# DISPATCH: Unraveling Security Patches from Entangled Code Changes

## Abstract

보안 패치는 컴퓨팅 리소스의 무결성, 기밀성, 가용성을 보존하는 데 중요합니다. 그러나 비보안 패치와 얽히게 되면 배포가 상당히 지연될 수 있습니다. 기존 코드 변경 분해 방법은 주로 코드 리뷰를 위해 설계되었으며 관련된 부분을 연결하는 데 중점을 둡니다. 그러나 보안 패치 탐지, 검증 및 배포를 복잡하게 만드는 부풀려진 보안 패치에 관련 없는 구문을 포함하는 경우가 많습니다. 본 논문에서는 얽힌 코드 변경에서 개별 보안 패치를 분리하기 위한 DISPATCH라는 패치 분해 시스템을 개발합니다. 먼저 변경된 구문과 종속성을 유지하여 세분화된 코드 수정을 캡처하는 PatchGraph라는 그래프 표현을 도입합니다. 다음으로, 동일한 취약점을 해결하는 변경된 구문을 개별 보안 패치로 그룹화하기 위해 2단계 패치 종속성 분석을 수행합니다. 첫 번째 단계는 관련 없는 구문을 제외하도록 경계가 정의되는 구문 수준에 중점을 둡니다. 두 번째 단계는 방문하지 않은 종속성을 분석하여 구문적 정확성과 기능적 완전성을 유지함으로써 패치의 적용 가능성을 보장합니다. 4개의 인기 있는 소프트웨어 리포지토리(즉, OpenSSL, Linux Kernel, ImageMagick, Nginx)에 대한 평가에서 DISPATCH는 얽힌 패치에서 개별 보안 패치를 91.9% 이상의 재현율(recall)로 분리할 수 있었으며, 정확도 면에서 기존 방법보다 최소 20% 이상 뛰어난 성능을 보였습니다.

## 1 Introduction

소프트웨어 패치는 컴퓨터 프로그램이나 시스템의 문제를 업데이트하거나 수정하기 위한 코드 변경 사항입니다. 이러한 문제에는 보안 취약점, 구현 버그, 성능 향상 및 호환성 개선이 포함됩니다. 보안 패치는 소프트웨어 취약점을 해결하여 컴퓨팅 리소스의 무결성, 기밀성 및 가용성을 유지하는 중요한 업데이트입니다 [[15]](#ref15). 이러한 패치를 신속하게 채택하면 전반적인 보안을 크게 강화하여 데이터 유출 및 사이버 공격으로부터 보호할 수 있습니다. 각 패치를 특정 목적에 집중시켜 이해, 테스트 및 배포를 용이하게 하는 것이 가장 좋습니다.

그러나 실제로는 보안 패치가 일반적으로 다른 패치와 얽혀 있습니다. 8개의 인기 있는 리포지토리에 대한 연구에 따르면 [[40]](#ref40), 보안 패치의 11%-39%가 수정과 관련 없는 변경 사항과 복잡하게 얽혀 있습니다. 또한 NVD [7]에서 무작위로 추출한 500개의 보안 패치 중 34.6%(173/500) (예: CVE-2019-13223 [[12]](#ref12) 및 CVE-2019-11338 [[13]](#ref13))가 하나 이상의 보안 패치 또는 비보안 패치와 얽혀 있습니다. 이러한 얽힌 패치를 직접 적용하면 예기치 않은 버그나 회귀가 발생하여 테스트 및 검증의 복잡성이 높아져 유지 관리 오버헤드가 증가할 수 있습니다. 또한 이러한 얽힌 패치는 보안 업데이트의 우선순위 지정, 효능 확인 및 호환성 보장을 방해하여 조직에 심각한 문제를 제기합니다. 결과적으로 이는 시스템의 신속한 보안을 방해하고 알려진 취약점에 대한 노출을 연장시킵니다. 따라서 얽힌 패치에서 각 보안 패치의 영향을 분리하고 이해하는 것이 중요합니다.

얽힌 패치를 풀기 위해 여러 노력이 있었습니다. 코드 변경의 구문 구조, 제어 흐름 및 데이터 종속성을 포괄하기 위해 다양한 유형의 프로그램 표현이 추출되면서 휴리스틱 기반 솔루션 [[20, 25, 27, 29, 30, 48, 50]](#ref20), 슬라이싱 기반 솔루션 [[25, 39, 56]](#ref25) 및 그래프 클러스터링 기반 솔루션 [[18, 22, 24, 32, 41, 44, 47, 51]](#ref18)을 포함한 다양한 클러스터링 접근 방식이 관련 구문을 별도의 그룹으로 클러스터링하기 위해 수행됩니다. 그러나 기존 솔루션의 주요 목적은 코드 리뷰를 용이하게 하는 것이므로 얽힌 패치에서 보안 패치를 풀 때 두 가지 문제에 직면합니다. 첫째, 보안 패치에 관련 없는 구문을 포함하기 쉽습니다. 보안 패치가 다른 비보안 패치와 데이터 종속성을 가질 때 기존 솔루션은 종종 이러한 얽힌 업데이트를 단일 패치로 잘못 처리합니다. 이는 부풀려진 보안 패치를 테스트하는 노력을 불필요하게 증가시킵니다. 둘째, 개별 보안 패치의 완전성을 보장할 수 없으며, 잠재적으로 패치의 일부를 다른 클러스터에 남겨둡니다. 이러한 불완전성은 두 가지 문제를 야기할 수 있습니다. (1) 보안 패치가 컴파일에 실패할 수 있고, (2) 컴파일되더라도 대상 취약점을 완전히 해결하지 못할 수 있습니다. 따라서 얽힌 패치에서 보안 패치를 정확하고 정확하게 푸는 것은 여전히 어려운 과제입니다.

본 논문에서는 얽힌 코드 변경에서 개별 보안 패치를 풀기 위한 DISPATCH라는 패치 분해 시스템을 제안합니다. 우리의 연구는 기존 접근 방식 [[22, 32, 47, 51, 56]](#ref22)이 업데이트된 구문을 무시하면서 패치 표현에서 삭제/추가된 구문만 보존한다는 관찰에 동기를 부여받았으며, 이는 더 필수적인 정보를 제공할 수 있습니다. 우리는 변경된 내용과 변경 방법(예: if 조건의 경계 확장)을 식별하고 동일한 목적으로 변경 사항을 그룹화하여 업데이트된 것을 고려합니다. 먼저 세분화된 구문 및 종속성 수정, 즉 diff 동작을 캡처하기 위해 PatchGraph라는 그래프 기반 패치 표현을 개발하여 개별 패치 생성을 위한 전제 조건을 제공합니다. 그런 다음 개별 패치의 범위를 결정하고 보안 패치를 혼합된 패치에서 분리하기 위해 2단계 패치 종속성 분석을 수행합니다. 제어/데이터 종속성 및 호출 관계에 의존하는 기존 종속성 분석 [[51, 56]](#ref51)과 달리, 우리는 diff 동작, 제어/데이터 종속성 변경 및 호출 관계 수정에 중점을 둡니다. 첫째, 관련 없는 변경 사항 없이 수정된 구문을 패치 세그먼트로 클러스터링하기 위해 구문 종속성 분석을 수행합니다. 둘째, 패치 세그먼트 간의 관계를 활용하여 개별 보안 패치를 생성하기 위해 세그먼트 종속성 분석을 수행합니다.

얽힌 패치가 주어지면, 우리는 diff 동작이라고 하는 세분화된 변경 사항(예: 삭제된 사용되지 않는 변수, 새 함수 호출 또는 업데이트된 반환 상태)을 나타내기 위해 PatchGraph를 개발합니다. 먼저 변경된 구문을 삭제/추가/업데이트의 세 가지 수정 유형으로 구분한 다음 삭제/추가된 식별자(예: 변수, 함수 및 반환 상태)를 삭제 또는 추가된 구문에서 식별하고 업데이트된 구문의 세분화된 토큰을 비교하여 수정된 구성 요소를 유지하고 변경되지 않은 구성 요소를 버립니다. 그렇게 함으로써 diff 동작을 수정된 구문 및 해당 변경된 데이터 종속성으로 성공적으로 제한할 수 있습니다. 마지막으로, diff 동작을 기존 프로그램 종속성(즉, CDG, DDG 및 호출 그래프)에 오버레이하여 PatchGraph를 구성합니다.

수정 종속적인 구문만 그룹화되도록 하기 위해 각 패치 세그먼트의 범위를 구체화하기 위해 패치 구문 수준 종속성 분석을 수행합니다. 먼저 동일한 유형의 diff 동작과 동일한 엔티티(예: 변수, 함수, 반환 값)로 연결된 구문을 수집하기 위해 diff 동작 기반 슬라이싱을 수행합니다. 그런 다음 동일한 문제를 해결하는 구문을 수집하기 위해 패턴 기반 슬라이싱을 도입합니다. 이러한 패턴¹은 300개 이상의 인기 있는 GitHub 리포지토리에 걸쳐 공개 패치 데이터셋 [[7, 53]](#ref7)에서 추출되었으며, 슬라이싱을 시작하기 위한 앵커 노드, 슬라이싱을 중지하기 위한 종료 기준이 있는 슬라이싱 방향, 보안 패치 세그먼트를 제안하기 위한 보안 속성 표시기로 구성됩니다. 따라서 우리는 하나의 보안 패치에 관련된 구문만 유지할 수 있습니다.

패치 세그먼트를 얻은 후, 종속 패치 세그먼트를 개별 패치로 추가로 병합하여 문법적 정확성과 기능적 완전성을 보장하는 세그먼트 수준 종속성 분석을 수행합니다. 여기에는 세 가지 단계가 포함됩니다. 즉, 정의되지 않은 변수 사용을 피하기 위해 프로시저 내 종속성을 유지할지 여부를 결정하고, 함수 선언 및 구현을 찾기 위해 프로시저 간 호출 종속성을 해결하고, 하나의 문제가 완전히 해결될 수 있도록 유사한 세그먼트를 그룹화하는 것입니다. 마지막으로, 개별 패치에 보안 패치 세그먼트와 비보안 패치 세그먼트가 모두 포함된 경우 사전 정의된 기준에 따라 개별 보안 패치로 간주해야 하는지 여부를 결정합니다. 예를 들어, 보안 패치 세그먼트가 비보안 패치 세그먼트(예: 새 기능 추가)에 의해 도입된 취약점을 수정하기 위한 것이라면 개별 비보안 패치로 처리합니다.

우리는 DISPATCH의 프로토타입을 구현하고 4개의 인기 있는 리포지토리, 즉 OpenSSL, Linux Kernel, ImageMagick 및 Nginx로 분해 정확성을 평가합니다. 리포지토리 크기는 84.5MB에서 6.71GB에 이릅니다. DISPATCH는 얽힌 패치에서 개별 보안 패치의 91.9%를 성공적으로 풀 수 있습니다. 또한 SPatch [[36]](#ref36](슬라이싱 기반 접근 방식), GPT-4 [[16]](#ref16](LLM 기반 접근 방식) 및 UTANGO [[32]](#ref32](GNN 기반 접근 방식)를 포함한 최신(SOTA) 접근 방식과 비교합니다. 실험 결과에 따르면 DISPATCH는 모든 기존 방법보다 성능이 뛰어나며 정확도가 최소 20% 향상되었으며, 제안된 패턴이 다양한 유형의 응용 프로그램에 일반화될 수 있음을 보여줍니다.

요약하면 다음과 같은 기여를 합니다.
*   얽힌 패치에서 개별 보안 패치를 풀기 위한 패치 분리 시스템을 설계합니다.
*   사전 패치 및 사후 패치 코드 간의 수정된 구문 및 종속성을 캡처하기 위한 새로운 그래프 기반 패치 표현을 제안합니다.
*   개별 패치의 범위를 구체화하기 위한 제한된 슬라이싱 방법을 개발합니다.
*   DISPATCH의 프로토타입을 구현하고 실험 결과는 보안 패치 분리에 효과적임을 보여줍니다.

## 2 Preliminaries

### 2.1 Entangled Patches

패치는 설치 시 다른 소프트웨어 구성 요소와 관련된 파일이나 장치 설정을 직접 수정하는 소프트웨어 구성 요소입니다 [[9]](#ref9). 패치는 GitHub 커밋 또는 Unix 계열 운영 체제에서 `diff` 명령으로 생성된 두 버전의 소프트웨어 간의 코드 차이 집합일 수 있습니다. 이상적으로 패치는 버그 수정, 기능 업데이트 또는 유지 관리와 같은 단일 관심사를 해결하는 데 중점을 두어야 합니다. 그러나 실제 세계에서는 패치에 여러 활동이 포함되어 다른 관심사를 다룰 수 있으며 [[40]](#ref40), 이를 **얽힌 패치(entangled patch)**라고 합니다. Listing 1은 새로운 사용자 프로필 속성을 추가하기 위한 비보안 패치(4행, 7-8행, 13행)와 Null 포인터 역참조 버그를 수정하기 위한 보안 패치(9-10행)의 두 가지 패치로 구성된 얽힌 패치를 보여줍니다.

<pre>
<code>
1 typedef struct {
2   char* name;
3   int age;
4 + char* email;
5 } UserProfile;
6 @@ void processUserProfile (UserProfile* userProfile,
7 - char* newName, int newAge) {
8 + char* newName, int newAge, char* newEmail) {
9 +   if (userProfile == NULL)
10 +    return;
11    userProfile->name = newName;
12    userProfile->age = newAge;
13 +  userProfile->email newEmail;
14    print("Updated user profile
");
</code>
</pre>

**Listing 1: Security patch entangled with non-security patch.**

그러나 비보안 패치의 함수 서명 업데이트로 인해 사용자는 버전 호환성 문제로 전체 패치를 거부할 수 있으며, 이로 인해 비보안 패치와 별도로 적용될 수 있는 보안 패치의 전파가 방해받을 수 있습니다. OpenSSL에서 339개의 닫힌 풀 리퀘스트를 분석했으며, 이 중 200개는 무작위로 선택된 병합되지 않은 요청이고 139개는 모두 병합된 요청입니다. 이 중 221개는 C 코드를 포함하며, 90개(40.7%)가 얽힌 것으로 식별되었습니다. 90개의 얽힌 패치 중 63개(70%)의 풀 리퀘스트는 병합되지 않았고, 27개(30%)만 병합되었습니다. 이는 얽힌 패치를 채택하는 데 따르는 어려움을 보여줍니다. 사례 연구의 자세한 통계는 부록 A에 제공됩니다.

사용자가 얽힌 패치의 구성을 이해하고 패치의 어떤 부분을 적용해야 할지 결정하는 데 도움을 주기 위해, 얽힌 패치에서 개별 패치를 분리하는 것이 중요합니다. 본 논문에서는 **개별 패치(individual patches)**를 단일 관심사를 해결하고 대상 소프트웨어에 별도로 적용할 수 있는 패치로 지칭합니다.

### 2.2 Program Dependencies

프로그램 종속성은 코드 구문, 실행 논리 및 코드 의미를 이해하는 데 중요한 역할을 합니다. 프로그램 종속성에는 데이터 종속성, 제어 종속성, 호출 종속성의 세 가지 주요 유형이 있습니다. 프로그램의 데이터 종속성은 프로그램 문이 이전 문의 데이터를 참조할 때 발생하며, 제어 종속성은 프로그램 문의 실행이 이전 제어 문의 결과에 따라 달라지는 상황을 나타냅니다. 호출 종속성은 함수 또는 프로시저 간의 관계를 나타냅니다. 프로그램 종속성은 단일 버전의 코드에서 정보를 파악하는 데 중점을 둡니다.

두 버전의 코드를 포함하는 패치 코드 변경 사항을 더 잘 이해하려면 프로그램 종속성 정보를 확장하여 두 버전 간의 차이점을 포괄하는 것이 중요합니다. 본 논문에서는 코드 변경에서 삭제/추가/업데이트된 동작을 기록하기 위해 **diff 동작(diff behavior)**이라는 새로운 유형의 프로그램 종속성을 도입합니다. 자세한 설명은 §5에서 제공됩니다. 우리는 diff 동작을 기존의 제어 종속성 그래프(CDG), 데이터 종속성 그래프(DDG) 및 호출 그래프(CG)와 통합하여 수정된 구문(예: 새 변수 선언 및 변경된 변수 정의) 및 업데이트된 종속성(예: 새 데이터 연결, 변경된 조건부 제어 종속성, 수정된 변수 할당 및 업데이트된 함수 활용)에 대한 세부 정보를 제공합니다.

### 2.3 Program Slicing

프로그램 슬라이싱은 크고 복잡한 프로그램의 이해와 분석을 관련 부분(즉, 슬라이스)에만 집중하여 단순화하는 프로그램 분석 기술입니다 [[54]](#ref54). 슬라이싱은 프로그램 지점의 변수에서 시작하여 지정된 기준(예: 홉 수, 끝)이 충족될 때까지 종속성 에지(예: 데이터 종속성, 제어 종속성 또는 둘 다)를 따라 프로그램을 순회합니다. 우리는 관련 문을 유지하고 관련 없는 문을 제거하기 위한 시작점과 기준을 지정하는 제한된 프로그램 슬라이싱 기술을 개발합니다. 자세한 내용은 §6.2에서 찾을 수 있습니다.

## 3 A Motivating Example

그림 1의 예를 사용하여 DISPATCH가 비보안 패치와 얽힌 개별 보안 패치를 분해하는 방법을 보여줍니다. 문장 수준에서 패치를 대략적으로 분석하는 기존 방법[[36, 44]](#ref36)과 달리, 우리는 종속성 수준과 토큰 수준에서 변경 사항을 삭제, 추가 또는 업데이트로 분류하여 미세한 접근 방식을 채택합니다. 또한, 종속성을 드러내고 종속성이 있는 한 문장을 그룹화하는 것을 목표로 하는 코드 검토용 분해 방법과 달리, 우리는 원래 기능을 손상시키지 않고 다시 적용할 수 있는 개별 패치에 대한 경계를 명시적으로 정의합니다. DISPATCH는 PatchGraph라는 새로운 그래프 기반 패치 표현을 구성하고 종속성 분석을 수행하여 개별 패치를 생성하는 두 단계로 구성됩니다.

**Understanding an Entangled Patch.** 그림 1(a)는 보안 패치(18-21행)와 비보안 패치(4-6행, 10-15행)로 구성된 얽힌 패치를 보여줍니다[[43]](#ref43). 3행에서 5행까지, 사전 패치는 두 개의 메모리 공간을 할당한 다음 두 메모리 할당에 대한 실패를 확인합니다. 그러나 첫 번째 할당이 실패하면 두 번째 확인을 수행할 필요가 없습니다. 따라서 사후 패치는 `db`(6행)의 성공적인 할당 후에 `em`(11행)을 할당하여 메모리 할당을 최적화합니다. `OPENSSL_malloc`(4행)을 사용하여 `em`을 할당하고 `memset`(10행)으로 0으로 설정하는 대신, 사후 패치는 `OPENSSL_zalloc`(11행)으로 이 두 단계를 수행합니다. 위의 변경 사항은 취약점을 수정하지 않고 프로그램 구조만 최적화하므로 비보안 패치에 속합니다. 18행에서 21행까지, `OPENSSL_free` 함수는 해제 작업 전에 민감한 정보가 포함된 메모리를 지우는 `OPENSSL_clear_free`로 대체되어 메모리 누수를 방지하는 보안 패치를 나타냅니다.

변수 `em`에 대한 데이터 종속성(즉, 4행과 19행, 11행과 21행)으로 인해 기존 데이터 종속성 기반 패치 분해 솔루션[[22, 32, 47, 51, 56]](#ref22)은 그림 1(a)의 모든 변경된 코드를 단일 패치로 간주합니다. 그러나 21행의 `em` 값은 11행이 적용되었는지 여부에 관계없이 `em`의 값이 변경되지 않기 때문에 11행과 독립적입니다. 따라서 우리는 이를 두 개의 개별 패치로 간주해야 합니다.

**Representing a Patch with PatchGraph.** 수정된 내용과 수정 방식을 파악하기 위해, 우리는 diff 동작을 도입하고 이를 기존 프로그램 종속성 그래프(즉, DDG 및 CDG)와 통합하여 PatchGraph로 만듭니다. 그림 1(b)에서 볼 수 있듯이, 왼쪽 부분은 패치의 CDG 및 DDG입니다(공간 제약으로 인해 단순화됨). 그림 1(b)의 오른쪽 부분에서는 주어진 패치에 대해 세 가지 추가적인 diff 동작이 식별됩니다: (1) 4, 10, 11행에서 `em`에 대한 메모리 할당 함수 변경, (2) 5행의 조건문을 6행과 12행의 두 `if` 검사로 분할, (3) 18행과 20행, 19행과 21행 사이의 함수 업데이트, 여기서 더 안전한 함수가 이전 함수를 대체합니다. 사전 및 사후 패치의 CDG, DDG 및 diff 동작을 결합하여 PatchGraph는 패치 코드 변경의 목적을 더 잘 이해하기 위해 패치 코드 변경에 대한 포괄적인 보기를 제공합니다.

**Unraveling a Patch with Dependency Analysis.** PatchGraph가 주어지면, 우리는 수정 종속적인 변경 사항을 개별 패치로 그룹화하기 위해 2단계 패치 종속성 분석을 제안합니다. 각 패치 세그먼트의 범위를 결정하기 위해 미리 정의된 기준으로 슬라이싱을 수행하는 문장 수준 분석과, 문법 정확성 및 기능 완전성을 보장하기 위해 패치 세그먼트 간의 방문하지 않은 종속성을 분석하고 필요한 것을 유지하는 세그먼트 수준 분석이 있습니다.

**Statement Dependency Analysis.** 코드 문에 대해 diff 동작 유도 슬라이싱과 패턴 유도 슬라이싱을 모두 수행합니다. 먼저, 세 가지 유형의 diff 동작이 슬라이싱을 안내하는 데 사용됩니다. 슬라이싱 결과는 그림 1(c) ①과 같이 세 개의 세그먼트(즉, s1, s2, s3)입니다. 그중에서 s3(18-21행)는 보안 함수 교체를 포함하므로 보안 패치 후보로 간주합니다. 그런 다음, 앵커 노드, 종료 기준이 있는 슬라이싱 방향 및 보안 속성 표시기를 포함한 경험적 지식에서 파생된 패치 패턴에 따라 PatchGraph를 슬라이싱합니다. 그림 1(c) ②에서 볼 수 있듯이, 앵커 노드는 예외 값(12행)을 확인하는 if 문이며, 오류 처리 문(13행 및 14행)을 얻기 위한 순방향 슬라이싱과 `em`의 할당(11행)을 얻기 위한 역방향 슬라이싱이 있습니다. 이러한 방식으로 패치 세그먼트 s4(11-14행)를 얻고 완전한 오류 처리 프로세스로 인해 보안 패치 후보로 식별합니다. 위의 diff 동작 유도 슬라이싱 및 패턴 유도 슬라이싱 후, 우리는 개별 패치를 생성하기 위한 기본 구성 요소 역할을 하는 네 개의 패치 세그먼트(s1-s4)를 얻습니다.

**Segment Dependency Analysis.** 세그먼트 수준 분석은 컴파일 및 문법 정확성을 보장하기 위해 패치 세그먼트 간의 방문하지 않은 종속성을 보존해야 하는지 여부를 재검토합니다. 그림 1(c)에서 볼 수 있듯이, s1과 s2 간의 종속성 및 s1과 s4 간의 종속성은 필수적입니다. s1과 s3, s3과 s4 간의 종속성은 이러한 종속성에 관계없이 `em` 및 `db`의 값이 변경되지 않으므로 불필요한 것으로 간주됩니다. 필수 종속 세그먼트를 병합한 후, 우리는 두 개의 개별 패치, 즉 s1+s2+s4와 s3를 얻습니다. 그런 다음, 각 개별 패치에 포함된 보안 패치 후보를 추가로 확인하여 개별 패치가 보안 패치인지 여부를 결정합니다. 11-14행의 추가된 `em` 확인 및 오류 처리가 사전 패치의 5행에서 이미 수행되었으므로, s1+s2+s4(5행과 11-14행 모두 포함)는 실제로 새로운 보안 검사를 도입하지 않습니다. 따라서 우리는 이를 비보안 패치로 간주합니다. 마지막으로, 원래의 얽힌 패치를 두 개의 개별 패치로 분해합니다: 4행에서 15행에 걸친 비보안 패치와 18행에서 21행을 포함하는 보안 패치, 그림 1(c)와 같습니다.

<figure>
    <img src="assets/Figure_1.png" alt="Figure 1">
    <figcaption>
        <p>Figure 1: A motivating example of separating a security patch from a non-security patch in an entangled patch.</p>
    </figcaption>
</figure>

## 4 System Overview

DISPATCH는 얽힌 보안 패치를 개별 패치로 분해하며, DISPATCH의 전체 워크플로는 그림 2에 설명되어 있습니다. 버전 차이, OSS 패치 또는 Git 커밋이 주어지면 DISPATCH는 수정된 구문과 종속성(즉, diff 동작)을 추출하여 그래프 표현(즉, PatchGraph)으로 나타내는 것으로 시작합니다. 다음으로, 함께 적용해야 하는 수정된 문(즉, 개별 패치)을 그룹화하기 위해 패치 종속성 분석을 수행합니다. 패치 종속성 분석은 두 가지 다른 수준에서 수행됩니다: (1) 종속 수정이 패치 세그먼트로 그룹화되는 문장 수준, (2) 종속 패치 세그먼트가 개별 패치로 결합되는 세그먼트 수준.

<figure>
    <img src="assets/Figure_2.png" alt="Figure 2">
    <figcaption>
        <p>Figure 2: Overview of DISPATCH: ① PatchGraph construction; ② statement dependency analysis; ③ segment dependency analysis.</p>
    </figcaption>
</figure>

### 4.1 Patch Representation with PatchGraph

구문 구조를 기록하고 단일 버전의 코드에서 프로그램 종속성을 캡처하는 데 중점을 둔 기존 프로그램 그래프 표현(예: AST 및 PDG)과 달리, 패치 표현은 두 버전 간의 변경된 구문과 종속성을 캡처할 수 있어야 합니다. 이전 방법[[44, 52]](#ref44)은 사전 패치 및 사후 패치 그래프 표현을 직접 병합하여 그래프가 분리되고, 부적절하며, 중복되게 만듭니다. 예를 들어, 그림 3의 1행과 2행은 동일한 코드 라인을 참조함에도 불구하고 에지로 연결되거나 업데이트된 것으로 표시되지 않습니다. 또한, `*p`는 변경되지 않은 상태로 유지되지만 관련된 종속성은 여전히 유지됩니다. 직접 병합은 미세한 수정을 강조하지 못하게 하고 변경된 문과 변경되지 않은 문을 구별하지 못하게 하여 동일한 목적을 수행하는 변경 사항을 집계하는 데 도움이 되지 않습니다. 이 격차를 메우기 위해, 우리는 실제 미세한 변경 사항을 설명하기 위해 **diff 동작**을 도입하고 모든 diff 동작을 PatchGraph로 통합하여 패치를 나타냅니다.

### 4.2 Patch Dependency Analysis

얽힌 패치를 나타내는 PatchGraph가 주어지면, 패치 종속성 분석을 통해 큰 그래프를 더 작은 하위 그래프로 분해하여 개별 패치를 얻습니다. 데이터 또는 제어 종속성에 따라 클러스터링하는 기존 프로그램 종속성 분석[[51, 56]](#ref51)과 달리, 패치 종속성 분석은 diff 동작(즉, 구문 및 종속성 삭제, 추가, 업데이트)을 종속 노드를 연결하는 주요 종속성으로 취급합니다. 이를 달성하기 위해, 우리는 문장 수준 및 패치 세그먼트 수준 분석을 수행합니다.

**Patch Statement Dependency Analysis.** 문장 수준 종속성 분석 중에, 우리는 동일한 목적을 위해 코드 변경 사항을 집계하는 것을 목표로 합니다. 여기서 수정 범위를 정의하는 방법, 특히 슬라이싱을 시작할 위치와 종료할 시점이 어렵습니다. 예를 들어, 그림 1(a)에서 19행은 10행에 데이터 종속적이지만, 두 개의 개별 패치에 속하므로 각각에 대한 범위를 정의해야 합니다. 이를 해결하기 위해, 우리는 수정 종속적인 문을 패치 세그먼트로 그룹화하기 위해 **패턴 유도 슬라이싱**이라는 새로운 제한된 슬라이싱 메커니즘을 제안합니다. 우리는 앵커 노드로 슬라이싱을 시작하고, 제약 조건에 따라 프로그램 슬라이싱을 수행하고 종료하여 패치 세그먼트를 형성하고, 보안 속성 표시기로 보안 패치 세그먼트 후보를 식별하는 데 사용되는 보안 및 비보안 패치 패턴 집합을 경험적으로 요약합니다. 이러한 방식으로, 얽힌 패치는 여러 패치 세그먼트로 분할되고, 각 패치 세그먼트는 하나의 문제(예: 변수 초기화/재할당, 함수 사용 업데이트)를 해결합니다.

**Patch Segment Dependency Analysis.** 각 패치 세그먼트가 의도된 기능(기능적 정확성)을 방해하지 않고 개별적으로 적용될 수 있도록(문법적 정확성) 보장하기 위해, 우리는 슬라이스된 패치 세그먼트 간의 종속성을 추가로 분석하고 필수 종속성이 있는 세그먼트를 병합하여 최종 개별 패치를 생성합니다. 개별 패치가 보안 패치인지 아닌지를 추가로 확인하기 위해, 우리는 개별 패치를 구성하는 패치 세그먼트를 분석합니다. 개별 패치에 한 가지 유형의 패치 세그먼트만 있는 경우, 보안 특성은 세그먼트의 레이블과 일치합니다. 개별 패치가 보안 패치 세그먼트와 비보안 패치 세그먼트로 동시에 구성된 경우, 우리는 그것이 보안 패치인지 확인하기 위해 추가 분석을 수행합니다.

## 5 Patch Representation

그림 3에서 볼 수 있듯이, 우리는 필수적인 diff 동작을 기존 프로그램 종속성에 오버레이하여 PatchGraph를 구성합니다. 먼저, 기존 프로그램 그래프 표현, 즉 추상 구문 트리(AST), CDG, DDG 및 호출 그래프(CG)를 생성합니다. 그중에서 사전 패치 및 사후 패치 AST는 삭제/추가/업데이트된 문과 구성 요소(예: 변수, 함수, 값, 문자열)를 찾는 데 사용됩니다. 사전 패치 및 사후 패치 CDG, DDG 및 CG는 수정된 종속성을 인식하는 데 사용됩니다. 그런 다음, 문장 수준에서 diff 동작을 식별합니다. diff 동작을 기존 종속성 위에 통합함으로써, 우리는 패치 파일을 정확하게 나타내는 PatchGraph를 갖게 됩니다.

<figure>
    <img src="assets/Figure_3.png" alt="Figure 3">
    <figcaption>
        <p>Figure 3: The workflow of PatchGraph construction.</p>
    </figcaption>
</figure>

### 5.1 Diff Behavior Indentification

우리는 패치의 미세한 코드 변경을 나타내기 위해 diff 동작을 도입합니다. diff 동작은 사전 패치와 사후 패치 문 사이의 수정 세부 정보를 설명합니다. 세 가지 유형의 수정이 있으며, 이를 사용하여 변경된 문과 토큰을 각각 설명합니다.

*   **Deleted.** 삭제된 문은 사전 패치에는 존재하지만 사후 패치에는 없는 문을 나타냅니다. 삭제된 문의 토큰은 삭제된 구성 요소로 간주됩니다.
*   **Added.** 추가된 문은 사후 패치에는 있지만 사전 패치에는 없는 문을 나타냅니다. 추가된 문의 토큰은 추가된 구성 요소로 간주됩니다.
*   **Updated.** 이러한 문은 사전 패치와 사후 패치 노드 모두에 존재하지만 약간의 변형이 있습니다. 패치에서 업데이트된 문은 일반적으로 쌍으로 제공되며(일부 문이 여러 줄로 나뉘거나 여러 문이 하나로 병합된 경우 제외), 하나는 사전 패치에서, 다른 하나는 사후 패치에서 가져오며, 업데이트된 구성 요소를 속성으로 사용하여 이러한 쌍을 연결하기 위해 diff 동작 에지를 도입합니다. 업데이트된 문의 구성 요소는 변경되었는지 여부를 확인하기 위해 비교해야 합니다. 변경된 경우 삭제, 추가 또는 업데이트 유형으로 추가 태그가 지정됩니다.

diff 동작을 캡처하기 위해, 먼저 삭제/추가/업데이트된 문을 식별한 다음 수정된 토큰을 인식하여 미세한 실제 업데이트를 찾습니다. 그런 다음, diff 동작을 추출하여 PatchGraph 구성을 위해 노드 또는 에지 속성을 사용하여 기록합니다.

**Identifying Deleted/Added/Updated Statements.** GitHub 분할 보기 [14]에서 패치의 삭제, 추가 및 업데이트된 문을 식별하는 방법을 배웁니다. 분할 보기(그림 2 참조)에서 볼 수 있듯이, 삭제된 문은 왼쪽의 빨간색으로만 표시되고 오른쪽에는 녹색 문이 없습니다. 추가된 문은 오른쪽의 녹색으로만 표시되고 왼쪽에는 빨간색 문이 없습니다. 업데이트된 문은 왼쪽에 빨간색 삭제가 있고 오른쪽에 녹색 추가가 있는 문입니다. 먼저 각 덩어리 헤더(예: `@@ -7 +7 @@ void func_name (int a)`)를 사용하여 각 덩어리를 식별하고 각 줄의 시작 부분에 있는 "-" 및 "+" 접두사를 인식하여 덩어리 내의 삭제 및 추가된 문을 결정합니다. 다음으로, 각 덩어리 내의 추가 및 삭제된 문을 비교합니다. 추가된 문과 삭제된 문이 동일한 문 유형(예: 함수 선언)을 공유하고 공통 변수(예: 함수 호출 문의 함수 매개변수 또는 할당 문의 왼쪽 변수)를 갖는 경우, 이를 업데이트된 문으로 쌍을 이룹니다. 또한, 하나의 문이 여러 개로 나뉜 경우(예: 하나의 if 검사가 두 개로 나뉨)와 여러 문이 하나로 병합된 경우(예: 여러 동일한 유형의 선언 문이 한 줄로 병합됨)도 고려합니다. 이에 따라 주어진 패치에 대해 삭제, 추가 및 업데이트된 문을 쉽게 인식할 수 있습니다.

**Identifying Deleted/Added/Updated Components.** 삭제/추가/업데이트된 문이 주어지면, 우리는 미세한 구성 요소를 인식합니다. 삭제된 문의 모든 필요한 요소(예: 매개변수, 변수, 함수, 조건, 분기, 루프 및 반환 값)를 삭제된 구성 요소로 식별합니다. 마찬가지로 추가된 구성 요소를 검색합니다. 업데이트된 문에서는 먼저 쌍을 이룬 문 간의 토큰을 비교하여 변경되지 않은 토큰을 제거합니다. 그런 다음, 사전 패치 문에만 있는 구성 요소를 삭제된 것으로, 사후 패치 문에만 있는 구성 요소를 추가된 것으로, 사전 패치 및 사후 패치 문 모두에 있는 구성 요소를 업데이트된 것으로 식별합니다.

**Identifying Diff Behaviors.** 우리는 구성 요소 유형과 해당 삭제된 토큰에 따라 삭제된 코드 동작을 3-튜플(수정 유형, 토큰 유형, 토큰 세부 정보), 예를 들어 (deleted, assignment, *q)을 사용하여 설명합니다. 마찬가지로 추가된 동작을 설명합니다. 업데이트된 동작의 경우, 구성 요소의 유형과 세부 정보 외에도 두 문의 식별자가 동작을 완료해야 합니다. 우리는 위의 동작을 설명하기 위해 4-튜플(수정 유형, 토큰 유형, 쌍을 이룬 문 ID, 토큰 세부 정보)을 채택합니다. 예를 들어, 그림 3에서 8행과 9행 사이의 diff 동작은 (updated, function, pre_8: post_9, free: clear_free)로 표시됩니다. 캡처된 diff 동작은 PatchGraph의 노드 및 에지의 속성을 나타냅니다.

### 5.2 PatchGraph Construction

패치 코드 변경을 모델링하기 위해, 우리는 diff 동작과 기존 프로그램 표현(즉, CDG, DDG, CG)을 PatchGraph라는 공동 구조로 통합합니다. PatchGraph를 구성하기 위해, 먼저 사전 패치 및 사후 패치 코드에 대한 CDG, DDG, CG를 생성합니다. CDG, DDG, CG의 각 노드는 문이고 에지는 두 문 노드 간의 종속성(즉, 제어 종속성, 데이터 종속성, 호출자-피호출자 관계)을 보여주므로, 이를 하나의 그래프로 병합하고 그 위에 diff 동작을 추가할 수 있습니다. 우리는 (V, E)를 사용하여 PatchGraph를 설명하며, 여기서 V는 노드 집합이고 E는 방향성 에지 집합입니다.

**Nodes in PatchGraph.** PatchGraph의 노드는 패치 파일의 문이며, 우리는 5-튜플(id, 버전, 코드, 유형, 속성)을 사용하여 노드 집합 V를 나타냅니다. 우리는 패치 파일을 구문 분석하여 사전 패치 및 사후 패치의 줄 번호를 노드 ID 및 노드 버전(버전 ∈ {pre-patch, post-patch})으로 나타내는 노드를 얻습니다. 그런 다음, 문을 쌍으로 연결하여 각 문의 노드 유형을 인식합니다: 공식적으로, 유형 ∈ {deleted, added, updated, unchanged}. 문 유형이 주어지면, 토큰에서 노드 속성을 추출합니다. 노드 유형이 업데이트된 경우, 쌍을 이룬 노드 ID를 속성에 추가합니다. 노드 유형이 삭제/추가된 경우, 수정된 내용을 속성에 추가합니다. 예를 들어, 그림 3의 노드 중 하나는 (pre-8, pre-patch, free(p);, updated, post-9:clear_free(p);)로 설명될 수 있습니다.

**Edges in PatchGraph.** 방향성 에지 집합 E는 6-튜플(id₁, id₂, 버전, 수정 유형, 에지 유형, 속성)으로 표시되며, 여기서 id₁ 및 id₂는 시작 및 끝 노드의 ID를 나타냅니다. 버전은 노드가 존재하는 위치, 즉 사전 패치, 사후 패치 또는 둘 다를 반영합니다. PatchGraph에는 네 가지 유형의 에지가 있습니다: (1) 사전 패치 CDG 및 사후 패치 CDG의 에지, (2) DDG의 삭제/추가/업데이트된 변수에 대한 에지, (3) 사전 패치 CG 및 사후 패치 CG의 에지, (4) diff 동작에 의해 도입된 업데이트된 문 쌍을 연결하는 에지. 우리는 수정 유형, 에지 유형 및 속성을 함께 사용하여 이러한 미세한 수정을 기록하며, 여기서 수정 유형 ∈ {deleted, added, updated, unchanged}이고 에지 유형 ∈ {CDG, DDG, CG, diff behavior}입니다. 속성은 CDG 에지, DDG 에지에 대한 정의/사용된 변수, CG 에지에 대한 피호출자 함수 또는 diff 동작에 의해 식별된 수정된 토큰 유형 및 토큰 세부 정보를 기록합니다. 예를 들어, 그림 3의 8행과 9행 사이의 에지는 (pre-8, post-9, both, updated, diff behavior, function |free:clear_free)로 설명됩니다.

## 6 Individual Patch Generation

PatchGraph에 표현된 상세한 변경 사항이 주어지면, 우리는 얽힌 패치를 여러 개별 패치로 분할하기 위해 프로그램 슬라이싱을 수행합니다. 수정된 구문을 수정 목적에 매핑하는 패치 패턴 집합을 경험적으로 제안하여 슬라이싱을 안내함으로써, 우리는 각 문제가 하나의 문제를 해결하는 패치 세그먼트를 얻습니다. 또한, 각 개별 패치의 완전성을 보장하기 위해, 우리는 패치 세그먼트 간의 관계를 추가로 분석하여 수정 종속적인 패치 세그먼트를 병합하고 다시 적용될 수 있도록 보장합니다. 워크플로는 그림 4에 나와 있습니다.

<figure>
    <img src="assets/Figure_4.png" alt="Figure 4">
    <figcaption>
        <p>Figure 4: The workflow of individual patch generation.</p>
    </figcaption>
</figure>

### 6.1 Patch Pattern Discovery

각 개별 패치의 범위를 결정하기 위해, 우리는 먼저 각 슬라이스의 시작 및 종료 문을 찾는 데 도움이 될 수 있는 패치 패턴 집합을 경험적으로 요약하고, 슬라이스가 보안 수정을 수행하는지 여부에 대한 해석을 제공합니다. 이를 위해, 우리는 NVD [7] 및 PatchDB [53]에서 식별된 5k 보안 패치를 수동으로 분석하여 diff 동작에 대한 보안 패턴을 요약합니다. 그런 다음, 비보안 패치 패턴을 위해 Github에서 5k 비보안 커밋을 무작위로 선택합니다. 소프트웨어 보안 분야에서 3년 이상의 경험을 가진 3명의 박사 과정 학생에 의한 교차 검증 후, 우리는 12가지 유형의 보안 패치 패턴과 3가지 유형의 비보안 패치 패턴을 요약합니다. 이 연구에서는 C/C++에 중점을 두는데, 이는 보안 문제가 가장 많은 언어이기 때문입니다 [31]. 패턴 집합은 확장 가능하며, 사용자는 특정 응용 프로그램 시나리오에 따라 새로운 패턴을 정의할 수 있습니다.

**Patch Pattern Structure.** 각 개별 패치를 나타내고 보안 특성에 대한 통찰력을 제공하기 위해, 우리는 앵커 노드, 종료 기준이 있는 슬라이싱 방향, 보안 속성 표시기로 구성된 새로운 구조를 도입합니다. 구체적으로, 앵커 노드는 슬라이싱을 시작하는 시작 문 역할을 합니다. 종료 기준이 있는 슬라이싱 방향은 어떤 문이 앵커 노드와 연관될지를 결정합니다. 지정된 종료 기준이 없으면 해당 방향으로 슬라이싱을 수행하지 않습니다. 이러한 슬라이싱 결과는 하나의 목적을 완료하는 문 집합입니다. 우리는 이를 **패치 세그먼트**라고 부릅니다. 패치 세그먼트가 보안 관련인지 여부를 결정하기 위해, 우리는 보안 속성 표시기를 추가로 정의합니다. 보안 속성 표시기와 일치하지 않는 슬라이스는 비보안 패치 세그먼트로 레이블이 지정됩니다. 패턴은 4-튜플로 표시됩니다: (앵커 노드, 순방향 슬라이싱 종료 기준, 역방향 슬라이싱 기준, 보안 표시기). 앵커 노드와 보안 표시기는 문 유형과 관련 키워드를 지정하고, 종료 기준은 선택된 종속성과 종료 문 유형을 정의합니다. 예를 들어, 그림 3의 5행과 6행은 *Add Sanity Check*에 대한 패턴 인스턴스를 보여줍니다. 앵커 노드는 `if` 키워드가 있는 조건문에 해당합니다. 순방향 슬라이싱은 제어 종속성에 의해 제한되며 `if` 검사가 끝나면 종료됩니다. 역방향 슬라이싱은 `if` 검사 내의 변수에 대한 업데이트를 식별하는 것으로 제한됩니다. 보안 표시기는 조건문에 `NULL`, `not NULL`, `MAX`, `MIN`, 기타 유효하지 않거나 경계 값 또는 음수 반환 상태와 같은 특정 키워드의 존재를 확인합니다.

**Security Patch Pattern.** 우리는 4가지 범주, 즉 온전성 검사, 함수 연산, 변수 연산 및 반환 문에서 12가지 보안 패턴을 요약하고 이러한 패턴을 위의 구조로 나타냅니다. 요약은 표 1에서 찾을 수 있으며 자세한 설명은 부록 B.1에 있습니다.

**Non-security Patch Pattern.** 보안 패치와 비보안 패치를 구별하기 위해 디버깅, 코드 리팩토링 및 새로운 기능을 포함한 비보안 패턴을 요약합니다. 요약은 표 1에서 찾을 수 있으며 자세한 설명은 부록 B.2에 있습니다.

### 6.2 Patch Statement Dependency Analysis

그런 다음, 우리는 개별 패치에 대한 후보 역할을 하는 패치 세그먼트를 생성하기 위해 맞춤형 프로그램 슬라이싱을 수행합니다. 이 프로세스에는 두 가지 방법이 포함됩니다: 유사한 변경 사항을 그룹화하기 위한 diff 동작 기반 클러스터링과 유사한 문제에 대한 문을 수집하기 위한 패턴 유도 슬라이싱.

**Diff Behavior Based Clustering.** 우리는 동일한 diff 동작으로 연결된 노드를 하나의 문제를 해결하는 패치 세그먼트로 그룹화하기 위해 슬라이싱을 수행합니다. 제한된 조건을 도입하거나 더 많은 메모리 관리 작업(예: 그림 1의 s3에서 `free()`)을 적용하는지 확인하여 보안 관련 패치 세그먼트인지 평가합니다.

**Slicing Guided by Patch Patterns.** 요약된 패턴에 따라, 우리는 개별 수정 목적을 위해 문을 클러스터링하기 위해 슬라이싱을 수행합니다. 우리는 요약된 패턴의 앵커 노드 정의와 일치하는 문에서 슬라이싱을 시작합니다. 특정 패턴에 대한 문에서의 하나의 슬라이싱은 한 번에 수행됩니다. 예를 들어, 그림 3의 5행은 `if` 문이기 때문에 *add sanity check* 패턴에 속하는 앵커 노드로 식별되었습니다. 각 앵커 노드에 대해, 정의된 종료 조건이 충족되거나 코드의 시작/끝에 도달할 때까지 지정된 종속성에 대해 역방향 및 순방향 슬라이싱이 수행됩니다. 예를 들어, 앵커 노드 5행이 주어지면, 우리는 검사 본문의 끝까지 순방향 슬라이싱을 수행하고 `p`의 새로운 선언을 찾기 위해 역방향 슬라이싱을 수행합니다. 따라서, `p`가 새로 정의되지 않았기 때문에 5행과 6행을 패치 세그먼트로 얻습니다. 생성된 슬라이스(즉, 패치 세그먼트)는 정의된 보안 지표에 따라 보안 또는 비보안으로 레이블이 지정됩니다. 예를 들어, 5행과 6행은 조건문에서 `NULL`을 확인하고 음수 상태를 반환하여 오류 처리 프로세스를 나타내므로 보안 패치 세그먼트입니다.

### 6.3 Patch Segment Dependency Analysis

우리의 최종 목표는 원래 기능을 방해하지 않고 하나의 문제를 완전히 해결할 수 있는 보안 패치를 생성하는 것입니다. 이를 위해 DISPATCH는 패치 세그먼트 간의 종속성을 추가로 분석하고 필요한 종속성을 공유하는 세그먼트를 개별 패치로 그룹화합니다. 그런 다음 DISPATCH는 각 개별 패치가 보안 패치인지 확인합니다.

#### 6.3.1 Patch Segment Integrator

현재 세그먼트가 다른 세그먼트에 의존하는지 여부를 확인하기 위해, 우리는 남아있는 프로시저 내 및 프로시저 간 종속성을 검사합니다. 또한, 동일한 문제가 한 번에 철저히 해결될 수 있도록 유사한 패치 세그먼트를 하나의 패치로 그룹화하기 위해 유사성 분석을 수행합니다.

**Intraprocedural Remaining Dependency Analysis.** 필수적인 데이터/제어 종속성을 가진 패치 세그먼트를 병합하기 위해, 먼저 함수 내의 방문하지 않은 종속성에 중점을 둡니다. 우리는 문법적 관점에서 사용되지 않은 CDG 및 DDG 에지의 필요성을 평가합니다. CDG 에지의 경우, 중첩된 문의 완전성을 보장하여 중첩된 세그먼트의 종속성을 유지합니다. 나중 패치의 변수가 새로 정의되고 할당된 경우 DDG 에지를 포함하며, 그렇지 않은 경우 종속성을 버립니다.

<pre>
<code>
1 diff --git a/.../v3_purp.c b/.../v3_purp.c
2 +const ASN1_INTEGER *X509_..._serial (X509 *x) {
3 + X509_check_purpose (x, -1, -1);
4 + return (x->akid != NULL? x->akid->serial: NULL);
5 +}
6 diff --git a/.../v3_purp.c b/.../v3_purp.c
7 +const GENERAL_NAMES *X509_..._ issuer (X509 *x) {
8 + X509_check_purpose (x, -1, -1);
9 + return (x->akid != NULL? x->akid->issuer: NULL);
10 +}
</code>
</pre>

**Listing 2: An example of similarity analysis.**

**Interprocedural Remaining Dependency Analysis.** 프로시저 간 분석은 수정되거나 새로 추가된 함수의 함수 호출과 같이 함께 적용되어야 하는 함수 및 파일 전반에 걸쳐 패치를 완료하는 것을 목표로 합니다. 이를 위해 호출자와 피호출자 간의 관계를 분석합니다. 피호출자 함수가 새로 추가되거나 피호출자의 매개변수가 변경된 경우, 호출 체인을 완료하기 위해 그들 사이의 호출 그래프 에지를 유지합니다. 또한, 프로시저 간 종속성 분석은 매크로의 정의와 사용을 처리하여 새로운 매크로 식별자를 식별하고 그들의 정의와 사용의 패치 세그먼트를 병합합니다.

**Patch Segment Similarity Analysis.** 위의 종속성 분석 외에도, 우리는 패치 세그먼트가 호출, 데이터, 제어 또는 수정 종속성 없이 동일한 유형의 취약점을 패치하기 위해 동일한 수정 구조를 공유할 수 있다는 격차를 메우기 위해 유사성 분석을 수행합니다. 예를 들어, Listing 2에서 두 함수는 x509 인증서를 처리하기 위해 동일한 패치 논리와 구조를 가지며, 함께 패치되어야 합니다. 패치 세그먼트 간의 유사성 분석을 계산함으로써, 동일한 문제가 하나의 개별 패치에서 철저하게 해결됩니다. 이러한 구문적 유사성을 캡처하기 위해, 우리는 패치 세그먼트 간의 순차적 유사성을 계산합니다. 순차적 유사성은 간단하고 효율적인 Levenshtein 거리 [55]를 사용하여 계산됩니다. 순차적 유사성이 0.9보다 클 때 두 세그먼트를 유사한 쌍으로 간주합니다.

#### 6.3.2 Individual Security Patch Identification

개별 패치가 보안 패치 세그먼트 또는 비보안 패치 세그먼트 중 한 가지 유형만 포함하는 경우, 패치 세그먼트의 레이블을 사용하여 개별 패치에 레이블을 지정합니다. 보안 패치 세그먼트와 비보안 패치 세그먼트를 동시에 포함하는 나머지 개별 패치의 경우, 두 가지 분석을 수행합니다. 첫째, 보안 패치 후보가 비보안 패치 세그먼트의 일부인 경우, 비보안 세그먼트의 목표가 보안 문제를 구체적으로 해결하는 것이 아니라 재구성, 디버깅, 리팩토링 또는 새로운 기능을 도입하는 것이라는 사실을 감안할 때, 이러한 개별 패치를 비보안으로 취급합니다. 둘째, 보안 패치 후보의 기능이 온전성 검사에서 동일한 조건에 대한 소스 코드를 포함하는지 비교하여 사전 패치에 이미 존재하는지 확인합니다. 보안 세그먼트의 조건이 사전 패치 코드에 이미 존재하는 경우(예: 그림 1의 s4), 개별 패치를 비보안 패치로 취급합니다. 나머지 개별 패치는 개별 보안 패치로 레이블이 지정됩니다.

## 7 Evaluation

이 섹션에서는 실제 프로젝트에 대한 실험을 수행하여 다음 연구 질문(RQ)에 답합니다.

*   **RQ1:** 얽힌 패치를 풀기 위한 DISPATCH의 정확성과 확장성은 무엇입니까? (§ 7.1)
*   **RQ2:** DISPATCH가 기준선보다 성능이 뛰어납니까? (§ 7.2)
*   **RQ3:** 개별 보안 패치를 식별할 때 DISPATCH는 어떻게 수행됩니까? (§ 7.3)
*   **RQ4:** 다른 소프트웨어에서 DISPATCH는 어떻게 수행됩니까? (§ 7.4)
*   **RQ5:** 복잡한 커밋을 분해할 때 DISPATCH는 어떻게 수행됩니까? (§ 7.5)

**Experiment Setup.** 우리의 실험은 Intel Core i7 1.8GHz CPU와 16GB 메모리를 갖춘 Ubuntu 22.04를 실행하는 컴퓨터에서 수행됩니다. 우리는 네 가지 인기 있는 소프트웨어, 즉 OpenSSL(446,747 LOC), Nginx(242,153 LOC), ImageMagick(874,459 LOC) 및 Linux Kernel(18,963,973 LOC)을 사용하여 DISPATCH의 성능과 추출된 패턴의 적용 범위를 평가합니다.

### 7.1 Accuracy and Scalability (RQ1)

제안된 시스템의 얽힌 패치 분해 효과를 평가하기 위해, 우리는 OpenSSL 1.1.1의 모든 두 인접 문자 버전 [10] 간의 차이에 DISPATCH를 적용합니다. 왜냐하면 문자 버전에는 더 많은 버그 수정 및 보안 패치가 포함되어 있고, 각 차이는 동시에 여러 얽힌 보안 및 비보안 패치를 포함하는 얽힌 패치를 나타내기 때문입니다. 그러나 커밋과 개별 패치 간에 항상 1대1 매핑이 있는 것은 아닙니다. 개별 패치는 여러 커밋으로 구성될 수 있으며, 커밋에는 여러 개별 패치가 포함될 수 있습니다. 따라서 우리는 이 23개 문자 버전 차이의 모든 개별 패치를 수동으로 식별하여 ground truth로 사용합니다. 우리는 평가 지표로 **정확 일치(Exact Match)**와 **정확도(Accuracy)**를 사용합니다. 이름에서 알 수 있듯이, 정확 일치는 DISPATCH에 의해 생성된 개별 패치가 ground truth와 줄 단위로 동일한 것을 의미합니다. 정확도는 정확하게 일치하는 개별 패치의 백분율을 나타냅니다.

**Accuracy.** 먼저 그림 5를 사용하여 OpenSSL 1.1.1의 모든 인접 문자 버전 차이에 대한 분해 정확도 결과의 누적 분포 함수(CDF)를 그립니다. 우리는 우리 시스템의 각 설계, 즉 패치로 슬라이싱, 패치 동작으로 슬라이싱, 패치 문 분석으로 슬라이싱, 패치 세그먼트 분석으로 슬라이싱에 의해 도입된 기여를 밝히기 위해 절제 연구를 수행합니다.

<figure>
    <img src="assets/Figure_5.png" alt="Figure 5">
    <figcaption>
        <p>Figure 5: CDF of unraveling accuracy on OpenSSL 1.1.1.</p>
    </figcaption>
</figure>

그림에서 볼 수 있듯이, 기존 슬라이싱(제어 및 데이터 종속성 기반)의 분해 정확도는 0%에서 68.97%까지 다양하며, 대부분 50% 미만에 분포되어 있습니다. 슬라이싱에 패치 동작을 추가한 후, 결과가 개선되고 최고의 정확도는 69.57%에 도달합니다. 그런 다음 패치 문 분석을 추가로 채택하면 분해 정확도는 25%에서 86.21% 범위에 있습니다. 마지막으로, 패치 세그먼트 분석을 통합한 후 DISPATCH는 최저 정확도 75%, 최고 정확도 100%로 최고의 성능을 보입니다.

OpenSSL 1.1.1의 각 문자 버전에 대한 분해 결과를 표 2에 나열합니다. 첫 번째 열은 OpenSSL의 두 연속 버전의 버전 번호를 나열하며, 각각 원본 및 패치된 소스 코드로 사용되었습니다. 두 번째 열은 수동으로 식별된 개별 패치의 수를 보고하며, 이는 ground truth 역할을 합니다. 세 번째에서 열네 번째 열은 기존 슬라이싱(3-5열), 패치 동작으로 슬라이싱(6-8열), 패치 동작 및 문 분석으로 슬라이싱(9-11열), 패치 동작, 문 분석 및 세그먼트 분석으로 슬라이싱(즉, DISPATCH)(12-14열)을 기반으로 한 얽힌 패치 분해 결과를 보여줍니다.

<figure>
    <img src="assets/Table_2.png" alt="Table 2">
    <figcaption>
        <p>Table 2: Ablation study results on patch unraveling in OpenSSL 1.1.1.</p>
    </figcaption>
</figure>

표 2에서 볼 수 있듯이, OpenSSL 1.1.1의 1025개 개별 패치 중에서 DISPATCH는 923개를 성공적으로 분해하여 평균 90.05%의 정확도를 나타내며, 이는 DISPATCH가 얽힌 버전 차이를 높은 정확도로 분해할 수 있음을 나타냅니다. 비교해 보면, DISPATCH의 성능은 diff 동작이 없는 기존 슬라이싱보다 약 50% 뛰어납니다. 또한, 절제 연구 결과에서 패치 동작과 문 분석이 도입되면 대부분의 경우 생성된 분해된 패치의 수가 감소하고 분해 정확도는 계속 증가합니다. 이는 패치 동작이 패치 코드 변경 간의 필수적인 정보를 제공하고, 패치 문 분석이 동일한 패턴으로 수정을 추가로 집계할 수 있음을 나타냅니다. f-g, h-i, o-p 버전의 경우, 패치 동작이 도입되면 분해된 패치의 수가 감소하는 반면, 패치 문 분석으로 수가 증가하여 패턴 유도 슬라이싱이 중복 종속성을 효율적으로 차단하지만 개별 패치를 얻기 위해서는 여전히 패치 세그먼트 분석이 필요함을 보여줍니다. 결과는 DISPATCH의 각 구성 요소의 중요성을 암시하며 함께 작동해야 할 필요성을 나타냅니다.

또한 DISPATCH가 분해에 실패하는 경우를 분석하고 세 가지 주요 이유를 요약합니다. 첫째, 동일한 수정 의미론이 다른 표현 방식을 가질 수 있습니다. 예를 들어, Listing 3에서 패치는 함수 이름과 해당 매크로 값을 변경하여 쿠키 크기를 확대하는 것을 목표로 합니다. 그러나 이 두 덩어리는 종속성이나 유사성이 없어 DISPATCH가 두 가지 유형의 수정을 통합하지 못하게 합니다. 둘째, 동일한 목적의 동일한 값이 다른 변수에 할당될 수 있습니다. 예를 들어, Listing 4에서 두 덩어리의 수정은 SSL 객체의 길이를 초기화하는 것을 목표로 합니다. 그러나 초기화 작업은 다른 변수 이름을 가진 다른 함수에서 발생하므로 이러한 의미론은 diff 동작 및 유사성 분석에 의해 캡처되지 않습니다. 셋째, DISPATCH는 간접 데이터 종속성을 캡처하지 못합니다. 예를 들어, Listing 5에서 `s->session`은 `ssl_session_st` 구조체에서 인스턴스화됩니다. `ssl_session_st` 구조체의 요소가 삭제되었으므로 다른 인스턴스도 삭제된 요소의 사용을 삭제해야 합니다. 그러나 DISPATCH는 2-홉 데이터 종속성을 캡처하지 못합니다. 이러한 경우, 우리의 의미 분석은 사전 패치와 사후 패치 간의 중요한 의미 차이를 감지하여 이러한 차이를 통합하지 못할 수 있습니다.

<pre>
<code>
1 diff --git a/ssl/packet_local.h b/ssl/packet_local.h
2 - || !PACKET_get_net_4 (&cookie, &tm)
3 + || !PACKET_get_net_8(&cookie, &tm)
4 diff --git a/.../_srvr.c b/.../..._srvr.c
5 -#define MAX_COOKIE_SIZE (...+4+2+EVP_MAX_MD_SIZE
6 +#define MAX_COOKIE_SIZE (...+8+2+EVP_MAX_MD_SIZE
</code>
</pre>

**Listing 3: Same update purpose with different presentations.**

<pre>
<code>
1 diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
2 + s->s3->tmp.psklen = 0;
3 diff --git a/.../statem_clnt.c b/.../statem_clnt.c
4 + s->s3->tmp.pmslen = 0;
</code>
</pre>

**Listing 4: Same value assignment to independent variables.**

<pre>
<code>
1 diff --git a/ssl/ssl_local.h b/ssl/ssl_local.h
2 - int peer_type;
3 diff --git a/.../statem_clnt.c b/...m/statem_clnt.c
4 - s->session->peer_type = certidx;
</code>
</pre>

**Listing 5: Missing critical data dependency.**

**Scalability.** 표 2, 그림 6 및 부록 D에서 볼 수 있듯이, 23개의 얽힌 패치(즉, 버전 차이)는 3-122개의 개별 패치(6-128 커밋)로 구성되며 4-716개의 수정된 파일과 103-15,645개의 변경된 LOC를 포함합니다. 이러한 얽힌 패치 중에서 DISPATCH는 일관되게 좋은 성능을 유지하여 DISPATCH가 큰 패치를 처리하는 확장성을 나타냅니다. 요약하면, PatchGraph 및 맞춤형 슬라이싱 메커니즘을 통해 DISPATCH는 얽힌 패치를 높은 정확도로 풀고 큰 얽힌 패치에 잘 확장할 수 있습니다.

### 7.2 Comparison with Baseline Models (RQ2)

일반적인 패치 분해에 대한 DISPATCH의 성능을 추가로 평가하기 위해, 우리는 SOTA 방법과 비교 실험을 수행합니다. 우리는 다른 범주의 세 가지 대표적인 연구를 선택합니다: SPatch [36] (슬라이싱 기반 접근 방식), GPT-4 [16] (LLM 기반 접근 방식), UTANGO [32] (GNN 기반 접근 방식). 이러한 기존 연구는 일반적인 패치 분해에만 초점을 맞추고 있으며 DISPATCH는 개별 보안 패치를 처음으로 푸는 것입니다.

**Comparison with SPatch.** SPatch는 패치를 여러 변경 단위(CU)로 분할하여 개별 패치로 만들고, 단일 편집 작업(추가, 삭제, 업데이트, 이동)의 코드 변경 사항을 하나의 CU로 통합합니다. 소스 코드가 공개되지 않았기 때문에 설계를 따라 재구현합니다.

표 3에서, OpenSSL 1.1.1의 1025개 개별 패치 중에서 SPatch는 405개를 성공적으로 분해하여 평균 39.51%의 정확도를 나타내며, 이는 SPatch가 얽힌 버전 차이를 푸는 데 제한적인 능력을 가지고 있음을 나타냅니다. 또한, 생성된 패치의 수가 ground truth보다 크고 생성된 패치의 평균 크기가 실제보다 훨씬 작다는 것을 알 수 있습니다. DISPATCH와 비교할 때, 결과의 이유는 세 가지 측면에서 비롯됩니다. 첫째, SPatch는 제어 흐름을 무시하여 중요한 실행 논리, 특히 매개변수가 없는 함수에 대해 누락됩니다. 둘째, SPatch는 호출 종속성 및 매크로 사용과 같은 프로시저 간 관계를 고려하지 않아 종속 편집 작업을 연결하는 데 실패합니다. 셋째, SPatch는 업데이트 편집 작업을 고려하지만, 변경 사항을 병합하기 위해 미세한 업데이트 정보를 속성으로 활용하는 것을 잊어버립니다. 요약하면, DISPATCH는 분해 정확도를 50.54% 증가시켜 SPatch보다 성능이 뛰어납니다.

**Comparison with GPT-4.** 대규모 언어 모델(LLM)은 코드 이해 작업, 즉 보안 패치 분석 [19, 28, 49]에 널리 사용되었습니다. 패치 분석에서 LLM의 성능은 프롬프트가 얼마나 잘 구성되었는지에 따라 종종 영향을 받습니다. 우리는 GPT-4를 선택하고 세 가지 내용 [19]으로 프롬프트를 설계합니다: (1) 기본 내용은 GPT-4가 해결하기를 원하는 작업을 간단히 제공하고, (2) 보상 내용은 "매우 잘 수행하면 넉넉하게 팁을 주겠다"와 같은 동기 부여 문구를 사용하고, (3) 처벌 내용은 "잘못 수행하면 벌금을 물게 될 것이다"라고 경고합니다. 두 가지 실험 설정: (1) 제로샷 및 (2) 퓨샷. 두 번째 설정의 경우, GPT-4에 두 가지 예제로 얽힌 패치를 풀도록 지시합니다. 그런 다음, GPT-4에 개별 패치를 식별하도록 요청합니다.

표 3에서, 우리는 기본 내용이 포함된 제로샷 결과를 보여주며, 이는 위의 여섯 가지 설정 중 최고입니다. 일곱 개의 빈 결과가 있으며, 그 이유는 두 가지 측면에서 비롯됩니다. 첫째, GPT-4는 최대 토큰 길이를 초과하는 버전 차이(예: a-b 및 b-c)를 처리할 수 없습니다. 둘째, 우리의 프롬프트는 GPT-4에 버전 차이를 분해하도록 요청한 다음 버전 차이를 제공하여 구성되므로 GPT-4가 지침을 잊어버릴 수 있습니다. 따라서 GPT-4는 관련 없는 답변(예: 0-a의 출력은 이미지임)으로 응답할 수 있습니다. SPatch와 비교할 때, GPT-4는 프로시저 간 의미론을 추출할 수 있지만, 이로 인해 GPT-4는 관련 함수에 속하면서 다른 목적을 해결하는 변경 사항을 함께 그룹화하여 생성된 패치의 수가 훨씬 작아지고 평균 크기가 훨씬 커집니다. 따라서 GPT-4는 얽힌 커밋을 이해하고 개별 패치를 식별하는 데 제한적인 능력을 가지고 있습니다.

**Comparison with UTANGO.** UTANGO는 컨텍스트 인식, 그래프 기반, 코드 변경 표현 학습 모델을 사용하여 얽힌 커밋을 분해합니다. 처음에는 각 토큰에 대해 GloVe 임베딩 [45]을 사용하고 평균 임베딩을 계산하여 각 문을 나타냅니다. 그런 다음, Label-GCN(Graph Convolutional Network) [21]을 활용하여 컨텍스트 정보를 임베딩에 통합합니다. 마지막으로, 응집 클러스터링 알고리즘 [38]을 적용하여 코드 변경 사항을 클러스터링합니다. UNTANGO는 Java/C# [6] 기반의 코드와 모델을 공개합니다. 우리는 OpenSSL로 GloVe 모델을 훈련하여 C/C++ 코드를 적절하게 임베딩한 다음, 공개된 모델에 임베딩을 제공하여 확장합니다. UNTANGO에서 사용된 원래 평가 지표는 개별 패치를 나타내는 올바른 클러스터에 얼마나 많은 문이 할당되었는지를 계산하는 것입니다. 우리는 생성된 패치의 완전성을 중요하게 생각하므로, 얼마나 많은 개별 패치가 정확하게 식별될 수 있는지를 평가합니다.

UTANGO의 논의에 따르면, 변경된 문의 수가 40개를 초과하면 정확도가 떨어집니다 [32]. 그러나 우리 데이터셋의 변경된 문의 최소 줄은 40개를 초과합니다. 또한, UTANGO는 Java/C#에서 훈련되었기 때문에 C/C++ 코드에 대한 이해가 제한적입니다. 또한, UTANGO는 프로시저 간 관계를 간과합니다. 공정한 비교를 위해, 우리는 함수 수준에서 UTANGO를 평가하며, 이는 분해당 변경된 문의 수를 제한합니다. 표 3에서 볼 수 있듯이, UTANGO는 평균 42.5%의 분해 정확도를 달성하여 40개 미만의 변경된 문으로도 개별 패치를 분해하는 데 제한적인 능력을 보여줍니다.

위의 비교를 통해, 우리는 기존 분해 접근 방식이 얽힌 버전 차이에서 개별 패치를 효과적으로 분해할 수 없다고 결론 내립니다. 또한, SPatch와 UTANGO는 보안 관련 개별 패치를 식별할 수 없습니다. 그들은 보안 패치와 비보안 패치를 구별하는 메커니즘이 부족하며, 보안 패치를 관련된 모든 업데이트와 혼합합니다.

<figure>
    <img src="assets/Table_3.png" alt="Table 3">
    <figcaption>
        <p>Table 3: Comparison with slicing, LLM, and GNN based patch unraveling solutions.</p>
    </figcaption>
</figure>

### 7.3 Unraveling Security Patch (RQ3)

DISPATCH가 개별 보안 패치를 분해하는 능력을 평가하기 위해, 우리는 CVE에 의해 색인된 공개 보안 패치와 이전 논문 [53, 57, 58]에 의해 주석이 달린 자동 보안 패치를 포함하여 OpenSSL 1.1.1의 23개 버전의 모든 개별 보안 패치를 고려합니다. 이들은 DISPATCH가 개별 보안 패치를 생성하는 데 대한 재현율과 정밀도를 계산하기 위한 ground truth로 사용되었습니다.

표 4에서 볼 수 있듯이, 504개의 ground-truth 보안 패치 중에서 465개가 DISPATCH에 의해 성공적으로 식별되어 91.9%의 재현율을 나타냅니다. DISPATCH에 의해 분해된 531개의 개별 보안 패치 중에서 465개가 실제 보안 패치로, 87.75%의 정밀도를 보입니다. 또한, OpenSSL 1.1.1 [4]에서 CVE에 의해 공개적으로 색인된 공식 보안 패치에 대한 결과를 확인합니다. CVE에 의해 주석이 달린 패치의 87.5%가 DISPATCH에 의해 올바르게 분해됩니다. 더 자세한 결과는 부록 E 표 11에서 찾을 수 있습니다.

<figure>
    <img src="assets/Table_4.png" alt="Table 4">
    <figcaption>
        <p>Table 4: Security patch unraveling results in OpenSSL 1.1.1.</p>
    </figcaption>
</figure>

우리는 DISPATCH가 개별 보안 패치를 풀고 식별하는 데 실패하는 경우를 분석합니다. 첫째, 개별 보안 패치가 얽힌 차이에서 완전히 분해되지 않았습니다. 그 이유는 § 7.1에서 찾을 수 있습니다. 둘째, 개별 패치가 완전히 분해되었지만 비보안 개별 패치로 레이블이 지정되었습니다. 이는 주로 기존 보안 패치 데이터셋에서 파생된 패턴의 제한된 범위 때문입니다. 예를 들어, DISPATCH는 OpenSSL 1.1.1t와 1.1.1u 사이의 버전 차이에서 타이밍 유출 [2]을 수정하는 개별 패치를 감지하지 못합니다. 이 취약점은 우리의 고려 범위를 벗어나는 변수 할당 논리를 업데이트하여 수정됩니다.

또한 위양성을 조사하고 두 가지 주요 원인을 식별합니다: 개별 패치의 불완전한 분해(§ 7.1에 자세히 설명됨) 및 비보안 패치의 잘못된 레이블링. 예를 들어, Listing 6의 `cleanup_old_md_data`는 컨텍스트 부재로 인해 보안 관련으로 잘못 태그가 지정되었습니다. 그러나 보안 수준을 변경하지 않고 `if` 검사를 포함한 리팩터일 뿐입니다.

<pre>
<code>
1 diff --git a/crypto/digest.c b/crypto/digest.c
2 - if (ctx->digest && ctx->digest->ctx_size) {
3 - OPENSSL_clear_free (ctx->md_data, ctx_size);
4 - ctx->md_data = NULL;
5 - }
6 + cleanup_old_md_data (ctx, 1);
</code>
</pre>

**Listing 6: Lack of context information.**

이러한 관찰을 바탕으로 DISPATCH는 사전 정의된 패턴의 도움으로 개별 보안 패치를 식별하여 높은 재현율과 정밀도를 달성할 수 있습니다.

**New Security Patch Identification.** 표 11(부록 E)에서 볼 수 있듯이, OpenSSL 1.1.1에는 NVD [7]에 의해 공개적으로 색인된 24개의 보안 패치가 있습니다. ground truth에 레이블을 지정할 때, 우리는 480개의 추가 보안 패치를 식별합니다. 이러한 새로 식별된 보안 패치 중에서 DISPATCH는 444개(92.5%)를 분해하고 정확히 찾아내어 DISPATCH가 공개되지 않은 보안 패치를 식별할 수 있음을 나타냅니다.

### 7.4 Effectiveness on Different Software (RQ4)

다양한 소프트웨어 생태계에서 패턴의 적용 범위와 DISPATCH의 성능을 평가하기 위해, 우리는 다른 세 가지 인기 있는 오픈 소스 프로젝트에서 DISPATCH를 평가합니다. 이 프로젝트들은 다양한 응용 분야, 즉 Linux Kernel(운영 체제 코어), Nginx(웹 서버), ImageMagick(이미지 편집 소프트웨어)를 다루며, 각각 상당한 수의 알려진 취약점을 가지고 있습니다. 우리는 버전 차이를 수동으로 개별 패치로 분해하여 ground truth로 사용합니다. 우리의 실험은 다음과 같은 비교적 새로운 버전 비교에 중점을 둡니다: Linux Kernel v5.16-rc7 및 v5.16-rc8, Nginx release-1.1.0 및 1.1.3, ImageMagick 7.0.1-7 및 7.0.1-10.

표 5는 DISPATCH가 95%의 정확도를 달성하여 190개의 개별 패치 중 185개를 분해하는 것을 보여줍니다. DISPATCH의 효과와 다양한 응용 프로그램에 대한 일반화 능력은 3가지 주요 측면에서 비롯됩니다: (1) PatchGraph는 문 유형을 분석하고 미세한 토큰을 비교하여 구문 차이를 캡처하며, 이는 응용 프로그램에 구애받지 않습니다. (2) 식별된 12개의 보안 및 3개의 비보안 패턴은 광범위한 실제 패치 인스턴스를 효과적으로 다룹니다. (3) 패턴 유도 슬라이싱은 패턴 구조의 퍼지 매칭을 채택하며, 이 또한 응용 프로그램에 의존하지 않습니다. 또한 선택된 기준 모델을 DISPATCH와 비교합니다. 부록 F의 표 12에서 볼 수 있듯이, 결과는 OpenSSL 데이터셋의 비교와 일치합니다.

<figure>
    <img src="assets/Table_5.png" alt="Table 5">
    <figcaption>
        <p>Table 5: Patch unraveling results.</p>
    </figcaption>
</figure>

우리는 개별 보안 패치를 푸는 데 대한 DISPATCH의 효과를 추가로 평가합니다. 표 6은 평균 분해 재현율이 94.6%이고 정밀도가 92.6%임을 보여줍니다. 실험 결과에서 DISPATCH는 개별 보안 패치를 효과적으로 분해하고 식별할 수 있으며, DISPATCH의 분해 능력은 보안 및 비보안 시나리오 모두에서 일관됩니다.

<figure>
    <img src="assets/Table_6.png" alt="Table 6">
    <figcaption>
        <p>Table 6: Security patch unraveling results.</p>
    </figcaption>
</figure>

### 7.5 Effectiveness on Complex Patches (RQ5)

복잡하게 얽힌 보안 패치에 대한 DISPATCH의 효과를 평가하기 위해 두 가지 시나리오가 예시됩니다.

**Security Patches Entangled with Non-security Patches.** Listing 7은 DISPATCH가 두 패치 사이의 경계를 어떻게 결정하는지 보여줍니다. Listing 7에는 두 개의 개별 패치가 있습니다. 개별 비보안(1-7행) 패치는 `while` 루프를 `for` 루프로 리팩토링하고, 개별 보안 패치(8행)는 메모리 누수를 피하기 위해 `fds`를 해제합니다. 해제된 변수의 값은 비보안 패치에서 할당됩니다. 리팩토링 패턴과 추가된 메모리 관련 함수 패턴은 얽힌 패치를 두 개의 패치 세그먼트로 분할합니다. 패치 세그먼트 분석은 `fds`가 새롭지 않다는 것을 확인하여 병합의 필요성을 제거합니다. 이 예는 패치 문 분석이 패치 경계를 어떻게 정의하고 세그먼트 분석의 필요성을 보여주는지를 보여줍니다.

<pre>
<code>
1 - size_t i;
2 - while (numfds > 0) {
3 - openssl_fdset ((int) *fds, &asyncfds);
4 - numfds--;
5 - fds++;
6 + for (i = 0; i < numfds; i++) {
7 + openssl_fdset((int) fds[i], &asyncfds);
8 + OPENSSL_free (fds);
</code>
</pre>

**Listing 7: Security patches entangled with non-security ones.**

**Security Patches Entangled with Security Patches.** Listing 8은 두 개의 보안 패치를 얽어 놓은 패치를 보여줍니다(2-3행, 4행). 모든 보안 패치를 시기적절하게 적용하는 것이 중요하지만, 사용자와 시스템 관리자에게 특정 세부 정보를 알려 정보에 입각한 패치 결정을 내릴 수 있도록 얽힌 보안 패치를 분해할 필요가 여전히 있습니다. 이러한 맥락에서 DISPATCH는 업데이트된 조건문과 메모리 관련 함수 패턴을 효과적으로 사용하여 개별 패치를 분리하는 능력을 보여줍니다.

<pre>
<code>
1 diff --git a/.../pem_pk8.c b/.../pem_pk8.c
2 - if (klen <= 0) {
3 + if (klen < 0) {
4 + OPENSSL_cleanse (psbuf, klen);
</code>
</pre>

**Listing 8: Security patches entangled with security patches.**

## 8 Discussion

**Limitations.** DISPATCH는 Tree-sitter [11]를 사용하여 AST를 생성하고 MLTA [35]를 채택하여 간접 호출 대상을 식별합니다. 따라서 DISPATCH는 필연적으로 그들의 한계를 계승합니다. 또한 현재 패치 패턴에는 두 가지 한계가 있을 수 있습니다. 첫째, 우리는 공개 보안 패치 데이터베이스에서 패치 패턴을 추출하는데, 여기서 취약점 유형의 분포가 편향될 수 있습니다. 그러나 우리의 관찰에 따르면, 인기 있는 소프트웨어의 패치 패턴은 크게 다르지 않을 수 있습니다. 둘째, 패턴은 보안 전문가에 의해 생성되므로 특정 유형에 대한 편견을 도입하고 일부 경우(예: 보안 패치와 비보안 패치가 동일한 패턴을 공유할 수 있음)에 보안 패치와 비보안 패치를 구별하는 데 주관적일 수 있습니다. 여기서는 NVD CWE [42]의 지침을 따르고 CWE 유형과 관련된 취약점을 수정하는 경우 패치를 보안 패치로 분류합니다. 또한 개별 패치의 정의는 전문가마다 의견이 다를 수 있으므로 주관적일 수 있습니다. 일부는 단일 수정을 패치로 간주할 수 있지만 다른 일부는 수정의 일부로 간주할 수 있습니다. 이 주관성을 완화하기 위해, 우리는 레이블링 과정에 세 명의 전문가를 참여시켰습니다. 이 전문가들은 개별 패치를 공동으로 연구하고 레이블링 기준을 논의했습니다. 주관성을 더욱 최소화하기 위해, 우리는 개별 패치로 프로젝트를 컴파일하고 테스트합니다.

**Usability.** DISPATCH는 Tree-sitter [11]를 확장하여 다른 언어(C, Java, Python, Go 등)에 적용할 수 있습니다. 더 많은 언어별 패턴을 도입하여 더 많은 언어를 지원하도록 도구를 확장할 것입니다. 또한 DISPATCH는 패치 형식에 대한 요구 사항 없이 소스 코드만 활용하므로 플랫폼 독립적입니다.

**Patch Quality.** 수동으로 레이블이 지정된 패치의 경우, 구문 품질은 두 가지로 보장되었습니다. 첫째, 전문가들은 경험적 지식으로 얽힌 패치와 개별 패치를 면밀히 조사했습니다. 둘째, 우리는 ground truth를 사전 패치 소스 코드에 다시 적용한 다음, 패치된 코드를 빌드하고 컴파일했습니다. 의미론적 품질에 대해서는, 우리는 무작위로 개별 패치를 선택하고 수동으로 확인합니다. 결과적으로 의미론적 정확성이 보장될 수 있습니다. 원래 기능을 보장하기 위해, 우리는 각 개별 패치를 적용한 후 사용 가능한 테스트 케이스(예: OpenSSL [8]의 내장 테스트 케이스)를 실행합니다. 이는 분해 결과가 ground truth와 일치할 때 개별 패치가 기능을 보존함을 확인합니다. 또한, 얻은 모든 개별 패치는 누적되지 않으며 독립적으로 다시 적용될 수 있습니다.

## 9 Related Work

**Entangled Patch Analysis and Decomposition.** 연구자들은 얽힌 커밋을 분해하기 위해 몇 가지 노력을 기울였습니다. 휴리스틱 기반 접근 방식은 사전 정의된 템플릿이나 마이닝 패턴 [20, 25, 27, 29, 30, 48, 50]을 활용하여 단일 목적 커밋을 얻습니다. 슬라이싱 기반 접근 방식 [25, 39, 56]과 그래프 클러스터링 기반 접근 방식 [18, 22, 24, 32, 41, 44, 47, 51]은 종속성 분석을 수행하고 프로그램 슬라이싱 기술과 그래프 클러스터링 알고리즘을 사용하여 종속성 그래프의 노드를 그룹화합니다. 또한, [25, 47, 56]은 자동 프로세스를 보완하기 위한 대화형 메커니즘을 도입합니다. 또한, [23]은 IDE의 정보를 채택하고, [26, 46]은 얽힌 커밋을 수동으로 분해합니다.

**Constrained Program Slicing.** 연구자들은 프로그램 슬라이싱을 안내하기 위해 여러 제약 조건을 도입합니다. [34]는 핵심 지점(중심)을 도입하고 DFG 또는 CFG에서 코드 가젯을 슬라이스합니다. [59]는 특정 구문 특성과 일치하는 문장 하위 집합인 코드 주의를 제안하여 코드 가젯을 구체화합니다. [33]은 프로그램 슬라이싱을 위한 시작점과 노드 유형을 구체화합니다. [37]은 취약점 유형에 따라 발현 지점을 정의합니다. 그에 비해, 패턴 유도 슬라이싱은 퍼지 매칭으로 슬라이싱 절차를 안내함으로써 DISPATCH에 적응성을 제공합니다.

## 10 Conclusion

우리는 PatchGraph 및 패치 종속성 분석을 통해 얽힌 패치에서 개별 보안 패치를 분리하는 DISPATCH를 제안합니다. PatchGraph는 삭제/추가/업데이트된 의미론을 캡처하는 풍부한 그래프 구조로 미세한 diff 동작을 나타냅니다. 패치 종속성 분석에는 완전한 개별 보안 패치를 얻기 위한 문장 및 세그먼트 종속성 분석이 포함됩니다. 우리는 4개의 실제 인기 있는 프로젝트의 버전 차이에 대한 DISPATCH의 효과를 평가합니다. 실험 결과에 따르면 DISPATCH는 일반 개별 패치의 90% 이상과 개별 보안 패치의 87% 이상을 효과적으로 분리합니다. 우리는 우리의 접근 방식을 SOTA 방법과 비교하고 DISPATCH가 20% 이상의 정확도 향상으로 그들을 능가함을 보여줍니다.

## Acknowledgments

우리는 Shepherd와 리뷰어들의 통찰력 있는 피드백에 감사드립니다. 이 연구는 ONR 보조금 N00014-23-1-2122와 George Mason University의 IDIA P3 교수 펠로우십의 부분적인 지원을 받았습니다.

## References

- <a id="ref1"></a>[1] "Official Patch for CVE-2021-3449," https://github.com/openssl/openssl/commit/fb9fa6b51defd48157eeb207f52181f735d96148.
- <a id="ref2"></a>[2] "Official Patch for CVE-2022-4304," https://github.com/openssl/openssl/commit/3f499b24f3bcd66db022074f7e8b4f6ee266a3ae.
- <a id="ref3"></a>[3] "Official Patch for CVE-2023-0464," https://github.com/openssl/openssl/commit/879f7080d7e141f415c79eaa3a8ac4a3dad0348b.
- <a id="ref4"></a>[4] "OpenSSL Vulnerabilities Fixed in OpenSSL 1.1.1," https://www.openssl.org/news/vulnerabilities-1.1.1.html.
- <a id="ref5"></a>[5] "grammar zoo browsable c99 grammar 2015," 2015. [Online]. Available: https://slebok.github.io/zoo/c/c99/iso-9899-tc3/extracted/index.html
- <a id="ref6"></a>[6] "Git Repository of UTANGO." https://github.com/Commit-Untangling/commit-untangling, 2022.
- <a id="ref7"></a>[7] "National Vulnerability Database," https://nvd.nist.gov, 2023.
- <a id="ref8"></a>[8] "OpenSSL Project," https://github.com/openssl/openssl, 2023.
- <a id="ref9"></a>[9] "Patch," https://csrc.nist.gov/glossary/term/patch, 2023.
- <a id="ref10"></a>[10] "Release Strategy of OpenSSL," https://www.openssl.org/policies/releasestrat, 2023.
- <a id="ref11"></a>[11] "Tree-Sitter," https://tree-sitter.github.io/tree-sitter/, 2023.
- <a id="ref12"></a>[12] 2024. [Online]. Available: https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6
- <a id="ref13"></a>[13] 2024. [Online]. Available: https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e
- <a id="ref14"></a>[14] "Split View of a Commit." https://github.com/openssl/openssl/commit/041962b429ebe748c8b6b7922980dfb6decfef26?diff=split&w=0, 2024.
- <a id="ref15"></a>[15] "Understanding Patches and Software Updates." https://www.cisa.gov/news-events/news/understanding-patches-and-software-updates, 2024.
- <a id="ref16"></a>[16] J. Achiam, S. Adler, S. Agarwal, L. Ahmad, I. Akkaya, F. L. Aleman, D. Almeida, J. Altenschmidt, S. Altman, S. Anadkat et al., "Gpt-4 technical report," arXiv preprint arXiv:2303.08774, 2023.
- <a id="ref17"></a>[17] alexbuckgit, "C docs - get started, tutorials, reference." 2024. [Online]. Available: https://learn.microsoft.com/en-us/cpp/c-language/?view=msvc-170
- <a id="ref18"></a>[18] R. Arima, Y. Higo, and S. Kusumoto, "A study on inappropriately partitioned commits: How much and what kinds of ip commits in java projects?" in Proceedings of the 15th International Conference on Mining Software Repositories, 2018, pp. 336-340.
- <a id="ref19"></a>[19] W. Bai, Q. Wu, K. Wu, and K. Lu, "Exploring the influence of prompts in llms for security-related tasks."
- <a id="ref20"></a>[20] M. Barnett, C. Bird, J. Brunet, and S. K. Lahiri, "Helping developers help themselves: Automatic decomposition of code review changesets," in 2015 IEEE/ACM 37th IEEE International Conference on Software Engineering, vol. 1. IEEE, 2015, pp. 134-144.
- <a id="ref21"></a>[21] C. Bellei, H. Alattas, and N. Kaaniche, "Label-gcn: an effective method for adding label propagation to graph convolutional networks," arXiv preprint arXiv:2104.02153, 2021.
- <a id="ref22"></a>[22] S. Chen, S. Xu, Y. Yao, and F. Xu, "Untangling composite commits by attributed graph clustering," in Proceedings of the 13th Asia-Pacific Symposium on Internetware, 2022, pp. 117–126.
- <a id="ref23"></a>[23] M. Dias, A. Bacchelli, G. Gousios, D. Cassou, and S. Ducasse, "Untangling fine-grained code changes," in 2015 IEEE 22nd International Conference on Software Analysis, Evolution, and Reengineering (SANER). IEEE, 2015, pp. 341-350.
- <a id="ref24"></a>[24] J.-R. Falleri, F. Morandat, X. Blanc, M. Martinez, and M. Monperrus, "Fine-grained and accurate source code differencing," in Proceedings of the 29th ACM/IEEE international conference on Automated software engineering, 2014, pp. 313-324.
- <a id="ref25"></a>[25] B. Guo and M. Song, "Interactively decomposing composite changes to support code review and regression testing," in 2017 IEEE 41st Annual Computer Software and Applications Conference. IEEE, 2017, pp. 118-127.
- <a id="ref26"></a>[26] S. Herbold, A. Trautsch, and B. Ledel, "Large-scale manual validation of bugfixing changes," in Proceedings of the 17th International Conference on Mining Software Repositories, 2020, pp. 611-614.
- <a id="ref27"></a>[27] K. Herzig, S. Just, and A. Zeller, "The impact of tangled code changes on defect prediction models," Empirical Software Engineering, vol. 21, pp. 303-336, 2016.
- <a id="ref28"></a>[28] M. Jin, S. Shahriar, M. Tufano, X. Shi, S. Lu, N. Sundaresan, and A. Svyatkovskiy, "Inferfix: End-to-end program repair with Ilms," in Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2023, pp. 1646-1656.
- <a id="ref29"></a>[29] H. Kirinuki, Y. Higo, K. Hotta, and S. Kusumoto, "Hey! are you committing tangled changes?" in Proceedings of the 22nd International Conference on Program Comprehension, 2014, pp. 262–265.
- <a id="ref30"></a>[30] "Splitting commits via past code changes," in 2016 23rd Asia-Pacific Software Engineering Conference (APSEC). IEEE, 2016, pp. 129-136.
- <a id="ref31"></a>[31] F. Li and V. Paxson, "A large-scale empirical study of security patches," in Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, 2017, pp. 2201-2215.
- <a id="ref32"></a>[32] Y. Li, S. Wang, and T. N. Nguyen, "Utango: untangling commits with context-aware, graph-based, code change clustering learning model," in Proceedings of the 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2022, pp. 221-232.
- <a id="ref33"></a>[33] Z. Li, D. Zou, S. Xu, H. Jin, Y. Zhu, and Z. Chen, "Sysevr: A framework for using deep learning to detect software vulnerabilities," IEEE Transactions on Dependable and Secure Computing, vol. 19, no. 4, pp. 2244-2258, 2021.
- <a id="ref34"></a>[34] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, and Y. Zhong, "Vuldeepecker: A deep learning-based system for vulnerability detection," arXiv preprint arXiv:1801.01681, 2018.
- <a id="ref35"></a>[35] K. Lu and H. Hu, "Where does it go? refining indirect-call targets with multi-layer type analysis," in Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, 2019, pp. 1867-1881.
- <a id="ref36"></a>[36] C. Luo, W. Meng, and S. Wang, "Strengthening supply chain security with fine-grained safe patch identification," in 2024 IEEE/ACM 46th International Conference on Software Engineering (ICSE). IEEE Computer Society, 2024, pp. 873-873.
- <a id="ref37"></a>[37] Y. Mirsky, G. Macon, M. Brown, C. Yagemann, M. Pruett, E. Downing, S. Mertoguno, and W. Lee, “Vulchecker: Graph-based vulnerability localization in source code," in 31st USENIX Security Symposium, Security 2022, 2023.
- <a id="ref38"></a>[38] D. Müllner, "Modern hierarchical, agglomerative clustering algorithms," arXiv preprint arXiv:1109.2378, 2011.
- <a id="ref39"></a>[39] W. Muylaert and C. De Roover, "Untangling composite commits using program slicing," in 2018 IEEE 18th International Working Conference on Source Code Analysis and Manipulation (SCAM). IEEE, 2018, pp. 193-202.
- <a id="ref40"></a>[40] H. A. Nguyen, A. T. Nguyen, and T. N. Nguyen, "Filtering noise in mixed-purpose fixing commits to improve defect prediction and localization," in 2013 IEEE 24th international symposium on software reliability engineering (ISSRE). IEEE, 2013, pp. 138-147.
- <a id="ref41"></a>[41] H. A. Nguyen, T. N. Nguyen, D. Dig, S. Nguyen, H. Tran, and M. Hilton, "Graph-based mining of in-the-wild, fine-grained, semantic code change patterns," in 2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE). IEEE, 2019, pp. 819-830.
- <a id="ref42"></a>[42] NIST, "Common Weakness Enumeration Specification (CWE)," https://nvd.nist.gov/vuln/categories.
- <a id="ref43"></a>[43] OpenSSL, "crypto/rsa/rsa_oaep." https://github.com/openssl/openssl/compare/OpenSSL_1_1_0...OpenSSL_1_1_1, 2023.
- <a id="ref44"></a>[44] P.-P. Pârțachi, S. K. Dash, M. Allamanis, and E. T. Barr, "Flexeme: Untangling commits using lexical flows," in Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2020, pp. 63-74.
- <a id="ref45"></a>[45] J. Pennington, R. Socher, and C. D. Manning, "Glove: Global vectors for word representation," in Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP), 2014, pp. 1532-1543.
- <a id="ref46"></a>[46] K. A. Safwan and F. Servant, "Decomposing the rationale of code commits: the software developer's perspective," in Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2019, pp. 397-408.
- <a id="ref47"></a>[47] B. Shen, W. Zhang, C. Kästner, H. Zhao, Z. Wei, G. Liang, and Z. Jin, "Smartcommit: a graph-based interactive assistant for activity-oriented commits," in Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, 2021, pp. 379-390.
- <a id="ref48"></a>[48] L. Sousa, D. Cedrim, A. Garcia, W. Oizumi, A. C. Bibiano, D. Oliveira, M. Kim, and A. Oliveira, "Characterizing and identifying composite refactorings: Concepts, heuristics and patterns," in Proceedings of the 17th International Conference on Mining Software Repositories, 2020, pp. 186-197.
- <a id="ref49"></a>[49] X. Tang, Z. Chen, K. Kim, H. Tian, S. Ezzini, and J. Klein, "Just-in-time security patch detection-llm at the rescue for data augmentation," arXiv preprint arXiv:2312.01241, 2023.
- <a id="ref50"></a>[50] Y. Tao and S. Kim, "Partitioning composite code changes to facilitate code review," in 2015 IEEE/ACM 12th Working Conference on Mining Software Repositories. IEEE, 2015, pp. 180-190.
- <a id="ref51"></a>[51] M. Wang, Z. Lin, Y. Zou, and B. Xie, “Cora: Decomposing and describing tangled code changes for reviewer," in 2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE). IEEE, 2019, pp. 1050-1061.
- <a id="ref52"></a>[52] S. Wang, X. Wang, K. Sun, S. Jajodia, H. Wang, and Q. Li, "Graphspd: Graph-based security patch detection with enriched code semantics," in 2023 IEEE Symposium on Security and Privacy (SP). IEEE, 2023, pp. 2409-2426.
- <a id="ref53"></a>[53] X. Wang, S. Wang, P. Feng, K. Sun, and S. Jajodia, "Patchdb: A large-scale security patch dataset," in 2021 51st Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN). IEEE, 2021, pp. 149-160.
- <a id="ref54"></a>[54] M. Weiser, "Program slicing," IEEE Transactions on software engineering, no. 4, pp. 352-357, 1984.
- <a id="ref55"></a>[55] Wikipedia, "Levenshtein distance." https://en.wikipedia.org/wiki/Levenshtein_distance, 2024.
- <a id="ref56"></a>[56] S. Yamashita, S. Hayashi, and M. Saeki, "Changebeadsthreader: An interactive environment for tailoring automatically untangled changes," in 2020 IEEE 27th International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2020, pp. 657-661.
- <a id="ref57"></a>[57] J. Zhou, M. Pacheco, J. Chen, X. Hu, X. Xia, D. Lo, and A. E. Hassan, "Colefunda: Explainable silent vulnerability fix identification," in 2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE). IEEE, 2023, pp. 2565-2577.
- <a id="ref58"></a>[58] Y. Zhou, J. K. Siow, C. Wang, S. Liu, and Y. Liu, "Spi: Automated identification of security patches via commits," ACM Transactions on Software Engineering and Methodology (TOSEM), vol. 31, no. 1, pp. 1-27, 2021.
- <a id="ref59"></a>[59] D. Zou, S. Wang, S. Xu, Z. Li, and H. Jin, "uvuldeepecker: A deep learning-based system for multiclass vulnerability detection," IEEE Transactions on Dependable and Secure Computing, vol. 18, no. 5, pp. 2224-2236, 2019.