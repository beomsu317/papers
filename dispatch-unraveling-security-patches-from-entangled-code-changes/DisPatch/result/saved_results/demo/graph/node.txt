0,CA_1,/*
0,A_2, * Copyright 1995-2020 The OpenSSL Project Authors. All Rights Reserved.
0,CA_3, *
0,CA_4, * Licensed under the OpenSSL license (the "License").  You may not use
0,CA_5, * this file except in compliance with the License.  You can obtain a copy
0,CA_6, * in the file LICENSE in the source distribution or at
0,CA_7, * https://www.openssl.org/source/license.html
0,CA_8, */
0,CA_9,
0,CA_10,#include "internal/cryptlib.h"
0,CA_11,#include "bn_local.h"
0,CA_12,
0,CA_13,/*
0,CA_14, * bn_mod_inverse_no_branch is a special version of BN_mod_inverse. It does
0,CA_15, * not contain branches that may leak sensitive information.
0,CA_16, *
0,CA_17, * This is a static function, we ensure all callers in this file pass valid
0,CA_18, * arguments: all passed pointers here are non-NULL.
0,CA_19, */
0,CA_20,static ossl_inline
0,CA_21,BIGNUM *bn_mod_inverse_no_branch(BIGNUM *in,
0,CA_22,                                 const BIGNUM *a, const BIGNUM *n,
0,CA_23,                                 BN_CTX *ctx, int *pnoinv)
0,CA_24,{
0,CA_25,    BIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;
0,CA_26,    BIGNUM *ret = NULL;
0,CA_27,    int sign;
0,CA_28,
0,CA_29,    bn_check_top(a);
0,CA_30,    bn_check_top(n);
0,CA_31,
0,CA_32,    BN_CTX_start(ctx);
0,CA_33,    A = BN_CTX_get(ctx);
0,CA_34,    B = BN_CTX_get(ctx);
0,CA_35,    X = BN_CTX_get(ctx);
0,CA_36,    D = BN_CTX_get(ctx);
0,CA_37,    M = BN_CTX_get(ctx);
0,CA_38,    Y = BN_CTX_get(ctx);
0,CA_39,    T = BN_CTX_get(ctx);
0,CA_40,    if (T == NULL)
0,CA_41,        goto err;
0,CA_42,
0,CA_43,    if (in == NULL)
0,CA_44,        R = BN_new();
0,CA_45,    else
0,CA_46,        R = in;
0,CA_47,    if (R == NULL)
0,CA_48,        goto err;
0,CA_49,
0,A_50,    BN_one(X);
0,CA_51,    BN_zero(Y);
0,CA_52,    if (BN_copy(B, a) == NULL)
0,CA_53,        goto err;
0,CA_54,    if (BN_copy(A, n) == NULL)
0,CA_55,        goto err;
0,CA_56,    A->neg = 0;
0,CA_57,
0,CA_58,    if (B->neg || (BN_ucmp(B, A) >= 0)) {
0,CA_59,        /*
0,CA_60,         * Turn BN_FLG_CONSTTIME flag on, so that when BN_div is invoked,
0,CA_61,         * BN_div_no_branch will be called eventually.
0,CA_62,         */
0,CA_63,         {
0,CA_64,            BIGNUM local_B;
0,CA_65,            bn_init(&local_B);
0,CA_66,            BN_with_flags(&local_B, B, BN_FLG_CONSTTIME);
0,CA_67,            if (!BN_nnmod(B, &local_B, A, ctx))
0,CA_68,                goto err;
0,CA_69,            /* Ensure local_B goes out of scope before any further use of B */
0,CA_70,        }
0,CA_71,    }
0,CA_72,    sign = -1;
0,CA_73,    /*-
0,CA_74,     * From  B = a mod |n|,  A = |n|  it follows that
0,CA_75,     *
0,CA_76,     *      0 <= B < A,
0,CA_77,     *     -sign*X*a  ==  B   (mod |n|),
0,CA_78,     *      sign*Y*a  ==  A   (mod |n|).
0,CA_79,     */
0,CA_80,
0,CA_81,    while (!BN_is_zero(B)) {
0,CA_82,        BIGNUM *tmp;
0,CA_83,
0,CA_84,        /*-
0,CA_85,         *      0 < B < A,
0,CA_86,         * (*) -sign*X*a  ==  B   (mod |n|),
0,CA_87,         *      sign*Y*a  ==  A   (mod |n|)
0,CA_88,         */
0,CA_89,
0,CA_90,        /*
0,CA_91,         * Turn BN_FLG_CONSTTIME flag on, so that when BN_div is invoked,
0,CA_92,         * BN_div_no_branch will be called eventually.
0,CA_93,         */
0,CA_94,        {
0,CA_95,            BIGNUM local_A;
0,CA_96,            bn_init(&local_A);
0,CA_97,            BN_with_flags(&local_A, A, BN_FLG_CONSTTIME);
0,CA_98,
0,CA_99,            /* (D, M) := (A/B, A%B) ... */
0,CA_100,            if (!BN_div(D, M, &local_A, B, ctx))
0,CA_101,                goto err;
0,CA_102,            /* Ensure local_A goes out of scope before any further use of A */
0,CA_103,        }
0,CA_104,
0,CA_105,        /*-
0,CA_106,         * Now
0,CA_107,         *      A = D*B + M;
0,CA_108,         * thus we have
0,CA_109,         * (**)  sign*Y*a  ==  D*B + M   (mod |n|).
0,CA_110,         */
0,CA_111,
0,CA_112,        tmp = A;                /* keep the BIGNUM object, the value does not
0,CA_113,                                 * matter */
0,CA_114,
0,CA_115,        /* (A, B) := (B, A mod B) ... */
0,CA_116,        A = B;
0,CA_117,        B = M;
0,CA_118,        /* ... so we have  0 <= B < A  again */
0,CA_119,
0,CA_120,        /*-
0,CA_121,         * Since the former  M  is now  B  and the former  B  is now  A,
0,CA_122,         * (**) translates into
0,CA_123,         *       sign*Y*a  ==  D*A + B    (mod |n|),
0,CA_124,         * i.e.
0,CA_125,         *       sign*Y*a - D*A  ==  B    (mod |n|).
0,CA_126,         * Similarly, (*) translates into
0,CA_127,         *      -sign*X*a  ==  A          (mod |n|).
0,CA_128,         *
0,CA_129,         * Thus,
0,CA_130,         *   sign*Y*a + D*sign*X*a  ==  B  (mod |n|),
0,CA_131,         * i.e.
0,CA_132,         *        sign*(Y + D*X)*a  ==  B  (mod |n|).
0,CA_133,         *
0,CA_134,         * So if we set  (X, Y, sign) := (Y + D*X, X, -sign), we arrive back at
0,CA_135,         *      -sign*X*a  ==  B   (mod |n|),
0,CA_136,         *       sign*Y*a  ==  A   (mod |n|).
0,CA_137,         * Note that  X  and  Y  stay non-negative all the time.
0,CA_138,         */
0,CA_139,
0,CA_140,        if (!BN_mul(tmp, D, X, ctx))
0,CA_141,            goto err;
0,CA_142,        if (!BN_add(tmp, tmp, Y))
0,CA_143,            goto err;
0,CA_144,
0,CA_145,        M = Y;                  /* keep the BIGNUM object, the value does not
0,CA_146,                                 * matter */
0,CA_147,        Y = X;
0,CA_148,        X = tmp;
0,CA_149,        sign = -sign;
0,CA_150,    }
0,CA_151,
0,CA_152,    /*-
0,CA_153,     * The while loop (Euclid's algorithm) ends when
0,CA_154,     *      A == gcd(a,n);
0,CA_155,     * we have
0,CA_156,     *       sign*Y*a  ==  A  (mod |n|),
0,CA_157,     * where  Y  is non-negative.
0,CA_158,     */
0,CA_159,
0,CA_160,    if (sign < 0) {
0,CA_161,        if (!BN_sub(Y, n, Y))
0,CA_162,            goto err;
0,CA_163,    }
0,CA_164,    /* Now  Y*a  ==  A  (mod |n|).  */
0,CA_165,
0,CA_166,    if (BN_is_one(A)) {
0,CA_167,        /* Y*a == 1  (mod |n|) */
0,CA_168,        if (!Y->neg && BN_ucmp(Y, n) < 0) {
0,CA_169,            if (!BN_copy(R, Y))
0,CA_170,                goto err;
0,CA_171,        } else {
0,CA_172,            if (!BN_nnmod(R, Y, n, ctx))
0,CA_173,                goto err;
0,CA_174,        }
0,CA_175,    } else {
0,CA_176,        *pnoinv = 1;
0,CA_177,        /* caller sets the BN_R_NO_INVERSE error */
0,CA_178,        goto err;
0,CA_179,    }
0,CA_180,
0,CA_181,    ret = R;
0,CA_182,    *pnoinv = 0;
0,CA_183,
0,CA_184, err:
0,CA_185,    if ((ret == NULL) && (in == NULL))
0,CA_186,        BN_free(R);
0,CA_187,    BN_CTX_end(ctx);
0,CA_188,    bn_check_top(ret);
0,CA_189,    return ret;
0,CA_190,}
0,CA_191,
0,CA_192,/*
0,CA_193, * This is an internal function, we assume all callers pass valid arguments:
0,CA_194, * all pointers passed here are assumed non-NULL.
0,CA_195, */
0,CA_196,BIGNUM *int_bn_mod_inverse(BIGNUM *in,
0,CA_197,                           const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx,
0,CA_198,                           int *pnoinv)
0,CA_199,{
0,CA_200,    BIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;
0,CA_201,    BIGNUM *ret = NULL;
0,CA_202,    int sign;
0,CA_203,
0,CA_204,    /* This is invalid input so we don't worry about constant time here */
0,CA_205,    if (BN_abs_is_word(n, 1) || BN_is_zero(n)) {
0,CA_206,        *pnoinv = 1;
0,CA_207,        return NULL;
0,CA_208,    }
0,CA_209,
0,CA_210,    *pnoinv = 0;
0,CA_211,
0,CA_212,    if ((BN_get_flags(a, BN_FLG_CONSTTIME) != 0)
0,CA_213,        || (BN_get_flags(n, BN_FLG_CONSTTIME) != 0)) {
0,CA_214,        return bn_mod_inverse_no_branch(in, a, n, ctx, pnoinv);
0,CA_215,    }
0,CA_216,
0,CA_217,    bn_check_top(a);
0,CA_218,    bn_check_top(n);
0,CA_219,
0,CA_220,    BN_CTX_start(ctx);
0,CA_221,    A = BN_CTX_get(ctx);
0,CA_222,    B = BN_CTX_get(ctx);
0,CA_223,    X = BN_CTX_get(ctx);
0,CA_224,    D = BN_CTX_get(ctx);
0,CA_225,    M = BN_CTX_get(ctx);
0,CA_226,    Y = BN_CTX_get(ctx);
0,CA_227,    T = BN_CTX_get(ctx);
0,CA_228,    if (T == NULL)
0,CA_229,        goto err;
0,CA_230,
0,CA_231,    if (in == NULL)
0,CA_232,        R = BN_new();
0,CA_233,    else
0,CA_234,        R = in;
0,CA_235,    if (R == NULL)
0,CA_236,        goto err;
0,CA_237,
0,A_238,    BN_one(X);
0,CA_239,    BN_zero(Y);
0,CA_240,    if (BN_copy(B, a) == NULL)
0,CA_241,        goto err;
0,CA_242,    if (BN_copy(A, n) == NULL)
0,CA_243,        goto err;
0,CA_244,    A->neg = 0;
0,CA_245,    if (B->neg || (BN_ucmp(B, A) >= 0)) {
0,CA_246,        if (!BN_nnmod(B, B, A, ctx))
0,CA_247,            goto err;
0,CA_248,    }
0,CA_249,    sign = -1;
0,CA_250,    /*-
0,CA_251,     * From  B = a mod |n|,  A = |n|  it follows that
0,CA_252,     *
0,CA_253,     *      0 <= B < A,
0,CA_254,     *     -sign*X*a  ==  B   (mod |n|),
0,CA_255,     *      sign*Y*a  ==  A   (mod |n|).
0,CA_256,     */
0,CA_257,
0,CA_258,    if (BN_is_odd(n) && (BN_num_bits(n) <= 2048)) {
0,CA_259,        /*
0,CA_260,         * Binary inversion algorithm; requires odd modulus. This is faster
0,CA_261,         * than the general algorithm if the modulus is sufficiently small
0,CA_262,         * (about 400 .. 500 bits on 32-bit systems, but much more on 64-bit
0,CA_263,         * systems)
0,CA_264,         */
0,CA_265,        int shift;
0,CA_266,
0,CA_267,        while (!BN_is_zero(B)) {
0,CA_268,            /*-
0,CA_269,             *      0 < B < |n|,
0,CA_270,             *      0 < A <= |n|,
0,CA_271,             * (1) -sign*X*a  ==  B   (mod |n|),
0,CA_272,             * (2)  sign*Y*a  ==  A   (mod |n|)
0,CA_273,             */
0,CA_274,
0,CA_275,            /*
0,CA_276,             * Now divide B by the maximum possible power of two in the
0,CA_277,             * integers, and divide X by the same value mod |n|. When we're
0,CA_278,             * done, (1) still holds.
0,CA_279,             */
0,CA_280,            shift = 0;
0,CA_281,            while (!BN_is_bit_set(B, shift)) { /* note that 0 < B */
0,CA_282,                shift++;
0,CA_283,
0,CA_284,                if (BN_is_odd(X)) {
0,CA_285,                    if (!BN_uadd(X, X, n))
0,CA_286,                        goto err;
0,CA_287,                }
0,CA_288,                /*
0,CA_289,                 * now X is even, so we can easily divide it by two
0,CA_290,                 */
0,CA_291,                if (!BN_rshift1(X, X))
0,CA_292,                    goto err;
0,CA_293,            }
0,CA_294,            if (shift > 0) {
0,CA_295,                if (!BN_rshift(B, B, shift))
0,CA_296,                    goto err;
0,CA_297,            }
0,CA_298,
0,CA_299,            /*
0,CA_300,             * Same for A and Y.  Afterwards, (2) still holds.
0,CA_301,             */
0,CA_302,            shift = 0;
0,CA_303,            while (!BN_is_bit_set(A, shift)) { /* note that 0 < A */
0,CA_304,                shift++;
0,CA_305,
0,CA_306,                if (BN_is_odd(Y)) {
0,CA_307,                    if (!BN_uadd(Y, Y, n))
0,CA_308,                        goto err;
0,CA_309,                }
0,CA_310,                /* now Y is even */
0,CA_311,                if (!BN_rshift1(Y, Y))
0,CA_312,                    goto err;
0,CA_313,            }
0,CA_314,            if (shift > 0) {
0,CA_315,                if (!BN_rshift(A, A, shift))
0,CA_316,                    goto err;
0,CA_317,            }
0,CA_318,
0,CA_319,            /*-
0,CA_320,             * We still have (1) and (2).
0,CA_321,             * Both  A  and  B  are odd.
0,CA_322,             * The following computations ensure that
0,CA_323,             *
0,CA_324,             *     0 <= B < |n|,
0,CA_325,             *      0 < A < |n|,
0,CA_326,             * (1) -sign*X*a  ==  B   (mod |n|),
0,CA_327,             * (2)  sign*Y*a  ==  A   (mod |n|),
0,CA_328,             *
0,CA_329,             * and that either  A  or  B  is even in the next iteration.
0,CA_330,             */
0,CA_331,            if (BN_ucmp(B, A) >= 0) {
0,CA_332,                /* -sign*(X + Y)*a == B - A  (mod |n|) */
0,CA_333,                if (!BN_uadd(X, X, Y))
0,CA_334,                    goto err;
0,CA_335,                /*
0,CA_336,                 * NB: we could use BN_mod_add_quick(X, X, Y, n), but that
0,CA_337,                 * actually makes the algorithm slower
0,CA_338,                 */
0,CA_339,                if (!BN_usub(B, B, A))
0,CA_340,                    goto err;
0,CA_341,            } else {
0,CA_342,                /*  sign*(X + Y)*a == A - B  (mod |n|) */
0,CA_343,                if (!BN_uadd(Y, Y, X))
0,CA_344,                    goto err;
0,CA_345,                /*
0,CA_346,                 * as above, BN_mod_add_quick(Y, Y, X, n) would slow things down
0,CA_347,                 */
0,CA_348,                if (!BN_usub(A, A, B))
0,CA_349,                    goto err;
0,CA_350,            }
0,CA_351,        }
0,CA_352,    } else {
0,CA_353,        /* general inversion algorithm */
0,CA_354,
0,CA_355,        while (!BN_is_zero(B)) {
0,CA_356,            BIGNUM *tmp;
0,CA_357,
0,CA_358,            /*-
0,CA_359,             *      0 < B < A,
0,CA_360,             * (*) -sign*X*a  ==  B   (mod |n|),
0,CA_361,             *      sign*Y*a  ==  A   (mod |n|)
0,CA_362,             */
0,CA_363,
0,CA_364,            /* (D, M) := (A/B, A%B) ... */
0,CA_365,            if (BN_num_bits(A) == BN_num_bits(B)) {
0,CA_366,                if (!BN_one(D))
0,CA_367,                    goto err;
0,CA_368,                if (!BN_sub(M, A, B))
0,CA_369,                    goto err;
0,CA_370,            } else if (BN_num_bits(A) == BN_num_bits(B) + 1) {
0,CA_371,                /* A/B is 1, 2, or 3 */
0,CA_372,                if (!BN_lshift1(T, B))
0,CA_373,                    goto err;
0,CA_374,                if (BN_ucmp(A, T) < 0) {
0,CA_375,                    /* A < 2*B, so D=1 */
0,CA_376,                    if (!BN_one(D))
0,CA_377,                        goto err;
0,CA_378,                    if (!BN_sub(M, A, B))
0,CA_379,                        goto err;
0,CA_380,                } else {
0,CA_381,                    /* A >= 2*B, so D=2 or D=3 */
0,CA_382,                    if (!BN_sub(M, A, T))
0,CA_383,                        goto err;
0,CA_384,                    if (!BN_add(D, T, B))
0,CA_385,                        goto err; /* use D (:= 3*B) as temp */
0,CA_386,                    if (BN_ucmp(A, D) < 0) {
0,CA_387,                        /* A < 3*B, so D=2 */
0,CA_388,                        if (!BN_set_word(D, 2))
0,CA_389,                            goto err;
0,CA_390,                        /*
0,CA_391,                         * M (= A - 2*B) already has the correct value
0,CA_392,                         */
0,CA_393,                    } else {
0,CA_394,                        /* only D=3 remains */
0,CA_395,                        if (!BN_set_word(D, 3))
0,CA_396,                            goto err;
0,CA_397,                        /*
0,CA_398,                         * currently M = A - 2*B, but we need M = A - 3*B
0,CA_399,                         */
0,CA_400,                        if (!BN_sub(M, M, B))
0,CA_401,                            goto err;
0,CA_402,                    }
0,CA_403,                }
0,CA_404,            } else {
0,CA_405,                if (!BN_div(D, M, A, B, ctx))
0,CA_406,                    goto err;
0,CA_407,            }
0,CA_408,
0,CA_409,            /*-
0,CA_410,             * Now
0,CA_411,             *      A = D*B + M;
0,CA_412,             * thus we have
0,CA_413,             * (**)  sign*Y*a  ==  D*B + M   (mod |n|).
0,CA_414,             */
0,CA_415,
0,CA_416,            tmp = A;    /* keep the BIGNUM object, the value does not matter */
0,CA_417,
0,CA_418,            /* (A, B) := (B, A mod B) ... */
0,CA_419,            A = B;
0,CA_420,            B = M;
0,CA_421,            /* ... so we have  0 <= B < A  again */
0,CA_422,
0,CA_423,            /*-
0,CA_424,             * Since the former  M  is now  B  and the former  B  is now  A,
0,CA_425,             * (**) translates into
0,CA_426,             *       sign*Y*a  ==  D*A + B    (mod |n|),
0,CA_427,             * i.e.
0,CA_428,             *       sign*Y*a - D*A  ==  B    (mod |n|).
0,CA_429,             * Similarly, (*) translates into
0,CA_430,             *      -sign*X*a  ==  A          (mod |n|).
0,CA_431,             *
0,CA_432,             * Thus,
0,CA_433,             *   sign*Y*a + D*sign*X*a  ==  B  (mod |n|),
0,CA_434,             * i.e.
0,CA_435,             *        sign*(Y + D*X)*a  ==  B  (mod |n|).
0,CA_436,             *
0,CA_437,             * So if we set  (X, Y, sign) := (Y + D*X, X, -sign), we arrive back at
0,CA_438,             *      -sign*X*a  ==  B   (mod |n|),
0,CA_439,             *       sign*Y*a  ==  A   (mod |n|).
0,CA_440,             * Note that  X  and  Y  stay non-negative all the time.
0,CA_441,             */
0,CA_442,
0,CA_443,            /*
0,CA_444,             * most of the time D is very small, so we can optimize tmp := D*X+Y
0,CA_445,             */
0,CA_446,            if (BN_is_one(D)) {
0,CA_447,                if (!BN_add(tmp, X, Y))
0,CA_448,                    goto err;
0,CA_449,            } else {
0,CA_450,                if (BN_is_word(D, 2)) {
0,CA_451,                    if (!BN_lshift1(tmp, X))
0,CA_452,                        goto err;
0,CA_453,                } else if (BN_is_word(D, 4)) {
0,CA_454,                    if (!BN_lshift(tmp, X, 2))
0,CA_455,                        goto err;
0,CA_456,                } else if (D->top == 1) {
0,CA_457,                    if (!BN_copy(tmp, X))
0,CA_458,                        goto err;
0,CA_459,                    if (!BN_mul_word(tmp, D->d[0]))
0,CA_460,                        goto err;
0,CA_461,                } else {
0,CA_462,                    if (!BN_mul(tmp, D, X, ctx))
0,CA_463,                        goto err;
0,CA_464,                }
0,CA_465,                if (!BN_add(tmp, tmp, Y))
0,CA_466,                    goto err;
0,CA_467,            }
0,CA_468,
0,CA_469,            M = Y;      /* keep the BIGNUM object, the value does not matter */
0,CA_470,            Y = X;
0,CA_471,            X = tmp;
0,CA_472,            sign = -sign;
0,CA_473,        }
0,CA_474,    }
0,CA_475,
0,CA_476,    /*-
0,CA_477,     * The while loop (Euclid's algorithm) ends when
0,CA_478,     *      A == gcd(a,n);
0,CA_479,     * we have
0,CA_480,     *       sign*Y*a  ==  A  (mod |n|),
0,CA_481,     * where  Y  is non-negative.
0,CA_482,     */
0,CA_483,
0,CA_484,    if (sign < 0) {
0,CA_485,        if (!BN_sub(Y, n, Y))
0,CA_486,            goto err;
0,CA_487,    }
0,CA_488,    /* Now  Y*a  ==  A  (mod |n|).  */
0,CA_489,
0,CA_490,    if (BN_is_one(A)) {
0,CA_491,        /* Y*a == 1  (mod |n|) */
0,CA_492,        if (!Y->neg && BN_ucmp(Y, n) < 0) {
0,CA_493,            if (!BN_copy(R, Y))
0,CA_494,                goto err;
0,CA_495,        } else {
0,CA_496,            if (!BN_nnmod(R, Y, n, ctx))
0,CA_497,                goto err;
0,CA_498,        }
0,CA_499,    } else {
0,CA_500,        *pnoinv = 1;
0,CA_501,        goto err;
0,CA_502,    }
0,CA_503,    ret = R;
0,CA_504, err:
0,CA_505,    if ((ret == NULL) && (in == NULL))
0,CA_506,        BN_free(R);
0,CA_507,    BN_CTX_end(ctx);
0,CA_508,    bn_check_top(ret);
0,CA_509,    return ret;
0,CA_510,}
0,CA_511,
0,CA_512,/* solves ax == 1 (mod n) */
0,CA_513,BIGNUM *BN_mod_inverse(BIGNUM *in,
0,CA_514,                       const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
0,CA_515,{
0,CA_516,    BN_CTX *new_ctx = NULL;
0,CA_517,    BIGNUM *rv;
0,CA_518,    int noinv = 0;
0,CA_519,
0,CA_520,    if (ctx == NULL) {
0,CA_521,        ctx = new_ctx = BN_CTX_new();
0,CA_522,        if (ctx == NULL) {
0,CA_523,            BNerr(BN_F_BN_MOD_INVERSE, ERR_R_MALLOC_FAILURE);
0,CA_524,            return NULL;
0,CA_525,        }
0,CA_526,    }
0,CA_527,
0,CA_528,    rv = int_bn_mod_inverse(in, a, n, ctx, &noinv);
0,CA_529,    if (noinv)
0,CA_530,        BNerr(BN_F_BN_MOD_INVERSE, BN_R_NO_INVERSE);
0,CA_531,    BN_CTX_free(new_ctx);
0,CA_532,    return rv;
0,CA_533,}
0,CA_534,
0,CA_535,/*-
0,CA_536, * This function is based on the constant-time GCD work by Bernstein and Yang:
0,CA_537, * https://eprint.iacr.org/2019/266
0,CA_538, * Generalized fast GCD function to allow even inputs.
0,CA_539, * The algorithm first finds the shared powers of 2 between
0,CA_540, * the inputs, and removes them, reducing at least one of the
0,CA_541, * inputs to an odd value. Then it proceeds to calculate the GCD.
0,CA_542, * Before returning the resulting GCD, we take care of adding
0,CA_543, * back the powers of two removed at the beginning.
0,CA_544, * Note 1: we assume the bit length of both inputs is public information,
0,CA_545, * since access to top potentially leaks this information.
0,CA_546, */
0,CA_547,int BN_gcd(BIGNUM *r, const BIGNUM *in_a, const BIGNUM *in_b, BN_CTX *ctx)
0,CA_548,{
0,CA_549,    BIGNUM *g, *temp = NULL;
0,CA_550,    BN_ULONG mask = 0;
0,CA_551,    int i, j, top, rlen, glen, m, bit = 1, delta = 1, cond = 0, shifts = 0, ret = 0;
0,CA_552,
0,CA_553,    /* Note 2: zero input corner cases are not constant-time since they are
0,CA_554,     * handled immediately. An attacker can run an attack under this
0,CA_555,     * assumption without the need of side-channel information. */
0,CA_556,    if (BN_is_zero(in_b)) {
0,CA_557,        ret = BN_copy(r, in_a) != NULL;
0,CA_558,        r->neg = 0;
0,CA_559,        return ret;
0,CA_560,    }
0,CA_561,    if (BN_is_zero(in_a)) {
0,CA_562,        ret = BN_copy(r, in_b) != NULL;
0,CA_563,        r->neg = 0;
0,CA_564,        return ret;
0,CA_565,    }
0,CA_566,
0,CA_567,    bn_check_top(in_a);
0,CA_568,    bn_check_top(in_b);
0,CA_569,
0,CA_570,    BN_CTX_start(ctx);
0,CA_571,    temp = BN_CTX_get(ctx);
0,CA_572,    g = BN_CTX_get(ctx);
0,CA_573,
0,CA_574,    /* make r != 0, g != 0 even, so BN_rshift is not a potential nop */
0,CA_575,    if (g == NULL
0,CA_576,        || !BN_lshift1(g, in_b)
0,CA_577,        || !BN_lshift1(r, in_a))
0,CA_578,        goto err;
0,CA_579,
0,CA_580,    /* find shared powers of two, i.e. "shifts" >= 1 */
0,CA_581,    for (i = 0; i < r->dmax && i < g->dmax; i++) {
0,CA_582,        mask = ~(r->d[i] | g->d[i]);
0,CA_583,        for (j = 0; j < BN_BITS2; j++) {
0,CA_584,            bit &= mask;
0,CA_585,            shifts += bit;
0,CA_586,            mask >>= 1;
0,CA_587,        }
0,CA_588,    }
0,CA_589,
0,CA_590,    /* subtract shared powers of two; shifts >= 1 */
0,CA_591,    if (!BN_rshift(r, r, shifts)
0,CA_592,        || !BN_rshift(g, g, shifts))
0,CA_593,        goto err;
0,CA_594,
0,CA_595,    /* expand to biggest nword, with room for a possible extra word */
0,CA_596,    top = 1 + ((r->top >= g->top) ? r->top : g->top);
0,CA_597,    if (bn_wexpand(r, top) == NULL
0,CA_598,        || bn_wexpand(g, top) == NULL
0,CA_599,        || bn_wexpand(temp, top) == NULL)
0,CA_600,        goto err;
0,CA_601,
0,CA_602,    /* re arrange inputs s.t. r is odd */
0,CA_603,    BN_consttime_swap((~r->d[0]) & 1, r, g, top);
0,CA_604,
0,CA_605,    /* compute the number of iterations */
0,CA_606,    rlen = BN_num_bits(r);
0,CA_607,    glen = BN_num_bits(g);
0,CA_608,    m = 4 + 3 * ((rlen >= glen) ? rlen : glen);
0,CA_609,
0,CA_610,    for (i = 0; i < m; i++) {
0,CA_611,        /* conditionally flip signs if delta is positive and g is odd */
0,CA_612,        cond = (-delta >> (8 * sizeof(delta) - 1)) & g->d[0] & 1
0,CA_613,            /* make sure g->top > 0 (i.e. if top == 0 then g == 0 always) */
0,CA_614,            & (~((g->top - 1) >> (sizeof(g->top) * 8 - 1)));
0,CA_615,        delta = (-cond & -delta) | ((cond - 1) & delta);
0,CA_616,        r->neg ^= cond;
0,CA_617,        /* swap */
0,CA_618,        BN_consttime_swap(cond, r, g, top);
0,CA_619,
0,CA_620,        /* elimination step */
0,CA_621,        delta++;
0,CA_622,        if (!BN_add(temp, g, r))
0,CA_623,            goto err;
0,CA_624,        BN_consttime_swap(g->d[0] & 1 /* g is odd */
0,CA_625,                /* make sure g->top > 0 (i.e. if top == 0 then g == 0 always) */
0,CA_626,                & (~((g->top - 1) >> (sizeof(g->top) * 8 - 1))),
0,CA_627,                g, temp, top);
0,CA_628,        if (!BN_rshift1(g, g))
0,CA_629,            goto err;
0,CA_630,    }
0,CA_631,
0,CA_632,    /* remove possible negative sign */
0,CA_633,    r->neg = 0;
0,CA_634,    /* add powers of 2 removed, then correct the artificial shift */
0,CA_635,    if (!BN_lshift(r, r, shifts)
0,CA_636,        || !BN_rshift1(r, r))
0,CA_637,        goto err;
0,CA_638,
0,CA_639,    ret = 1;
0,CA_640,
0,CA_641, err:
0,CA_642,    BN_CTX_end(ctx);
0,CA_643,    bn_check_top(r);
0,CA_644,    return ret;
0,CA_645,}
0,CA_646,
0,CB_1,/*
0,B_2, * Copyright 1995-2022 The OpenSSL Project Authors. All Rights Reserved.
0,CB_3, *
0,CB_4, * Licensed under the OpenSSL license (the "License").  You may not use
0,CB_5, * this file except in compliance with the License.  You can obtain a copy
0,CB_6, * in the file LICENSE in the source distribution or at
0,CB_7, * https://www.openssl.org/source/license.html
0,CB_8, */
0,CB_9,
0,CB_10,#include "internal/cryptlib.h"
0,CB_11,#include "bn_local.h"
0,CB_12,
0,CB_13,/*
0,CB_14, * bn_mod_inverse_no_branch is a special version of BN_mod_inverse. It does
0,CB_15, * not contain branches that may leak sensitive information.
0,CB_16, *
0,CB_17, * This is a static function, we ensure all callers in this file pass valid
0,CB_18, * arguments: all passed pointers here are non-NULL.
0,CB_19, */
0,CB_20,static ossl_inline
0,CB_21,BIGNUM *bn_mod_inverse_no_branch(BIGNUM *in,
0,CB_22,                                 const BIGNUM *a, const BIGNUM *n,
0,CB_23,                                 BN_CTX *ctx, int *pnoinv)
0,CB_24,{
0,CB_25,    BIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;
0,CB_26,    BIGNUM *ret = NULL;
0,CB_27,    int sign;
0,CB_28,
0,CB_29,    bn_check_top(a);
0,CB_30,    bn_check_top(n);
0,CB_31,
0,CB_32,    BN_CTX_start(ctx);
0,CB_33,    A = BN_CTX_get(ctx);
0,CB_34,    B = BN_CTX_get(ctx);
0,CB_35,    X = BN_CTX_get(ctx);
0,CB_36,    D = BN_CTX_get(ctx);
0,CB_37,    M = BN_CTX_get(ctx);
0,CB_38,    Y = BN_CTX_get(ctx);
0,CB_39,    T = BN_CTX_get(ctx);
0,CB_40,    if (T == NULL)
0,CB_41,        goto err;
0,CB_42,
0,CB_43,    if (in == NULL)
0,CB_44,        R = BN_new();
0,CB_45,    else
0,CB_46,        R = in;
0,CB_47,    if (R == NULL)
0,CB_48,        goto err;
0,CB_49,
0,B_50,    if (!BN_one(X))
0,B_51,        goto err;
0,CB_52,    BN_zero(Y);
0,CB_53,    if (BN_copy(B, a) == NULL)
0,CB_54,        goto err;
0,CB_55,    if (BN_copy(A, n) == NULL)
0,CB_56,        goto err;
0,CB_57,    A->neg = 0;
0,CB_58,
0,CB_59,    if (B->neg || (BN_ucmp(B, A) >= 0)) {
0,CB_60,        /*
0,CB_61,         * Turn BN_FLG_CONSTTIME flag on, so that when BN_div is invoked,
0,CB_62,         * BN_div_no_branch will be called eventually.
0,CB_63,         */
0,CB_64,         {
0,CB_65,            BIGNUM local_B;
0,CB_66,            bn_init(&local_B);
0,CB_67,            BN_with_flags(&local_B, B, BN_FLG_CONSTTIME);
0,CB_68,            if (!BN_nnmod(B, &local_B, A, ctx))
0,CB_69,                goto err;
0,CB_70,            /* Ensure local_B goes out of scope before any further use of B */
0,CB_71,        }
0,CB_72,    }
0,CB_73,    sign = -1;
0,CB_74,    /*-
0,CB_75,     * From  B = a mod |n|,  A = |n|  it follows that
0,CB_76,     *
0,CB_77,     *      0 <= B < A,
0,CB_78,     *     -sign*X*a  ==  B   (mod |n|),
0,CB_79,     *      sign*Y*a  ==  A   (mod |n|).
0,CB_80,     */
0,CB_81,
0,CB_82,    while (!BN_is_zero(B)) {
0,CB_83,        BIGNUM *tmp;
0,CB_84,
0,CB_85,        /*-
0,CB_86,         *      0 < B < A,
0,CB_87,         * (*) -sign*X*a  ==  B   (mod |n|),
0,CB_88,         *      sign*Y*a  ==  A   (mod |n|)
0,CB_89,         */
0,CB_90,
0,CB_91,        /*
0,CB_92,         * Turn BN_FLG_CONSTTIME flag on, so that when BN_div is invoked,
0,CB_93,         * BN_div_no_branch will be called eventually.
0,CB_94,         */
0,CB_95,        {
0,CB_96,            BIGNUM local_A;
0,CB_97,            bn_init(&local_A);
0,CB_98,            BN_with_flags(&local_A, A, BN_FLG_CONSTTIME);
0,CB_99,
0,CB_100,            /* (D, M) := (A/B, A%B) ... */
0,CB_101,            if (!BN_div(D, M, &local_A, B, ctx))
0,CB_102,                goto err;
0,CB_103,            /* Ensure local_A goes out of scope before any further use of A */
0,CB_104,        }
0,CB_105,
0,CB_106,        /*-
0,CB_107,         * Now
0,CB_108,         *      A = D*B + M;
0,CB_109,         * thus we have
0,CB_110,         * (**)  sign*Y*a  ==  D*B + M   (mod |n|).
0,CB_111,         */
0,CB_112,
0,CB_113,        tmp = A;                /* keep the BIGNUM object, the value does not
0,CB_114,                                 * matter */
0,CB_115,
0,CB_116,        /* (A, B) := (B, A mod B) ... */
0,CB_117,        A = B;
0,CB_118,        B = M;
0,CB_119,        /* ... so we have  0 <= B < A  again */
0,CB_120,
0,CB_121,        /*-
0,CB_122,         * Since the former  M  is now  B  and the former  B  is now  A,
0,CB_123,         * (**) translates into
0,CB_124,         *       sign*Y*a  ==  D*A + B    (mod |n|),
0,CB_125,         * i.e.
0,CB_126,         *       sign*Y*a - D*A  ==  B    (mod |n|).
0,CB_127,         * Similarly, (*) translates into
0,CB_128,         *      -sign*X*a  ==  A          (mod |n|).
0,CB_129,         *
0,CB_130,         * Thus,
0,CB_131,         *   sign*Y*a + D*sign*X*a  ==  B  (mod |n|),
0,CB_132,         * i.e.
0,CB_133,         *        sign*(Y + D*X)*a  ==  B  (mod |n|).
0,CB_134,         *
0,CB_135,         * So if we set  (X, Y, sign) := (Y + D*X, X, -sign), we arrive back at
0,CB_136,         *      -sign*X*a  ==  B   (mod |n|),
0,CB_137,         *       sign*Y*a  ==  A   (mod |n|).
0,CB_138,         * Note that  X  and  Y  stay non-negative all the time.
0,CB_139,         */
0,CB_140,
0,CB_141,        if (!BN_mul(tmp, D, X, ctx))
0,CB_142,            goto err;
0,CB_143,        if (!BN_add(tmp, tmp, Y))
0,CB_144,            goto err;
0,CB_145,
0,CB_146,        M = Y;                  /* keep the BIGNUM object, the value does not
0,CB_147,                                 * matter */
0,CB_148,        Y = X;
0,CB_149,        X = tmp;
0,CB_150,        sign = -sign;
0,CB_151,    }
0,CB_152,
0,CB_153,    /*-
0,CB_154,     * The while loop (Euclid's algorithm) ends when
0,CB_155,     *      A == gcd(a,n);
0,CB_156,     * we have
0,CB_157,     *       sign*Y*a  ==  A  (mod |n|),
0,CB_158,     * where  Y  is non-negative.
0,CB_159,     */
0,CB_160,
0,CB_161,    if (sign < 0) {
0,CB_162,        if (!BN_sub(Y, n, Y))
0,CB_163,            goto err;
0,CB_164,    }
0,CB_165,    /* Now  Y*a  ==  A  (mod |n|).  */
0,CB_166,
0,CB_167,    if (BN_is_one(A)) {
0,CB_168,        /* Y*a == 1  (mod |n|) */
0,CB_169,        if (!Y->neg && BN_ucmp(Y, n) < 0) {
0,CB_170,            if (!BN_copy(R, Y))
0,CB_171,                goto err;
0,CB_172,        } else {
0,CB_173,            if (!BN_nnmod(R, Y, n, ctx))
0,CB_174,                goto err;
0,CB_175,        }
0,CB_176,    } else {
0,CB_177,        *pnoinv = 1;
0,CB_178,        /* caller sets the BN_R_NO_INVERSE error */
0,CB_179,        goto err;
0,CB_180,    }
0,CB_181,
0,CB_182,    ret = R;
0,CB_183,    *pnoinv = 0;
0,CB_184,
0,CB_185, err:
0,CB_186,    if ((ret == NULL) && (in == NULL))
0,CB_187,        BN_free(R);
0,CB_188,    BN_CTX_end(ctx);
0,CB_189,    bn_check_top(ret);
0,CB_190,    return ret;
0,CB_191,}
0,CB_192,
0,CB_193,/*
0,CB_194, * This is an internal function, we assume all callers pass valid arguments:
0,CB_195, * all pointers passed here are assumed non-NULL.
0,CB_196, */
0,CB_197,BIGNUM *int_bn_mod_inverse(BIGNUM *in,
0,CB_198,                           const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx,
0,CB_199,                           int *pnoinv)
0,CB_200,{
0,CB_201,    BIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;
0,CB_202,    BIGNUM *ret = NULL;
0,CB_203,    int sign;
0,CB_204,
0,CB_205,    /* This is invalid input so we don't worry about constant time here */
0,CB_206,    if (BN_abs_is_word(n, 1) || BN_is_zero(n)) {
0,CB_207,        *pnoinv = 1;
0,CB_208,        return NULL;
0,CB_209,    }
0,CB_210,
0,CB_211,    *pnoinv = 0;
0,CB_212,
0,CB_213,    if ((BN_get_flags(a, BN_FLG_CONSTTIME) != 0)
0,CB_214,        || (BN_get_flags(n, BN_FLG_CONSTTIME) != 0)) {
0,CB_215,        return bn_mod_inverse_no_branch(in, a, n, ctx, pnoinv);
0,CB_216,    }
0,CB_217,
0,CB_218,    bn_check_top(a);
0,CB_219,    bn_check_top(n);
0,CB_220,
0,CB_221,    BN_CTX_start(ctx);
0,CB_222,    A = BN_CTX_get(ctx);
0,CB_223,    B = BN_CTX_get(ctx);
0,CB_224,    X = BN_CTX_get(ctx);
0,CB_225,    D = BN_CTX_get(ctx);
0,CB_226,    M = BN_CTX_get(ctx);
0,CB_227,    Y = BN_CTX_get(ctx);
0,CB_228,    T = BN_CTX_get(ctx);
0,CB_229,    if (T == NULL)
0,CB_230,        goto err;
0,CB_231,
0,CB_232,    if (in == NULL)
0,CB_233,        R = BN_new();
0,CB_234,    else
0,CB_235,        R = in;
0,CB_236,    if (R == NULL)
0,CB_237,        goto err;
0,CB_238,
0,B_239,    if (!BN_one(X))
0,B_240,        goto err;
0,CB_241,    BN_zero(Y);
0,CB_242,    if (BN_copy(B, a) == NULL)
0,CB_243,        goto err;
0,CB_244,    if (BN_copy(A, n) == NULL)
0,CB_245,        goto err;
0,CB_246,    A->neg = 0;
0,CB_247,    if (B->neg || (BN_ucmp(B, A) >= 0)) {
0,CB_248,        if (!BN_nnmod(B, B, A, ctx))
0,CB_249,            goto err;
0,CB_250,    }
0,CB_251,    sign = -1;
0,CB_252,    /*-
0,CB_253,     * From  B = a mod |n|,  A = |n|  it follows that
0,CB_254,     *
0,CB_255,     *      0 <= B < A,
0,CB_256,     *     -sign*X*a  ==  B   (mod |n|),
0,CB_257,     *      sign*Y*a  ==  A   (mod |n|).
0,CB_258,     */
0,CB_259,
0,CB_260,    if (BN_is_odd(n) && (BN_num_bits(n) <= 2048)) {
0,CB_261,        /*
0,CB_262,         * Binary inversion algorithm; requires odd modulus. This is faster
0,CB_263,         * than the general algorithm if the modulus is sufficiently small
0,CB_264,         * (about 400 .. 500 bits on 32-bit systems, but much more on 64-bit
0,CB_265,         * systems)
0,CB_266,         */
0,CB_267,        int shift;
0,CB_268,
0,CB_269,        while (!BN_is_zero(B)) {
0,CB_270,            /*-
0,CB_271,             *      0 < B < |n|,
0,CB_272,             *      0 < A <= |n|,
0,CB_273,             * (1) -sign*X*a  ==  B   (mod |n|),
0,CB_274,             * (2)  sign*Y*a  ==  A   (mod |n|)
0,CB_275,             */
0,CB_276,
0,CB_277,            /*
0,CB_278,             * Now divide B by the maximum possible power of two in the
0,CB_279,             * integers, and divide X by the same value mod |n|. When we're
0,CB_280,             * done, (1) still holds.
0,CB_281,             */
0,CB_282,            shift = 0;
0,CB_283,            while (!BN_is_bit_set(B, shift)) { /* note that 0 < B */
0,CB_284,                shift++;
0,CB_285,
0,CB_286,                if (BN_is_odd(X)) {
0,CB_287,                    if (!BN_uadd(X, X, n))
0,CB_288,                        goto err;
0,CB_289,                }
0,CB_290,                /*
0,CB_291,                 * now X is even, so we can easily divide it by two
0,CB_292,                 */
0,CB_293,                if (!BN_rshift1(X, X))
0,CB_294,                    goto err;
0,CB_295,            }
0,CB_296,            if (shift > 0) {
0,CB_297,                if (!BN_rshift(B, B, shift))
0,CB_298,                    goto err;
0,CB_299,            }
0,CB_300,
0,CB_301,            /*
0,CB_302,             * Same for A and Y.  Afterwards, (2) still holds.
0,CB_303,             */
0,CB_304,            shift = 0;
0,CB_305,            while (!BN_is_bit_set(A, shift)) { /* note that 0 < A */
0,CB_306,                shift++;
0,CB_307,
0,CB_308,                if (BN_is_odd(Y)) {
0,CB_309,                    if (!BN_uadd(Y, Y, n))
0,CB_310,                        goto err;
0,CB_311,                }
0,CB_312,                /* now Y is even */
0,CB_313,                if (!BN_rshift1(Y, Y))
0,CB_314,                    goto err;
0,CB_315,            }
0,CB_316,            if (shift > 0) {
0,CB_317,                if (!BN_rshift(A, A, shift))
0,CB_318,                    goto err;
0,CB_319,            }
0,CB_320,
0,CB_321,            /*-
0,CB_322,             * We still have (1) and (2).
0,CB_323,             * Both  A  and  B  are odd.
0,CB_324,             * The following computations ensure that
0,CB_325,             *
0,CB_326,             *     0 <= B < |n|,
0,CB_327,             *      0 < A < |n|,
0,CB_328,             * (1) -sign*X*a  ==  B   (mod |n|),
0,CB_329,             * (2)  sign*Y*a  ==  A   (mod |n|),
0,CB_330,             *
0,CB_331,             * and that either  A  or  B  is even in the next iteration.
0,CB_332,             */
0,CB_333,            if (BN_ucmp(B, A) >= 0) {
0,CB_334,                /* -sign*(X + Y)*a == B - A  (mod |n|) */
0,CB_335,                if (!BN_uadd(X, X, Y))
0,CB_336,                    goto err;
0,CB_337,                /*
0,CB_338,                 * NB: we could use BN_mod_add_quick(X, X, Y, n), but that
0,CB_339,                 * actually makes the algorithm slower
0,CB_340,                 */
0,CB_341,                if (!BN_usub(B, B, A))
0,CB_342,                    goto err;
0,CB_343,            } else {
0,CB_344,                /*  sign*(X + Y)*a == A - B  (mod |n|) */
0,CB_345,                if (!BN_uadd(Y, Y, X))
0,CB_346,                    goto err;
0,CB_347,                /*
0,CB_348,                 * as above, BN_mod_add_quick(Y, Y, X, n) would slow things down
0,CB_349,                 */
0,CB_350,                if (!BN_usub(A, A, B))
0,CB_351,                    goto err;
0,CB_352,            }
0,CB_353,        }
0,CB_354,    } else {
0,CB_355,        /* general inversion algorithm */
0,CB_356,
0,CB_357,        while (!BN_is_zero(B)) {
0,CB_358,            BIGNUM *tmp;
0,CB_359,
0,CB_360,            /*-
0,CB_361,             *      0 < B < A,
0,CB_362,             * (*) -sign*X*a  ==  B   (mod |n|),
0,CB_363,             *      sign*Y*a  ==  A   (mod |n|)
0,CB_364,             */
0,CB_365,
0,CB_366,            /* (D, M) := (A/B, A%B) ... */
0,CB_367,            if (BN_num_bits(A) == BN_num_bits(B)) {
0,CB_368,                if (!BN_one(D))
0,CB_369,                    goto err;
0,CB_370,                if (!BN_sub(M, A, B))
0,CB_371,                    goto err;
0,CB_372,            } else if (BN_num_bits(A) == BN_num_bits(B) + 1) {
0,CB_373,                /* A/B is 1, 2, or 3 */
0,CB_374,                if (!BN_lshift1(T, B))
0,CB_375,                    goto err;
0,CB_376,                if (BN_ucmp(A, T) < 0) {
0,CB_377,                    /* A < 2*B, so D=1 */
0,CB_378,                    if (!BN_one(D))
0,CB_379,                        goto err;
0,CB_380,                    if (!BN_sub(M, A, B))
0,CB_381,                        goto err;
0,CB_382,                } else {
0,CB_383,                    /* A >= 2*B, so D=2 or D=3 */
0,CB_384,                    if (!BN_sub(M, A, T))
0,CB_385,                        goto err;
0,CB_386,                    if (!BN_add(D, T, B))
0,CB_387,                        goto err; /* use D (:= 3*B) as temp */
0,CB_388,                    if (BN_ucmp(A, D) < 0) {
0,CB_389,                        /* A < 3*B, so D=2 */
0,CB_390,                        if (!BN_set_word(D, 2))
0,CB_391,                            goto err;
0,CB_392,                        /*
0,CB_393,                         * M (= A - 2*B) already has the correct value
0,CB_394,                         */
0,CB_395,                    } else {
0,CB_396,                        /* only D=3 remains */
0,CB_397,                        if (!BN_set_word(D, 3))
0,CB_398,                            goto err;
0,CB_399,                        /*
0,CB_400,                         * currently M = A - 2*B, but we need M = A - 3*B
0,CB_401,                         */
0,CB_402,                        if (!BN_sub(M, M, B))
0,CB_403,                            goto err;
0,CB_404,                    }
0,CB_405,                }
0,CB_406,            } else {
0,CB_407,                if (!BN_div(D, M, A, B, ctx))
0,CB_408,                    goto err;
0,CB_409,            }
0,CB_410,
0,CB_411,            /*-
0,CB_412,             * Now
0,CB_413,             *      A = D*B + M;
0,CB_414,             * thus we have
0,CB_415,             * (**)  sign*Y*a  ==  D*B + M   (mod |n|).
0,CB_416,             */
0,CB_417,
0,CB_418,            tmp = A;    /* keep the BIGNUM object, the value does not matter */
0,CB_419,
0,CB_420,            /* (A, B) := (B, A mod B) ... */
0,CB_421,            A = B;
0,CB_422,            B = M;
0,CB_423,            /* ... so we have  0 <= B < A  again */
0,CB_424,
0,CB_425,            /*-
0,CB_426,             * Since the former  M  is now  B  and the former  B  is now  A,
0,CB_427,             * (**) translates into
0,CB_428,             *       sign*Y*a  ==  D*A + B    (mod |n|),
0,CB_429,             * i.e.
0,CB_430,             *       sign*Y*a - D*A  ==  B    (mod |n|).
0,CB_431,             * Similarly, (*) translates into
0,CB_432,             *      -sign*X*a  ==  A          (mod |n|).
0,CB_433,             *
0,CB_434,             * Thus,
0,CB_435,             *   sign*Y*a + D*sign*X*a  ==  B  (mod |n|),
0,CB_436,             * i.e.
0,CB_437,             *        sign*(Y + D*X)*a  ==  B  (mod |n|).
0,CB_438,             *
0,CB_439,             * So if we set  (X, Y, sign) := (Y + D*X, X, -sign), we arrive back at
0,CB_440,             *      -sign*X*a  ==  B   (mod |n|),
0,CB_441,             *       sign*Y*a  ==  A   (mod |n|).
0,CB_442,             * Note that  X  and  Y  stay non-negative all the time.
0,CB_443,             */
0,CB_444,
0,CB_445,            /*
0,CB_446,             * most of the time D is very small, so we can optimize tmp := D*X+Y
0,CB_447,             */
0,CB_448,            if (BN_is_one(D)) {
0,CB_449,                if (!BN_add(tmp, X, Y))
0,CB_450,                    goto err;
0,CB_451,            } else {
0,CB_452,                if (BN_is_word(D, 2)) {
0,CB_453,                    if (!BN_lshift1(tmp, X))
0,CB_454,                        goto err;
0,CB_455,                } else if (BN_is_word(D, 4)) {
0,CB_456,                    if (!BN_lshift(tmp, X, 2))
0,CB_457,                        goto err;
0,CB_458,                } else if (D->top == 1) {
0,CB_459,                    if (!BN_copy(tmp, X))
0,CB_460,                        goto err;
0,CB_461,                    if (!BN_mul_word(tmp, D->d[0]))
0,CB_462,                        goto err;
0,CB_463,                } else {
0,CB_464,                    if (!BN_mul(tmp, D, X, ctx))
0,CB_465,                        goto err;
0,CB_466,                }
0,CB_467,                if (!BN_add(tmp, tmp, Y))
0,CB_468,                    goto err;
0,CB_469,            }
0,CB_470,
0,CB_471,            M = Y;      /* keep the BIGNUM object, the value does not matter */
0,CB_472,            Y = X;
0,CB_473,            X = tmp;
0,CB_474,            sign = -sign;
0,CB_475,        }
0,CB_476,    }
0,CB_477,
0,CB_478,    /*-
0,CB_479,     * The while loop (Euclid's algorithm) ends when
0,CB_480,     *      A == gcd(a,n);
0,CB_481,     * we have
0,CB_482,     *       sign*Y*a  ==  A  (mod |n|),
0,CB_483,     * where  Y  is non-negative.
0,CB_484,     */
0,CB_485,
0,CB_486,    if (sign < 0) {
0,CB_487,        if (!BN_sub(Y, n, Y))
0,CB_488,            goto err;
0,CB_489,    }
0,CB_490,    /* Now  Y*a  ==  A  (mod |n|).  */
0,CB_491,
0,CB_492,    if (BN_is_one(A)) {
0,CB_493,        /* Y*a == 1  (mod |n|) */
0,CB_494,        if (!Y->neg && BN_ucmp(Y, n) < 0) {
0,CB_495,            if (!BN_copy(R, Y))
0,CB_496,                goto err;
0,CB_497,        } else {
0,CB_498,            if (!BN_nnmod(R, Y, n, ctx))
0,CB_499,                goto err;
0,CB_500,        }
0,CB_501,    } else {
0,CB_502,        *pnoinv = 1;
0,CB_503,        goto err;
0,CB_504,    }
0,CB_505,    ret = R;
0,CB_506, err:
0,CB_507,    if ((ret == NULL) && (in == NULL))
0,CB_508,        BN_free(R);
0,CB_509,    BN_CTX_end(ctx);
0,CB_510,    bn_check_top(ret);
0,CB_511,    return ret;
0,CB_512,}
0,CB_513,
0,CB_514,/* solves ax == 1 (mod n) */
0,CB_515,BIGNUM *BN_mod_inverse(BIGNUM *in,
0,CB_516,                       const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
0,CB_517,{
0,CB_518,    BN_CTX *new_ctx = NULL;
0,CB_519,    BIGNUM *rv;
0,CB_520,    int noinv = 0;
0,CB_521,
0,CB_522,    if (ctx == NULL) {
0,CB_523,        ctx = new_ctx = BN_CTX_new();
0,CB_524,        if (ctx == NULL) {
0,CB_525,            BNerr(BN_F_BN_MOD_INVERSE, ERR_R_MALLOC_FAILURE);
0,CB_526,            return NULL;
0,CB_527,        }
0,CB_528,    }
0,CB_529,
0,CB_530,    rv = int_bn_mod_inverse(in, a, n, ctx, &noinv);
0,CB_531,    if (noinv)
0,CB_532,        BNerr(BN_F_BN_MOD_INVERSE, BN_R_NO_INVERSE);
0,CB_533,    BN_CTX_free(new_ctx);
0,CB_534,    return rv;
0,CB_535,}
0,CB_536,
0,CB_537,/*-
0,CB_538, * This function is based on the constant-time GCD work by Bernstein and Yang:
0,CB_539, * https://eprint.iacr.org/2019/266
0,CB_540, * Generalized fast GCD function to allow even inputs.
0,CB_541, * The algorithm first finds the shared powers of 2 between
0,CB_542, * the inputs, and removes them, reducing at least one of the
0,CB_543, * inputs to an odd value. Then it proceeds to calculate the GCD.
0,CB_544, * Before returning the resulting GCD, we take care of adding
0,CB_545, * back the powers of two removed at the beginning.
0,CB_546, * Note 1: we assume the bit length of both inputs is public information,
0,CB_547, * since access to top potentially leaks this information.
0,CB_548, */
0,CB_549,int BN_gcd(BIGNUM *r, const BIGNUM *in_a, const BIGNUM *in_b, BN_CTX *ctx)
0,CB_550,{
0,CB_551,    BIGNUM *g, *temp = NULL;
0,CB_552,    BN_ULONG mask = 0;
0,CB_553,    int i, j, top, rlen, glen, m, bit = 1, delta = 1, cond = 0, shifts = 0, ret = 0;
0,CB_554,
0,CB_555,    /* Note 2: zero input corner cases are not constant-time since they are
0,CB_556,     * handled immediately. An attacker can run an attack under this
0,CB_557,     * assumption without the need of side-channel information. */
0,CB_558,    if (BN_is_zero(in_b)) {
0,CB_559,        ret = BN_copy(r, in_a) != NULL;
0,CB_560,        r->neg = 0;
0,CB_561,        return ret;
0,CB_562,    }
0,CB_563,    if (BN_is_zero(in_a)) {
0,CB_564,        ret = BN_copy(r, in_b) != NULL;
0,CB_565,        r->neg = 0;
0,CB_566,        return ret;
0,CB_567,    }
0,CB_568,
0,CB_569,    bn_check_top(in_a);
0,CB_570,    bn_check_top(in_b);
0,CB_571,
0,CB_572,    BN_CTX_start(ctx);
0,CB_573,    temp = BN_CTX_get(ctx);
0,CB_574,    g = BN_CTX_get(ctx);
0,CB_575,
0,CB_576,    /* make r != 0, g != 0 even, so BN_rshift is not a potential nop */
0,CB_577,    if (g == NULL
0,CB_578,        || !BN_lshift1(g, in_b)
0,CB_579,        || !BN_lshift1(r, in_a))
0,CB_580,        goto err;
0,CB_581,
0,CB_582,    /* find shared powers of two, i.e. "shifts" >= 1 */
0,CB_583,    for (i = 0; i < r->dmax && i < g->dmax; i++) {
0,CB_584,        mask = ~(r->d[i] | g->d[i]);
0,CB_585,        for (j = 0; j < BN_BITS2; j++) {
0,CB_586,            bit &= mask;
0,CB_587,            shifts += bit;
0,CB_588,            mask >>= 1;
0,CB_589,        }
0,CB_590,    }
0,CB_591,
0,CB_592,    /* subtract shared powers of two; shifts >= 1 */
0,CB_593,    if (!BN_rshift(r, r, shifts)
0,CB_594,        || !BN_rshift(g, g, shifts))
0,CB_595,        goto err;
0,CB_596,
0,CB_597,    /* expand to biggest nword, with room for a possible extra word */
0,CB_598,    top = 1 + ((r->top >= g->top) ? r->top : g->top);
0,CB_599,    if (bn_wexpand(r, top) == NULL
0,CB_600,        || bn_wexpand(g, top) == NULL
0,CB_601,        || bn_wexpand(temp, top) == NULL)
0,CB_602,        goto err;
0,CB_603,
0,CB_604,    /* re arrange inputs s.t. r is odd */
0,CB_605,    BN_consttime_swap((~r->d[0]) & 1, r, g, top);
0,CB_606,
0,CB_607,    /* compute the number of iterations */
0,CB_608,    rlen = BN_num_bits(r);
0,CB_609,    glen = BN_num_bits(g);
0,CB_610,    m = 4 + 3 * ((rlen >= glen) ? rlen : glen);
0,CB_611,
0,CB_612,    for (i = 0; i < m; i++) {
0,CB_613,        /* conditionally flip signs if delta is positive and g is odd */
0,CB_614,        cond = (-delta >> (8 * sizeof(delta) - 1)) & g->d[0] & 1
0,CB_615,            /* make sure g->top > 0 (i.e. if top == 0 then g == 0 always) */
0,CB_616,            & (~((g->top - 1) >> (sizeof(g->top) * 8 - 1)));
0,CB_617,        delta = (-cond & -delta) | ((cond - 1) & delta);
0,CB_618,        r->neg ^= cond;
0,CB_619,        /* swap */
0,CB_620,        BN_consttime_swap(cond, r, g, top);
0,CB_621,
0,CB_622,        /* elimination step */
0,CB_623,        delta++;
0,CB_624,        if (!BN_add(temp, g, r))
0,CB_625,            goto err;
0,CB_626,        BN_consttime_swap(g->d[0] & 1 /* g is odd */
0,CB_627,                /* make sure g->top > 0 (i.e. if top == 0 then g == 0 always) */
0,CB_628,                & (~((g->top - 1) >> (sizeof(g->top) * 8 - 1))),
0,CB_629,                g, temp, top);
0,CB_630,        if (!BN_rshift1(g, g))
0,CB_631,            goto err;
0,CB_632,    }
0,CB_633,
0,CB_634,    /* remove possible negative sign */
0,CB_635,    r->neg = 0;
0,CB_636,    /* add powers of 2 removed, then correct the artificial shift */
0,CB_637,    if (!BN_lshift(r, r, shifts)
0,CB_638,        || !BN_rshift1(r, r))
0,CB_639,        goto err;
0,CB_640,
0,CB_641,    ret = 1;
0,CB_642,
0,CB_643, err:
0,CB_644,    BN_CTX_end(ctx);
0,CB_645,    bn_check_top(r);
0,CB_646,    return ret;
0,CB_647,}
0,CB_648,
1,CA_1,/*
1,CA_2, * Copyright 2002-2022 The OpenSSL Project Authors. All Rights Reserved.
1,CA_3, *
1,CA_4, * Licensed under the OpenSSL license (the "License").  You may not use
1,CA_5, * this file except in compliance with the License.  You can obtain a copy
1,CA_6, * in the file LICENSE in the source distribution or at
1,CA_7, * https://www.openssl.org/source/license.html
1,CA_8, */
1,CA_9,
1,CA_10,#include <string.h>
1,CA_11,#include "ec_local.h"
1,CA_12,#include <openssl/err.h>
1,CA_13,#include <openssl/asn1t.h>
1,CA_14,#include <openssl/objects.h>
1,CA_15,#include "internal/nelem.h"
1,CA_16,
1,CA_17,int EC_GROUP_get_basis_type(const EC_GROUP *group)
1,CA_18,{
1,CA_19,    int i;
1,CA_20,
1,CA_21,    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
1,CA_22,        NID_X9_62_characteristic_two_field)
1,CA_23,        /* everything else is currently not supported */
1,CA_24,        return 0;
1,CA_25,
1,CA_26,    /* Find the last non-zero element of group->poly[] */
1,CA_27,    for (i = 0;
1,CA_28,         i < (int)OSSL_NELEM(group->poly) && group->poly[i] != 0;
1,CA_29,         i++)
1,CA_30,        continue;
1,CA_31,
1,CA_32,    if (i == 4)
1,CA_33,        return NID_X9_62_ppBasis;
1,CA_34,    else if (i == 2)
1,CA_35,        return NID_X9_62_tpBasis;
1,CA_36,    else
1,CA_37,        /* everything else is currently not supported */
1,CA_38,        return 0;
1,CA_39,}
1,CA_40,
1,CA_41,#ifndef OPENSSL_NO_EC2M
1,CA_42,int EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)
1,CA_43,{
1,CA_44,    if (group == NULL)
1,CA_45,        return 0;
1,CA_46,
1,CA_47,    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
1,CA_48,        NID_X9_62_characteristic_two_field
1,CA_49,        || !((group->poly[0] != 0) && (group->poly[1] != 0)
1,CA_50,             && (group->poly[2] == 0))) {
1,CA_51,        ECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS,
1,CA_52,              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
1,CA_53,        return 0;
1,CA_54,    }
1,CA_55,
1,CA_56,    if (k)
1,CA_57,        *k = group->poly[1];
1,CA_58,
1,CA_59,    return 1;
1,CA_60,}
1,CA_61,
1,CA_62,int EC_GROUP_get_pentanomial_basis(const EC_GROUP *group, unsigned int *k1,
1,CA_63,                                   unsigned int *k2, unsigned int *k3)
1,CA_64,{
1,CA_65,    if (group == NULL)
1,CA_66,        return 0;
1,CA_67,
1,CA_68,    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
1,CA_69,        NID_X9_62_characteristic_two_field
1,CA_70,        || !((group->poly[0] != 0) && (group->poly[1] != 0)
1,CA_71,             && (group->poly[2] != 0) && (group->poly[3] != 0)
1,CA_72,             && (group->poly[4] == 0))) {
1,CA_73,        ECerr(EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS,
1,CA_74,              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
1,CA_75,        return 0;
1,CA_76,    }
1,CA_77,
1,CA_78,    if (k1)
1,CA_79,        *k1 = group->poly[3];
1,CA_80,    if (k2)
1,CA_81,        *k2 = group->poly[2];
1,CA_82,    if (k3)
1,CA_83,        *k3 = group->poly[1];
1,CA_84,
1,CA_85,    return 1;
1,CA_86,}
1,CA_87,#endif
1,CA_88,
1,CA_89,/* some structures needed for the asn1 encoding */
1,CA_90,typedef struct x9_62_pentanomial_st {
1,CA_91,    int32_t k1;
1,CA_92,    int32_t k2;
1,CA_93,    int32_t k3;
1,CA_94,} X9_62_PENTANOMIAL;
1,CA_95,
1,CA_96,typedef struct x9_62_characteristic_two_st {
1,CA_97,    int32_t m;
1,CA_98,    ASN1_OBJECT *type;
1,CA_99,    union {
1,CA_100,        char *ptr;
1,CA_101,        /* NID_X9_62_onBasis */
1,CA_102,        ASN1_NULL *onBasis;
1,CA_103,        /* NID_X9_62_tpBasis */
1,CA_104,        ASN1_INTEGER *tpBasis;
1,CA_105,        /* NID_X9_62_ppBasis */
1,CA_106,        X9_62_PENTANOMIAL *ppBasis;
1,CA_107,        /* anything else */
1,CA_108,        ASN1_TYPE *other;
1,CA_109,    } p;
1,CA_110,} X9_62_CHARACTERISTIC_TWO;
1,CA_111,
1,CA_112,typedef struct x9_62_fieldid_st {
1,CA_113,    ASN1_OBJECT *fieldType;
1,CA_114,    union {
1,CA_115,        char *ptr;
1,CA_116,        /* NID_X9_62_prime_field */
1,CA_117,        ASN1_INTEGER *prime;
1,CA_118,        /* NID_X9_62_characteristic_two_field */
1,CA_119,        X9_62_CHARACTERISTIC_TWO *char_two;
1,CA_120,        /* anything else */
1,CA_121,        ASN1_TYPE *other;
1,CA_122,    } p;
1,CA_123,} X9_62_FIELDID;
1,CA_124,
1,CA_125,typedef struct x9_62_curve_st {
1,CA_126,    ASN1_OCTET_STRING *a;
1,CA_127,    ASN1_OCTET_STRING *b;
1,CA_128,    ASN1_BIT_STRING *seed;
1,CA_129,} X9_62_CURVE;
1,CA_130,
1,CA_131,struct ec_parameters_st {
1,CA_132,    int32_t version;
1,CA_133,    X9_62_FIELDID *fieldID;
1,CA_134,    X9_62_CURVE *curve;
1,CA_135,    ASN1_OCTET_STRING *base;
1,CA_136,    ASN1_INTEGER *order;
1,CA_137,    ASN1_INTEGER *cofactor;
1,CA_138,} /* ECPARAMETERS */ ;
1,CA_139,
1,CA_140,typedef enum {
1,CA_141,    ECPKPARAMETERS_TYPE_NAMED = 0,
1,CA_142,    ECPKPARAMETERS_TYPE_EXPLICIT,
1,CA_143,    ECPKPARAMETERS_TYPE_IMPLICIT
1,CA_144,} ecpk_parameters_type_t;
1,CA_145,
1,CA_146,struct ecpk_parameters_st {
1,CA_147,    int type;
1,CA_148,    union {
1,CA_149,        ASN1_OBJECT *named_curve;
1,CA_150,        ECPARAMETERS *parameters;
1,CA_151,        ASN1_NULL *implicitlyCA;
1,CA_152,    } value;
1,CA_153,} /* ECPKPARAMETERS */ ;
1,CA_154,
1,CA_155,/* SEC1 ECPrivateKey */
1,CA_156,typedef struct ec_privatekey_st {
1,CA_157,    int32_t version;
1,CA_158,    ASN1_OCTET_STRING *privateKey;
1,CA_159,    ECPKPARAMETERS *parameters;
1,CA_160,    ASN1_BIT_STRING *publicKey;
1,CA_161,} EC_PRIVATEKEY;
1,CA_162,
1,CA_163,/* the OpenSSL ASN.1 definitions */
1,CA_164,ASN1_SEQUENCE(X9_62_PENTANOMIAL) = {
1,CA_165,        ASN1_EMBED(X9_62_PENTANOMIAL, k1, INT32),
1,CA_166,        ASN1_EMBED(X9_62_PENTANOMIAL, k2, INT32),
1,CA_167,        ASN1_EMBED(X9_62_PENTANOMIAL, k3, INT32)
1,CA_168,} static_ASN1_SEQUENCE_END(X9_62_PENTANOMIAL)
1,CA_169,
1,CA_170,DECLARE_ASN1_ALLOC_FUNCTIONS(X9_62_PENTANOMIAL)
1,CA_171,IMPLEMENT_ASN1_ALLOC_FUNCTIONS(X9_62_PENTANOMIAL)
1,CA_172,
1,CA_173,ASN1_ADB_TEMPLATE(char_two_def) = ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.other, ASN1_ANY);
1,CA_174,
1,CA_175,ASN1_ADB(X9_62_CHARACTERISTIC_TWO) = {
1,CA_176,        ADB_ENTRY(NID_X9_62_onBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.onBasis, ASN1_NULL)),
1,CA_177,        ADB_ENTRY(NID_X9_62_tpBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.tpBasis, ASN1_INTEGER)),
1,CA_178,        ADB_ENTRY(NID_X9_62_ppBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.ppBasis, X9_62_PENTANOMIAL))
1,CA_179,} ASN1_ADB_END(X9_62_CHARACTERISTIC_TWO, 0, type, 0, &char_two_def_tt, NULL);
1,CA_180,
1,CA_181,ASN1_SEQUENCE(X9_62_CHARACTERISTIC_TWO) = {
1,CA_182,        ASN1_EMBED(X9_62_CHARACTERISTIC_TWO, m, INT32),
1,CA_183,        ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, type, ASN1_OBJECT),
1,CA_184,        ASN1_ADB_OBJECT(X9_62_CHARACTERISTIC_TWO)
1,CA_185,} static_ASN1_SEQUENCE_END(X9_62_CHARACTERISTIC_TWO)
1,CA_186,
1,CA_187,DECLARE_ASN1_ALLOC_FUNCTIONS(X9_62_CHARACTERISTIC_TWO)
1,CA_188,IMPLEMENT_ASN1_ALLOC_FUNCTIONS(X9_62_CHARACTERISTIC_TWO)
1,CA_189,
1,CA_190,ASN1_ADB_TEMPLATE(fieldID_def) = ASN1_SIMPLE(X9_62_FIELDID, p.other, ASN1_ANY);
1,CA_191,
1,CA_192,ASN1_ADB(X9_62_FIELDID) = {
1,CA_193,        ADB_ENTRY(NID_X9_62_prime_field, ASN1_SIMPLE(X9_62_FIELDID, p.prime, ASN1_INTEGER)),
1,CA_194,        ADB_ENTRY(NID_X9_62_characteristic_two_field, ASN1_SIMPLE(X9_62_FIELDID, p.char_two, X9_62_CHARACTERISTIC_TWO))
1,CA_195,} ASN1_ADB_END(X9_62_FIELDID, 0, fieldType, 0, &fieldID_def_tt, NULL);
1,CA_196,
1,CA_197,ASN1_SEQUENCE(X9_62_FIELDID) = {
1,CA_198,        ASN1_SIMPLE(X9_62_FIELDID, fieldType, ASN1_OBJECT),
1,CA_199,        ASN1_ADB_OBJECT(X9_62_FIELDID)
1,CA_200,} static_ASN1_SEQUENCE_END(X9_62_FIELDID)
1,CA_201,
1,CA_202,ASN1_SEQUENCE(X9_62_CURVE) = {
1,CA_203,        ASN1_SIMPLE(X9_62_CURVE, a, ASN1_OCTET_STRING),
1,CA_204,        ASN1_SIMPLE(X9_62_CURVE, b, ASN1_OCTET_STRING),
1,CA_205,        ASN1_OPT(X9_62_CURVE, seed, ASN1_BIT_STRING)
1,CA_206,} static_ASN1_SEQUENCE_END(X9_62_CURVE)
1,CA_207,
1,CA_208,ASN1_SEQUENCE(ECPARAMETERS) = {
1,CA_209,        ASN1_EMBED(ECPARAMETERS, version, INT32),
1,CA_210,        ASN1_SIMPLE(ECPARAMETERS, fieldID, X9_62_FIELDID),
1,CA_211,        ASN1_SIMPLE(ECPARAMETERS, curve, X9_62_CURVE),
1,CA_212,        ASN1_SIMPLE(ECPARAMETERS, base, ASN1_OCTET_STRING),
1,CA_213,        ASN1_SIMPLE(ECPARAMETERS, order, ASN1_INTEGER),
1,CA_214,        ASN1_OPT(ECPARAMETERS, cofactor, ASN1_INTEGER)
1,CA_215,} ASN1_SEQUENCE_END(ECPARAMETERS)
1,CA_216,
1,CA_217,DECLARE_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)
1,CA_218,IMPLEMENT_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)
1,CA_219,
1,CA_220,ASN1_CHOICE(ECPKPARAMETERS) = {
1,CA_221,        ASN1_SIMPLE(ECPKPARAMETERS, value.named_curve, ASN1_OBJECT),
1,CA_222,        ASN1_SIMPLE(ECPKPARAMETERS, value.parameters, ECPARAMETERS),
1,CA_223,        ASN1_SIMPLE(ECPKPARAMETERS, value.implicitlyCA, ASN1_NULL)
1,CA_224,} ASN1_CHOICE_END(ECPKPARAMETERS)
1,CA_225,
1,CA_226,DECLARE_ASN1_FUNCTIONS_const(ECPKPARAMETERS)
1,CA_227,DECLARE_ASN1_ENCODE_FUNCTIONS_const(ECPKPARAMETERS, ECPKPARAMETERS)
1,CA_228,IMPLEMENT_ASN1_FUNCTIONS_const(ECPKPARAMETERS)
1,CA_229,
1,CA_230,ASN1_SEQUENCE(EC_PRIVATEKEY) = {
1,CA_231,        ASN1_EMBED(EC_PRIVATEKEY, version, INT32),
1,CA_232,        ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
1,CA_233,        ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
1,CA_234,        ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
1,CA_235,} static_ASN1_SEQUENCE_END(EC_PRIVATEKEY)
1,CA_236,
1,CA_237,DECLARE_ASN1_FUNCTIONS_const(EC_PRIVATEKEY)
1,CA_238,DECLARE_ASN1_ENCODE_FUNCTIONS_const(EC_PRIVATEKEY, EC_PRIVATEKEY)
1,CA_239,IMPLEMENT_ASN1_FUNCTIONS_const(EC_PRIVATEKEY)
1,CA_240,
1,CA_241,/* some declarations of internal function */
1,CA_242,
1,CA_243,/* ec_asn1_group2field() sets the values in a X9_62_FIELDID object */
1,CA_244,static int ec_asn1_group2fieldid(const EC_GROUP *, X9_62_FIELDID *);
1,CA_245,/* ec_asn1_group2curve() sets the values in a X9_62_CURVE object */
1,CA_246,static int ec_asn1_group2curve(const EC_GROUP *, X9_62_CURVE *);
1,CA_247,
1,CA_248,/* the function definitions */
1,CA_249,
1,CA_250,static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
1,CA_251,{
1,CA_252,    int ok = 0, nid;
1,CA_253,    BIGNUM *tmp = NULL;
1,CA_254,
1,CA_255,    if (group == NULL || field == NULL)
1,CA_256,        return 0;
1,CA_257,
1,CA_258,    /* clear the old values (if necessary) */
1,CA_259,    ASN1_OBJECT_free(field->fieldType);
1,CA_260,    ASN1_TYPE_free(field->p.other);
1,CA_261,
1,CA_262,    nid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));
1,CA_263,    /* set OID for the field */
1,CA_264,    if ((field->fieldType = OBJ_nid2obj(nid)) == NULL) {
1,CA_265,        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
1,CA_266,        goto err;
1,CA_267,    }
1,CA_268,
1,CA_269,    if (nid == NID_X9_62_prime_field) {
1,CA_270,        if ((tmp = BN_new()) == NULL) {
1,CA_271,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CA_272,            goto err;
1,CA_273,        }
1,CA_274,        /* the parameters are specified by the prime number p */
1,CA_275,        if (!EC_GROUP_get_curve(group, tmp, NULL, NULL, NULL)) {
1,CA_276,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
1,CA_277,            goto err;
1,CA_278,        }
1,CA_279,        /* set the prime number */
1,CA_280,        field->p.prime = BN_to_ASN1_INTEGER(tmp, NULL);
1,CA_281,        if (field->p.prime == NULL) {
1,CA_282,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
1,CA_283,            goto err;
1,CA_284,        }
1,CA_285,    } else if (nid == NID_X9_62_characteristic_two_field)
1,CA_286,#ifdef OPENSSL_NO_EC2M
1,CA_287,    {
1,CA_288,        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_GF2M_NOT_SUPPORTED);
1,CA_289,        goto err;
1,CA_290,    }
1,CA_291,#else
1,CA_292,    {
1,CA_293,        int field_type;
1,CA_294,        X9_62_CHARACTERISTIC_TWO *char_two;
1,CA_295,
1,CA_296,        field->p.char_two = X9_62_CHARACTERISTIC_TWO_new();
1,CA_297,        char_two = field->p.char_two;
1,CA_298,
1,CA_299,        if (char_two == NULL) {
1,CA_300,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CA_301,            goto err;
1,CA_302,        }
1,CA_303,
1,CA_304,        char_two->m = (long)EC_GROUP_get_degree(group);
1,CA_305,
1,CA_306,        field_type = EC_GROUP_get_basis_type(group);
1,CA_307,
1,CA_308,        if (field_type == 0) {
1,CA_309,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
1,CA_310,            goto err;
1,CA_311,        }
1,CA_312,        /* set base type OID */
1,CA_313,        if ((char_two->type = OBJ_nid2obj(field_type)) == NULL) {
1,CA_314,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
1,CA_315,            goto err;
1,CA_316,        }
1,CA_317,
1,CA_318,        if (field_type == NID_X9_62_tpBasis) {
1,CA_319,            unsigned int k;
1,CA_320,
1,CA_321,            if (!EC_GROUP_get_trinomial_basis(group, &k))
1,CA_322,                goto err;
1,CA_323,
1,CA_324,            char_two->p.tpBasis = ASN1_INTEGER_new();
1,CA_325,            if (char_two->p.tpBasis == NULL) {
1,CA_326,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CA_327,                goto err;
1,CA_328,            }
1,CA_329,            if (!ASN1_INTEGER_set(char_two->p.tpBasis, (long)k)) {
1,CA_330,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
1,CA_331,                goto err;
1,CA_332,            }
1,CA_333,        } else if (field_type == NID_X9_62_ppBasis) {
1,CA_334,            unsigned int k1, k2, k3;
1,CA_335,
1,CA_336,            if (!EC_GROUP_get_pentanomial_basis(group, &k1, &k2, &k3))
1,CA_337,                goto err;
1,CA_338,
1,CA_339,            char_two->p.ppBasis = X9_62_PENTANOMIAL_new();
1,CA_340,            if (char_two->p.ppBasis == NULL) {
1,CA_341,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CA_342,                goto err;
1,CA_343,            }
1,CA_344,
1,CA_345,            /* set k? values */
1,CA_346,            char_two->p.ppBasis->k1 = (long)k1;
1,CA_347,            char_two->p.ppBasis->k2 = (long)k2;
1,CA_348,            char_two->p.ppBasis->k3 = (long)k3;
1,CA_349,        } else {                /* field_type == NID_X9_62_onBasis */
1,CA_350,
1,CA_351,            /* for ONB the parameters are (asn1) NULL */
1,CA_352,            char_two->p.onBasis = ASN1_NULL_new();
1,CA_353,            if (char_two->p.onBasis == NULL) {
1,CA_354,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CA_355,                goto err;
1,CA_356,            }
1,CA_357,        }
1,CA_358,    }
1,CA_359,#endif
1,CA_360,    else {
1,CA_361,        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_UNSUPPORTED_FIELD);
1,CA_362,        goto err;
1,CA_363,    }
1,CA_364,
1,CA_365,    ok = 1;
1,CA_366,
1,CA_367, err:
1,CA_368,    BN_free(tmp);
1,CA_369,    return ok;
1,CA_370,}
1,CA_371,
1,CA_372,static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
1,CA_373,{
1,CA_374,    int ok = 0;
1,CA_375,    BIGNUM *tmp_1 = NULL, *tmp_2 = NULL;
1,CA_376,    unsigned char *a_buf = NULL, *b_buf = NULL;
1,CA_377,    size_t len;
1,CA_378,
1,CA_379,    if (!group || !curve || !curve->a || !curve->b)
1,CA_380,        return 0;
1,CA_381,
1,CA_382,    if ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL) {
1,CA_383,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
1,CA_384,        goto err;
1,CA_385,    }
1,CA_386,
1,CA_387,    /* get a and b */
1,CA_388,    if (!EC_GROUP_get_curve(group, NULL, tmp_1, tmp_2, NULL)) {
1,CA_389,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);
1,CA_390,        goto err;
1,CA_391,    }
1,CA_392,
1,CA_393,    /*
1,CA_394,     * Per SEC 1, the curve coefficients must be padded up to size. See C.2's
1,CA_395,     * definition of Curve, C.1's definition of FieldElement, and 2.3.5's
1,CA_396,     * definition of how to encode the field elements.
1,CA_397,     */
1,CA_398,    len = ((size_t)EC_GROUP_get_degree(group) + 7) / 8;
1,CA_399,    if ((a_buf = OPENSSL_malloc(len)) == NULL
1,CA_400,        || (b_buf = OPENSSL_malloc(len)) == NULL) {
1,CA_401,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
1,CA_402,        goto err;
1,CA_403,    }
1,CA_404,    if (BN_bn2binpad(tmp_1, a_buf, len) < 0
1,CA_405,        || BN_bn2binpad(tmp_2, b_buf, len) < 0) {
1,CA_406,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);
1,CA_407,        goto err;
1,CA_408,    }
1,CA_409,
1,CA_410,    /* set a and b */
1,CA_411,    if (!ASN1_OCTET_STRING_set(curve->a, a_buf, len)
1,CA_412,        || !ASN1_OCTET_STRING_set(curve->b, b_buf, len)) {
1,CA_413,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
1,CA_414,        goto err;
1,CA_415,    }
1,CA_416,
1,CA_417,    /* set the seed (optional) */
1,CA_418,    if (group->seed) {
1,CA_419,        if (!curve->seed)
1,CA_420,            if ((curve->seed = ASN1_BIT_STRING_new()) == NULL) {
1,CA_421,                ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
1,CA_422,                goto err;
1,CA_423,            }
1,CA_424,        curve->seed->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
1,CA_425,        curve->seed->flags |= ASN1_STRING_FLAG_BITS_LEFT;
1,CA_426,        if (!ASN1_BIT_STRING_set(curve->seed, group->seed,
1,CA_427,                                 (int)group->seed_len)) {
1,CA_428,            ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
1,CA_429,            goto err;
1,CA_430,        }
1,CA_431,    } else {
1,CA_432,        ASN1_BIT_STRING_free(curve->seed);
1,CA_433,        curve->seed = NULL;
1,CA_434,    }
1,CA_435,
1,CA_436,    ok = 1;
1,CA_437,
1,CA_438, err:
1,CA_439,    OPENSSL_free(a_buf);
1,CA_440,    OPENSSL_free(b_buf);
1,CA_441,    BN_free(tmp_1);
1,CA_442,    BN_free(tmp_2);
1,CA_443,    return ok;
1,CA_444,}
1,CA_445,
1,CA_446,ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
1,CA_447,                                               ECPARAMETERS *params)
1,CA_448,{
1,CA_449,    size_t len = 0;
1,CA_450,    ECPARAMETERS *ret = NULL;
1,CA_451,    const BIGNUM *tmp;
1,CA_452,    unsigned char *buffer = NULL;
1,CA_453,    const EC_POINT *point = NULL;
1,CA_454,    point_conversion_form_t form;
1,CA_455,    ASN1_INTEGER *orig;
1,CA_456,
1,CA_457,    if (params == NULL) {
1,CA_458,        if ((ret = ECPARAMETERS_new()) == NULL) {
1,CA_459,            ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CA_460,            goto err;
1,CA_461,        }
1,CA_462,    } else
1,CA_463,        ret = params;
1,CA_464,
1,CA_465,    /* set the version (always one) */
1,CA_466,    ret->version = (long)0x1;
1,CA_467,
1,CA_468,    /* set the fieldID */
1,CA_469,    if (!ec_asn1_group2fieldid(group, ret->fieldID)) {
1,CA_470,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_471,        goto err;
1,CA_472,    }
1,CA_473,
1,CA_474,    /* set the curve */
1,CA_475,    if (!ec_asn1_group2curve(group, ret->curve)) {
1,CA_476,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_477,        goto err;
1,CA_478,    }
1,CA_479,
1,CA_480,    /* set the base point */
1,CA_481,    if ((point = EC_GROUP_get0_generator(group)) == NULL) {
1,CA_482,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, EC_R_UNDEFINED_GENERATOR);
1,CA_483,        goto err;
1,CA_484,    }
1,CA_485,
1,CA_486,    form = EC_GROUP_get_point_conversion_form(group);
1,CA_487,
1,CA_488,    len = EC_POINT_point2buf(group, point, form, &buffer, NULL);
1,CA_489,    if (len == 0) {
1,CA_490,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_491,        goto err;
1,CA_492,    }
1,CA_493,    if (ret->base == NULL && (ret->base = ASN1_OCTET_STRING_new()) == NULL) {
1,CA_494,        OPENSSL_free(buffer);
1,CA_495,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CA_496,        goto err;
1,CA_497,    }
1,CA_498,    ASN1_STRING_set0(ret->base, buffer, len);
1,CA_499,
1,CA_500,    /* set the order */
1,CA_501,    tmp = EC_GROUP_get0_order(group);
1,CA_502,    if (tmp == NULL) {
1,CA_503,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_504,        goto err;
1,CA_505,    }
1,CA_506,    ret->order = BN_to_ASN1_INTEGER(tmp, orig = ret->order);
1,CA_507,    if (ret->order == NULL) {
1,CA_508,        ret->order = orig;
1,CA_509,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CA_510,        goto err;
1,CA_511,    }
1,CA_512,
1,CA_513,    /* set the cofactor (optional) */
1,CA_514,    tmp = EC_GROUP_get0_cofactor(group);
1,CA_515,    if (tmp != NULL) {
1,CA_516,        ret->cofactor = BN_to_ASN1_INTEGER(tmp, orig = ret->cofactor);
1,CA_517,        if (ret->cofactor == NULL) {
1,CA_518,            ret->cofactor = orig;
1,CA_519,            ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CA_520,            goto err;
1,CA_521,        }
1,CA_522,    }
1,CA_523,
1,CA_524,    return ret;
1,CA_525,
1,CA_526, err:
1,CA_527,    if (params == NULL)
1,CA_528,        ECPARAMETERS_free(ret);
1,CA_529,    return NULL;
1,CA_530,}
1,CA_531,
1,CA_532,ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,
1,CA_533,                                            ECPKPARAMETERS *params)
1,CA_534,{
1,CA_535,    int ok = 1, tmp;
1,CA_536,    ECPKPARAMETERS *ret = params;
1,CA_537,
1,CA_538,    if (ret == NULL) {
1,CA_539,        if ((ret = ECPKPARAMETERS_new()) == NULL) {
1,CA_540,            ECerr(EC_F_EC_GROUP_GET_ECPKPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CA_541,            return NULL;
1,CA_542,        }
1,CA_543,    } else {
1,CA_544,        if (ret->type == ECPKPARAMETERS_TYPE_NAMED)
1,CA_545,            ASN1_OBJECT_free(ret->value.named_curve);
1,CA_546,        else if (ret->type == ECPKPARAMETERS_TYPE_EXPLICIT
1,CA_547,                 && ret->value.parameters != NULL)
1,CA_548,            ECPARAMETERS_free(ret->value.parameters);
1,CA_549,    }
1,CA_550,
1,CA_551,    if (EC_GROUP_get_asn1_flag(group) == OPENSSL_EC_NAMED_CURVE) {
1,CA_552,        /*
1,CA_553,         * use the asn1 OID to describe the elliptic curve parameters
1,CA_554,         */
1,CA_555,        tmp = EC_GROUP_get_curve_name(group);
1,CA_556,        if (tmp) {
1,CA_557,            ASN1_OBJECT *asn1obj = OBJ_nid2obj(tmp);
1,CA_558,
1,CA_559,            if (asn1obj == NULL || OBJ_length(asn1obj) == 0) {
1,CA_560,                ASN1_OBJECT_free(asn1obj);
1,CA_561,                ECerr(EC_F_EC_GROUP_GET_ECPKPARAMETERS, EC_R_MISSING_OID);
1,CA_562,                ok = 0;
1,CA_563,            } else {
1,CA_564,                ret->type = ECPKPARAMETERS_TYPE_NAMED;
1,CA_565,                ret->value.named_curve = asn1obj;
1,CA_566,            }
1,CA_567,        } else
1,CA_568,            /* we don't know the nid => ERROR */
1,CA_569,            ok = 0;
1,CA_570,    } else {
1,CA_571,        /* use the ECPARAMETERS structure */
1,CA_572,        ret->type = ECPKPARAMETERS_TYPE_EXPLICIT;
1,CA_573,        if ((ret->value.parameters =
1,CA_574,             EC_GROUP_get_ecparameters(group, NULL)) == NULL)
1,CA_575,            ok = 0;
1,CA_576,    }
1,CA_577,
1,CA_578,    if (!ok) {
1,CA_579,        ECPKPARAMETERS_free(ret);
1,CA_580,        return NULL;
1,CA_581,    }
1,CA_582,    return ret;
1,CA_583,}
1,CA_584,
1,CA_585,EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
1,CA_586,{
1,CA_587,    int ok = 0, tmp;
1,CA_588,    EC_GROUP *ret = NULL, *dup = NULL;
1,CA_589,    BIGNUM *p = NULL, *a = NULL, *b = NULL;
1,CA_590,    EC_POINT *point = NULL;
1,CA_591,    long field_bits;
1,CA_592,    int curve_name = NID_undef;
1,CA_593,    BN_CTX *ctx = NULL;
1,CA_594,
1,CA_595,    if (!params->fieldID || !params->fieldID->fieldType ||
1,CA_596,        !params->fieldID->p.ptr) {
1,CA_597,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_598,        goto err;
1,CA_599,    }
1,CA_600,
1,CA_601,    /*
1,CA_602,     * Now extract the curve parameters a and b. Note that, although SEC 1
1,CA_603,     * specifies the length of their encodings, historical versions of OpenSSL
1,CA_604,     * encoded them incorrectly, so we must accept any length for backwards
1,CA_605,     * compatibility.
1,CA_606,     */
1,CA_607,    if (!params->curve || !params->curve->a ||
1,CA_608,        !params->curve->a->data || !params->curve->b ||
1,CA_609,        !params->curve->b->data) {
1,CA_610,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_611,        goto err;
1,CA_612,    }
1,CA_613,    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);
1,CA_614,    if (a == NULL) {
1,CA_615,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
1,CA_616,        goto err;
1,CA_617,    }
1,CA_618,    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);
1,CA_619,    if (b == NULL) {
1,CA_620,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
1,CA_621,        goto err;
1,CA_622,    }
1,CA_623,
1,CA_624,    /* get the field parameters */
1,CA_625,    tmp = OBJ_obj2nid(params->fieldID->fieldType);
1,CA_626,    if (tmp == NID_X9_62_characteristic_two_field)
1,CA_627, 
1,CA_628,    {
1,CA_629,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);
1,CA_630,        goto err;
1,CA_631,    
1,CA_632, 
1,CA_633,    
1,CA_634,        X9_62_CHARACTERISTIC_TWO *char_two;
1,CA_635,
1,CA_636,        char_two = params->fieldID->p.char_two;
1,CA_637,
1,CA_638,        field_bits = char_two->m;
1,CA_639,        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
1,CA_640,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
1,CA_641,            goto err;
1,CA_642,        }
1,CA_643,
1,CA_644,        if ((p = BN_new()) == NULL) {
1,CA_645,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CA_646,            goto err;
1,CA_647,        }
1,CA_648,
1,CA_649,        /* get the base type */
1,CA_650,        tmp = OBJ_obj2nid(char_two->type);
1,CA_651,
1,CA_652,        if (tmp == NID_X9_62_tpBasis) {
1,CA_653,            long tmp_long;
1,CA_654,
1,CA_655,            if (!char_two->p.tpBasis) {
1,CA_656,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_657,                goto err;
1,CA_658,            }
1,CA_659,
1,CA_660,            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);
1,CA_661,
1,CA_662,            if (!(char_two->m > tmp_long && tmp_long > 0)) {
1,CA_663,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
1,CA_664,                      EC_R_INVALID_TRINOMIAL_BASIS);
1,CA_665,                goto err;
1,CA_666,            }
1,CA_667,
1,CA_668,            /* create the polynomial */
1,CA_669,            if (!BN_set_bit(p, (int)char_two->m))
1,CA_670,                goto err;
1,CA_671,            if (!BN_set_bit(p, (int)tmp_long))
1,CA_672,                goto err;
1,CA_673,            if (!BN_set_bit(p, 0))
1,CA_674,                goto err;
1,CA_675,        } else if (tmp == NID_X9_62_ppBasis) {
1,CA_676,            X9_62_PENTANOMIAL *penta;
1,CA_677,
1,CA_678,            penta = char_two->p.ppBasis;
1,CA_679,            if (!penta) {
1,CA_680,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_681,                goto err;
1,CA_682,            }
1,CA_683,
1,CA_684,            if (!
1,CA_685,                (char_two->m > penta->k3 && penta->k3 > penta->k2
1,CA_686,                 && penta->k2 > penta->k1 && penta->k1 > 0)) {
1,CA_687,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
1,CA_688,                      EC_R_INVALID_PENTANOMIAL_BASIS);
1,CA_689,                goto err;
1,CA_690,            }
1,CA_691,
1,CA_692,            /* create the polynomial */
1,CA_693,            if (!BN_set_bit(p, (int)char_two->m))
1,CA_694,                goto err;
1,CA_695,            if (!BN_set_bit(p, (int)penta->k1))
1,CA_696,                goto err;
1,CA_697,            if (!BN_set_bit(p, (int)penta->k2))
1,CA_698,                goto err;
1,CA_699,            if (!BN_set_bit(p, (int)penta->k3))
1,CA_700,                goto err;
1,CA_701,            if (!BN_set_bit(p, 0))
1,CA_702,                goto err;
1,CA_703,        } else if (tmp == NID_X9_62_onBasis) {
1,CA_704,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);
1,CA_705,            goto err;
1,CA_706,        } else {                /* error */
1,CA_707,
1,CA_708,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_709,            goto err;
1,CA_710,        }
1,CA_711,
1,CA_712,        /* create the EC_GROUP structure */
1,CA_713,        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);
1,CA_714,    }
1,CA_715, 
1,CA_716,    else if (tmp == NID_X9_62_prime_field) {
1,CA_717,        /* we have a curve over a prime field */
1,CA_718,        /* extract the prime number */
1,CA_719,        if (!params->fieldID->p.prime) {
1,CA_720,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_721,            goto err;
1,CA_722,        }
1,CA_723,        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);
1,CA_724,        if (p == NULL) {
1,CA_725,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CA_726,            goto err;
1,CA_727,        }
1,CA_728,
1,CA_729,        if (BN_is_negative(p) || BN_is_zero(p)) {
1,CA_730,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
1,CA_731,            goto err;
1,CA_732,        }
1,CA_733,
1,CA_734,        field_bits = BN_num_bits(p);
1,CA_735,        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
1,CA_736,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
1,CA_737,            goto err;
1,CA_738,        }
1,CA_739,
1,CA_740,        /* create the EC_GROUP structure */
1,CA_741,        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);
1,CA_742,    } else {
1,CA_743,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
1,CA_744,        goto err;
1,CA_745,    }
1,CA_746,
1,CA_747,    if (ret == NULL) {
1,CA_748,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_749,        goto err;
1,CA_750,    }
1,CA_751,
1,CA_752,    /* extract seed (optional) */
1,CA_753,    if (params->curve->seed != NULL) {
1,CA_754,        /*
1,CA_755,         * This happens for instance with
1,CA_756,         * fuzz/corpora/asn1/65cf44e85614c62f10cf3b7a7184c26293a19e4a
1,CA_757,         * and causes the OPENSSL_malloc below to choke on the
1,CA_758,         * zero length allocation request.
1,CA_759,         */
1,CA_760,        if (params->curve->seed->length == 0) {
1,CA_761,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_762,            goto err;
1,CA_763,        }
1,CA_764,        OPENSSL_free(ret->seed);
1,CA_765,        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {
1,CA_766,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CA_767,            goto err;
1,CA_768,        }
1,CA_769,        memcpy(ret->seed, params->curve->seed->data,
1,CA_770,               params->curve->seed->length);
1,CA_771,        ret->seed_len = params->curve->seed->length;
1,CA_772,    }
1,CA_773,
1,CA_774,    if (params->order == NULL
1,CA_775,            || params->base == NULL
1,CA_776,            || params->base->data == NULL
1,CA_777,            || params->base->length == 0) {
1,CA_778,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CA_779,        goto err;
1,CA_780,    }
1,CA_781,
1,CA_782,    if ((point = EC_POINT_new(ret)) == NULL)
1,CA_783,        goto err;
1,CA_784,
1,CA_785,    /* set the point conversion form */
1,CA_786,    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)
1,CA_787,                                       (params->base->data[0] & ~0x01));
1,CA_788,
1,CA_789,    /* extract the ec point */
1,CA_790,    if (!EC_POINT_oct2point(ret, point, params->base->data,
1,CA_791,                            params->base->length, NULL)) {
1,CA_792,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_793,        goto err;
1,CA_794,    }
1,CA_795,
1,CA_796,    /* extract the order */
1,A_797,    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {
1,CA_798,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CA_799,        goto err;
1,CA_800,    }
1,CA_801,    if (BN_is_negative(a) || BN_is_zero(a)) {
1,CA_802,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
1,CA_803,        goto err;
1,CA_804,    }
1,CA_805,    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */
1,CA_806,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
1,CA_807,        goto err;
1,CA_808,    }
1,CA_809,
1,CA_810,    /* extract the cofactor (optional) */
1,CA_811,    if (params->cofactor == NULL) {
1,CA_812,        BN_free(b);
1,CA_813,        b = NULL;
1,A_814,    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {
1,CA_815,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CA_816,        goto err;
1,CA_817,    }
1,CA_818,    /* set the generator, order and cofactor (if present) */
1,CA_819,    if (!EC_GROUP_set_generator(ret, point, a, b)) {
1,CA_820,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_821,        goto err;
1,CA_822,    }
1,CA_823,
1,CA_824,    /*
1,CA_825,     * Check if the explicit parameters group just created matches one of the
1,CA_826,     * built-in curves.
1,CA_827,     *
1,CA_828,     * We create a copy of the group just built, so that we can remove optional
1,CA_829,     * fields for the lookup: we do this to avoid the possibility that one of
1,CA_830,     * the optional parameters is used to force the library into using a less
1,CA_831,     * performant and less secure EC_METHOD instead of the specialized one.
1,CA_832,     * In any case, `seed` is not really used in any computation, while a
1,CA_833,     * cofactor different from the one in the built-in table is just
1,CA_834,     * mathematically wrong anyway and should not be used.
1,CA_835,     */
1,CA_836,    if ((ctx = BN_CTX_new()) == NULL) {
1,CA_837,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
1,CA_838,        goto err;
1,CA_839,    }
1,CA_840,    if ((dup = EC_GROUP_dup(ret)) == NULL
1,CA_841,            || EC_GROUP_set_seed(dup, NULL, 0) != 1
1,CA_842,            || !EC_GROUP_set_generator(dup, point, a, NULL)) {
1,CA_843,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_844,        goto err;
1,CA_845,    }
1,CA_846,    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
1,CA_847,        /*
1,CA_848,         * The input explicit parameters successfully matched one of the
1,CA_849,         * built-in curves: often for built-in curves we have specialized
1,CA_850,         * methods with better performance and hardening.
1,CA_851,         *
1,CA_852,         * In this case we replace the `EC_GROUP` created through explicit
1,CA_853,         * parameters with one created from a named group.
1,CA_854,         */
1,CA_855,        EC_GROUP *named_group = NULL;
1,CA_856,
1,CA_857,#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
1,CA_858,        /*
1,CA_859,         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for
1,CA_860,         * the same curve, we prefer the SECP nid when matching explicit
1,CA_861,         * parameters as that is associated with a specialized EC_METHOD.
1,CA_862,         */
1,CA_863,        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)
1,CA_864,            curve_name = NID_secp224r1;
1,CA_865,#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */
1,CA_866,
1,CA_867,        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {
1,CA_868,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CA_869,            goto err;
1,CA_870,        }
1,CA_871,        EC_GROUP_free(ret);
1,CA_872,        ret = named_group;
1,CA_873,
1,CA_874,        /*
1,CA_875,         * Set the flag so that EC_GROUPs created from explicit parameters are
1,CA_876,         * serialized using explicit parameters by default.
1,CA_877,         */
1,CA_878,        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);
1,CA_879,
1,CA_880,        /*
1,CA_881,         * If the input params do not contain the optional seed field we make
1,CA_882,         * sure it is not added to the returned group.
1,CA_883,         *
1,CA_884,         * The seed field is not really used inside libcrypto anyway, and
1,CA_885,         * adding it to parsed explicit parameter keys would alter their DER
1,CA_886,         * encoding output (because of the extra field) which could impact
1,CA_887,         * applications fingerprinting keys by their DER encoding.
1,CA_888,         */
1,CA_889,        if (params->curve->seed == NULL) {
1,CA_890,            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)
1,CA_891,                goto err;
1,CA_892,        }
1,CA_893,    }
1,CA_894,
1,CA_895,    ok = 1;
1,CA_896,
1,CA_897, err:
1,CA_898,    if (!ok) {
1,CA_899,        EC_GROUP_free(ret);
1,CA_900,        ret = NULL;
1,CA_901,    }
1,CA_902,    EC_GROUP_free(dup);
1,CA_903,
1,CA_904,    BN_free(p);
1,CA_905,    BN_free(a);
1,CA_906,    BN_free(b);
1,CA_907,    EC_POINT_free(point);
1,CA_908,
1,CA_909,    BN_CTX_free(ctx);
1,CA_910,
1,CA_911,    return ret;
1,CA_912,}
1,CA_913,
1,CB_1,/*
1,CB_2, * Copyright 2002-2022 The OpenSSL Project Authors. All Rights Reserved.
1,CB_3, *
1,CB_4, * Licensed under the OpenSSL license (the "License").  You may not use
1,CB_5, * this file except in compliance with the License.  You can obtain a copy
1,CB_6, * in the file LICENSE in the source distribution or at
1,CB_7, * https://www.openssl.org/source/license.html
1,CB_8, */
1,CB_9,
1,CB_10,#include <string.h>
1,CB_11,#include "ec_local.h"
1,CB_12,#include <openssl/err.h>
1,CB_13,#include <openssl/asn1t.h>
1,CB_14,#include <openssl/objects.h>
1,CB_15,#include "internal/nelem.h"
1,CB_16,
1,CB_17,int EC_GROUP_get_basis_type(const EC_GROUP *group)
1,CB_18,{
1,CB_19,    int i;
1,CB_20,
1,CB_21,    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
1,CB_22,        NID_X9_62_characteristic_two_field)
1,CB_23,        /* everything else is currently not supported */
1,CB_24,        return 0;
1,CB_25,
1,CB_26,    /* Find the last non-zero element of group->poly[] */
1,CB_27,    for (i = 0;
1,CB_28,         i < (int)OSSL_NELEM(group->poly) && group->poly[i] != 0;
1,CB_29,         i++)
1,CB_30,        continue;
1,CB_31,
1,CB_32,    if (i == 4)
1,CB_33,        return NID_X9_62_ppBasis;
1,CB_34,    else if (i == 2)
1,CB_35,        return NID_X9_62_tpBasis;
1,CB_36,    else
1,CB_37,        /* everything else is currently not supported */
1,CB_38,        return 0;
1,CB_39,}
1,CB_40,
1,CB_41,#ifndef OPENSSL_NO_EC2M
1,CB_42,int EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)
1,CB_43,{
1,CB_44,    if (group == NULL)
1,CB_45,        return 0;
1,CB_46,
1,CB_47,    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
1,CB_48,        NID_X9_62_characteristic_two_field
1,CB_49,        || !((group->poly[0] != 0) && (group->poly[1] != 0)
1,CB_50,             && (group->poly[2] == 0))) {
1,CB_51,        ECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS,
1,CB_52,              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
1,CB_53,        return 0;
1,CB_54,    }
1,CB_55,
1,CB_56,    if (k)
1,CB_57,        *k = group->poly[1];
1,CB_58,
1,CB_59,    return 1;
1,CB_60,}
1,CB_61,
1,CB_62,int EC_GROUP_get_pentanomial_basis(const EC_GROUP *group, unsigned int *k1,
1,CB_63,                                   unsigned int *k2, unsigned int *k3)
1,CB_64,{
1,CB_65,    if (group == NULL)
1,CB_66,        return 0;
1,CB_67,
1,CB_68,    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
1,CB_69,        NID_X9_62_characteristic_two_field
1,CB_70,        || !((group->poly[0] != 0) && (group->poly[1] != 0)
1,CB_71,             && (group->poly[2] != 0) && (group->poly[3] != 0)
1,CB_72,             && (group->poly[4] == 0))) {
1,CB_73,        ECerr(EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS,
1,CB_74,              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
1,CB_75,        return 0;
1,CB_76,    }
1,CB_77,
1,CB_78,    if (k1)
1,CB_79,        *k1 = group->poly[3];
1,CB_80,    if (k2)
1,CB_81,        *k2 = group->poly[2];
1,CB_82,    if (k3)
1,CB_83,        *k3 = group->poly[1];
1,CB_84,
1,CB_85,    return 1;
1,CB_86,}
1,CB_87,#endif
1,CB_88,
1,CB_89,/* some structures needed for the asn1 encoding */
1,CB_90,typedef struct x9_62_pentanomial_st {
1,CB_91,    int32_t k1;
1,CB_92,    int32_t k2;
1,CB_93,    int32_t k3;
1,CB_94,} X9_62_PENTANOMIAL;
1,CB_95,
1,CB_96,typedef struct x9_62_characteristic_two_st {
1,CB_97,    int32_t m;
1,CB_98,    ASN1_OBJECT *type;
1,CB_99,    union {
1,CB_100,        char *ptr;
1,CB_101,        /* NID_X9_62_onBasis */
1,CB_102,        ASN1_NULL *onBasis;
1,CB_103,        /* NID_X9_62_tpBasis */
1,CB_104,        ASN1_INTEGER *tpBasis;
1,CB_105,        /* NID_X9_62_ppBasis */
1,CB_106,        X9_62_PENTANOMIAL *ppBasis;
1,CB_107,        /* anything else */
1,CB_108,        ASN1_TYPE *other;
1,CB_109,    } p;
1,CB_110,} X9_62_CHARACTERISTIC_TWO;
1,CB_111,
1,CB_112,typedef struct x9_62_fieldid_st {
1,CB_113,    ASN1_OBJECT *fieldType;
1,CB_114,    union {
1,CB_115,        char *ptr;
1,CB_116,        /* NID_X9_62_prime_field */
1,CB_117,        ASN1_INTEGER *prime;
1,CB_118,        /* NID_X9_62_characteristic_two_field */
1,CB_119,        X9_62_CHARACTERISTIC_TWO *char_two;
1,CB_120,        /* anything else */
1,CB_121,        ASN1_TYPE *other;
1,CB_122,    } p;
1,CB_123,} X9_62_FIELDID;
1,CB_124,
1,CB_125,typedef struct x9_62_curve_st {
1,CB_126,    ASN1_OCTET_STRING *a;
1,CB_127,    ASN1_OCTET_STRING *b;
1,CB_128,    ASN1_BIT_STRING *seed;
1,CB_129,} X9_62_CURVE;
1,CB_130,
1,CB_131,struct ec_parameters_st {
1,CB_132,    int32_t version;
1,CB_133,    X9_62_FIELDID *fieldID;
1,CB_134,    X9_62_CURVE *curve;
1,CB_135,    ASN1_OCTET_STRING *base;
1,CB_136,    ASN1_INTEGER *order;
1,CB_137,    ASN1_INTEGER *cofactor;
1,CB_138,} /* ECPARAMETERS */ ;
1,CB_139,
1,CB_140,typedef enum {
1,CB_141,    ECPKPARAMETERS_TYPE_NAMED = 0,
1,CB_142,    ECPKPARAMETERS_TYPE_EXPLICIT,
1,CB_143,    ECPKPARAMETERS_TYPE_IMPLICIT
1,CB_144,} ecpk_parameters_type_t;
1,CB_145,
1,CB_146,struct ecpk_parameters_st {
1,CB_147,    int type;
1,CB_148,    union {
1,CB_149,        ASN1_OBJECT *named_curve;
1,CB_150,        ECPARAMETERS *parameters;
1,CB_151,        ASN1_NULL *implicitlyCA;
1,CB_152,    } value;
1,CB_153,} /* ECPKPARAMETERS */ ;
1,CB_154,
1,CB_155,/* SEC1 ECPrivateKey */
1,CB_156,typedef struct ec_privatekey_st {
1,CB_157,    int32_t version;
1,CB_158,    ASN1_OCTET_STRING *privateKey;
1,CB_159,    ECPKPARAMETERS *parameters;
1,CB_160,    ASN1_BIT_STRING *publicKey;
1,CB_161,} EC_PRIVATEKEY;
1,CB_162,
1,CB_163,/* the OpenSSL ASN.1 definitions */
1,CB_164,ASN1_SEQUENCE(X9_62_PENTANOMIAL) = {
1,CB_165,        ASN1_EMBED(X9_62_PENTANOMIAL, k1, INT32),
1,CB_166,        ASN1_EMBED(X9_62_PENTANOMIAL, k2, INT32),
1,CB_167,        ASN1_EMBED(X9_62_PENTANOMIAL, k3, INT32)
1,CB_168,} static_ASN1_SEQUENCE_END(X9_62_PENTANOMIAL)
1,CB_169,
1,CB_170,DECLARE_ASN1_ALLOC_FUNCTIONS(X9_62_PENTANOMIAL)
1,CB_171,IMPLEMENT_ASN1_ALLOC_FUNCTIONS(X9_62_PENTANOMIAL)
1,CB_172,
1,CB_173,ASN1_ADB_TEMPLATE(char_two_def) = ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.other, ASN1_ANY);
1,CB_174,
1,CB_175,ASN1_ADB(X9_62_CHARACTERISTIC_TWO) = {
1,CB_176,        ADB_ENTRY(NID_X9_62_onBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.onBasis, ASN1_NULL)),
1,CB_177,        ADB_ENTRY(NID_X9_62_tpBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.tpBasis, ASN1_INTEGER)),
1,CB_178,        ADB_ENTRY(NID_X9_62_ppBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.ppBasis, X9_62_PENTANOMIAL))
1,CB_179,} ASN1_ADB_END(X9_62_CHARACTERISTIC_TWO, 0, type, 0, &char_two_def_tt, NULL);
1,CB_180,
1,CB_181,ASN1_SEQUENCE(X9_62_CHARACTERISTIC_TWO) = {
1,CB_182,        ASN1_EMBED(X9_62_CHARACTERISTIC_TWO, m, INT32),
1,CB_183,        ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, type, ASN1_OBJECT),
1,CB_184,        ASN1_ADB_OBJECT(X9_62_CHARACTERISTIC_TWO)
1,CB_185,} static_ASN1_SEQUENCE_END(X9_62_CHARACTERISTIC_TWO)
1,CB_186,
1,CB_187,DECLARE_ASN1_ALLOC_FUNCTIONS(X9_62_CHARACTERISTIC_TWO)
1,CB_188,IMPLEMENT_ASN1_ALLOC_FUNCTIONS(X9_62_CHARACTERISTIC_TWO)
1,CB_189,
1,CB_190,ASN1_ADB_TEMPLATE(fieldID_def) = ASN1_SIMPLE(X9_62_FIELDID, p.other, ASN1_ANY);
1,CB_191,
1,CB_192,ASN1_ADB(X9_62_FIELDID) = {
1,CB_193,        ADB_ENTRY(NID_X9_62_prime_field, ASN1_SIMPLE(X9_62_FIELDID, p.prime, ASN1_INTEGER)),
1,CB_194,        ADB_ENTRY(NID_X9_62_characteristic_two_field, ASN1_SIMPLE(X9_62_FIELDID, p.char_two, X9_62_CHARACTERISTIC_TWO))
1,CB_195,} ASN1_ADB_END(X9_62_FIELDID, 0, fieldType, 0, &fieldID_def_tt, NULL);
1,CB_196,
1,CB_197,ASN1_SEQUENCE(X9_62_FIELDID) = {
1,CB_198,        ASN1_SIMPLE(X9_62_FIELDID, fieldType, ASN1_OBJECT),
1,CB_199,        ASN1_ADB_OBJECT(X9_62_FIELDID)
1,CB_200,} static_ASN1_SEQUENCE_END(X9_62_FIELDID)
1,CB_201,
1,CB_202,ASN1_SEQUENCE(X9_62_CURVE) = {
1,CB_203,        ASN1_SIMPLE(X9_62_CURVE, a, ASN1_OCTET_STRING),
1,CB_204,        ASN1_SIMPLE(X9_62_CURVE, b, ASN1_OCTET_STRING),
1,CB_205,        ASN1_OPT(X9_62_CURVE, seed, ASN1_BIT_STRING)
1,CB_206,} static_ASN1_SEQUENCE_END(X9_62_CURVE)
1,CB_207,
1,CB_208,ASN1_SEQUENCE(ECPARAMETERS) = {
1,CB_209,        ASN1_EMBED(ECPARAMETERS, version, INT32),
1,CB_210,        ASN1_SIMPLE(ECPARAMETERS, fieldID, X9_62_FIELDID),
1,CB_211,        ASN1_SIMPLE(ECPARAMETERS, curve, X9_62_CURVE),
1,CB_212,        ASN1_SIMPLE(ECPARAMETERS, base, ASN1_OCTET_STRING),
1,CB_213,        ASN1_SIMPLE(ECPARAMETERS, order, ASN1_INTEGER),
1,CB_214,        ASN1_OPT(ECPARAMETERS, cofactor, ASN1_INTEGER)
1,CB_215,} ASN1_SEQUENCE_END(ECPARAMETERS)
1,CB_216,
1,CB_217,DECLARE_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)
1,CB_218,IMPLEMENT_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)
1,CB_219,
1,CB_220,ASN1_CHOICE(ECPKPARAMETERS) = {
1,CB_221,        ASN1_SIMPLE(ECPKPARAMETERS, value.named_curve, ASN1_OBJECT),
1,CB_222,        ASN1_SIMPLE(ECPKPARAMETERS, value.parameters, ECPARAMETERS),
1,CB_223,        ASN1_SIMPLE(ECPKPARAMETERS, value.implicitlyCA, ASN1_NULL)
1,CB_224,} ASN1_CHOICE_END(ECPKPARAMETERS)
1,CB_225,
1,CB_226,DECLARE_ASN1_FUNCTIONS_const(ECPKPARAMETERS)
1,CB_227,DECLARE_ASN1_ENCODE_FUNCTIONS_const(ECPKPARAMETERS, ECPKPARAMETERS)
1,CB_228,IMPLEMENT_ASN1_FUNCTIONS_const(ECPKPARAMETERS)
1,CB_229,
1,CB_230,ASN1_SEQUENCE(EC_PRIVATEKEY) = {
1,CB_231,        ASN1_EMBED(EC_PRIVATEKEY, version, INT32),
1,CB_232,        ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
1,CB_233,        ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
1,CB_234,        ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
1,CB_235,} static_ASN1_SEQUENCE_END(EC_PRIVATEKEY)
1,CB_236,
1,CB_237,DECLARE_ASN1_FUNCTIONS_const(EC_PRIVATEKEY)
1,CB_238,DECLARE_ASN1_ENCODE_FUNCTIONS_const(EC_PRIVATEKEY, EC_PRIVATEKEY)
1,CB_239,IMPLEMENT_ASN1_FUNCTIONS_const(EC_PRIVATEKEY)
1,CB_240,
1,CB_241,/* some declarations of internal function */
1,CB_242,
1,CB_243,/* ec_asn1_group2field() sets the values in a X9_62_FIELDID object */
1,CB_244,static int ec_asn1_group2fieldid(const EC_GROUP *, X9_62_FIELDID *);
1,CB_245,/* ec_asn1_group2curve() sets the values in a X9_62_CURVE object */
1,CB_246,static int ec_asn1_group2curve(const EC_GROUP *, X9_62_CURVE *);
1,CB_247,
1,CB_248,/* the function definitions */
1,CB_249,
1,CB_250,static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
1,CB_251,{
1,CB_252,    int ok = 0, nid;
1,CB_253,    BIGNUM *tmp = NULL;
1,CB_254,
1,CB_255,    if (group == NULL || field == NULL)
1,CB_256,        return 0;
1,CB_257,
1,CB_258,    /* clear the old values (if necessary) */
1,CB_259,    ASN1_OBJECT_free(field->fieldType);
1,CB_260,    ASN1_TYPE_free(field->p.other);
1,CB_261,
1,CB_262,    nid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));
1,CB_263,    /* set OID for the field */
1,CB_264,    if ((field->fieldType = OBJ_nid2obj(nid)) == NULL) {
1,CB_265,        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
1,CB_266,        goto err;
1,CB_267,    }
1,CB_268,
1,CB_269,    if (nid == NID_X9_62_prime_field) {
1,CB_270,        if ((tmp = BN_new()) == NULL) {
1,CB_271,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CB_272,            goto err;
1,CB_273,        }
1,CB_274,        /* the parameters are specified by the prime number p */
1,CB_275,        if (!EC_GROUP_get_curve(group, tmp, NULL, NULL, NULL)) {
1,CB_276,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
1,CB_277,            goto err;
1,CB_278,        }
1,CB_279,        /* set the prime number */
1,CB_280,        field->p.prime = BN_to_ASN1_INTEGER(tmp, NULL);
1,CB_281,        if (field->p.prime == NULL) {
1,CB_282,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
1,CB_283,            goto err;
1,CB_284,        }
1,CB_285,    } else if (nid == NID_X9_62_characteristic_two_field)
1,CB_286,#ifdef OPENSSL_NO_EC2M
1,CB_287,    {
1,CB_288,        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_GF2M_NOT_SUPPORTED);
1,CB_289,        goto err;
1,CB_290,    }
1,CB_291,#else
1,CB_292,    {
1,CB_293,        int field_type;
1,CB_294,        X9_62_CHARACTERISTIC_TWO *char_two;
1,CB_295,
1,CB_296,        field->p.char_two = X9_62_CHARACTERISTIC_TWO_new();
1,CB_297,        char_two = field->p.char_two;
1,CB_298,
1,CB_299,        if (char_two == NULL) {
1,CB_300,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CB_301,            goto err;
1,CB_302,        }
1,CB_303,
1,CB_304,        char_two->m = (long)EC_GROUP_get_degree(group);
1,CB_305,
1,CB_306,        field_type = EC_GROUP_get_basis_type(group);
1,CB_307,
1,CB_308,        if (field_type == 0) {
1,CB_309,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
1,CB_310,            goto err;
1,CB_311,        }
1,CB_312,        /* set base type OID */
1,CB_313,        if ((char_two->type = OBJ_nid2obj(field_type)) == NULL) {
1,CB_314,            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
1,CB_315,            goto err;
1,CB_316,        }
1,CB_317,
1,CB_318,        if (field_type == NID_X9_62_tpBasis) {
1,CB_319,            unsigned int k;
1,CB_320,
1,CB_321,            if (!EC_GROUP_get_trinomial_basis(group, &k))
1,CB_322,                goto err;
1,CB_323,
1,CB_324,            char_two->p.tpBasis = ASN1_INTEGER_new();
1,CB_325,            if (char_two->p.tpBasis == NULL) {
1,CB_326,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CB_327,                goto err;
1,CB_328,            }
1,CB_329,            if (!ASN1_INTEGER_set(char_two->p.tpBasis, (long)k)) {
1,CB_330,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
1,CB_331,                goto err;
1,CB_332,            }
1,CB_333,        } else if (field_type == NID_X9_62_ppBasis) {
1,CB_334,            unsigned int k1, k2, k3;
1,CB_335,
1,CB_336,            if (!EC_GROUP_get_pentanomial_basis(group, &k1, &k2, &k3))
1,CB_337,                goto err;
1,CB_338,
1,CB_339,            char_two->p.ppBasis = X9_62_PENTANOMIAL_new();
1,CB_340,            if (char_two->p.ppBasis == NULL) {
1,CB_341,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CB_342,                goto err;
1,CB_343,            }
1,CB_344,
1,CB_345,            /* set k? values */
1,CB_346,            char_two->p.ppBasis->k1 = (long)k1;
1,CB_347,            char_two->p.ppBasis->k2 = (long)k2;
1,CB_348,            char_two->p.ppBasis->k3 = (long)k3;
1,CB_349,        } else {                /* field_type == NID_X9_62_onBasis */
1,CB_350,
1,CB_351,            /* for ONB the parameters are (asn1) NULL */
1,CB_352,            char_two->p.onBasis = ASN1_NULL_new();
1,CB_353,            if (char_two->p.onBasis == NULL) {
1,CB_354,                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
1,CB_355,                goto err;
1,CB_356,            }
1,CB_357,        }
1,CB_358,    }
1,CB_359,#endif
1,CB_360,    else {
1,CB_361,        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_UNSUPPORTED_FIELD);
1,CB_362,        goto err;
1,CB_363,    }
1,CB_364,
1,CB_365,    ok = 1;
1,CB_366,
1,CB_367, err:
1,CB_368,    BN_free(tmp);
1,CB_369,    return ok;
1,CB_370,}
1,CB_371,
1,CB_372,static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
1,CB_373,{
1,CB_374,    int ok = 0;
1,CB_375,    BIGNUM *tmp_1 = NULL, *tmp_2 = NULL;
1,CB_376,    unsigned char *a_buf = NULL, *b_buf = NULL;
1,CB_377,    size_t len;
1,CB_378,
1,CB_379,    if (!group || !curve || !curve->a || !curve->b)
1,CB_380,        return 0;
1,CB_381,
1,CB_382,    if ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL) {
1,CB_383,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
1,CB_384,        goto err;
1,CB_385,    }
1,CB_386,
1,CB_387,    /* get a and b */
1,CB_388,    if (!EC_GROUP_get_curve(group, NULL, tmp_1, tmp_2, NULL)) {
1,CB_389,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);
1,CB_390,        goto err;
1,CB_391,    }
1,CB_392,
1,CB_393,    /*
1,CB_394,     * Per SEC 1, the curve coefficients must be padded up to size. See C.2's
1,CB_395,     * definition of Curve, C.1's definition of FieldElement, and 2.3.5's
1,CB_396,     * definition of how to encode the field elements.
1,CB_397,     */
1,CB_398,    len = ((size_t)EC_GROUP_get_degree(group) + 7) / 8;
1,CB_399,    if ((a_buf = OPENSSL_malloc(len)) == NULL
1,CB_400,        || (b_buf = OPENSSL_malloc(len)) == NULL) {
1,CB_401,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
1,CB_402,        goto err;
1,CB_403,    }
1,CB_404,    if (BN_bn2binpad(tmp_1, a_buf, len) < 0
1,CB_405,        || BN_bn2binpad(tmp_2, b_buf, len) < 0) {
1,CB_406,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);
1,CB_407,        goto err;
1,CB_408,    }
1,CB_409,
1,CB_410,    /* set a and b */
1,CB_411,    if (!ASN1_OCTET_STRING_set(curve->a, a_buf, len)
1,CB_412,        || !ASN1_OCTET_STRING_set(curve->b, b_buf, len)) {
1,CB_413,        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
1,CB_414,        goto err;
1,CB_415,    }
1,CB_416,
1,CB_417,    /* set the seed (optional) */
1,CB_418,    if (group->seed) {
1,CB_419,        if (!curve->seed)
1,CB_420,            if ((curve->seed = ASN1_BIT_STRING_new()) == NULL) {
1,CB_421,                ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
1,CB_422,                goto err;
1,CB_423,            }
1,CB_424,        curve->seed->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
1,CB_425,        curve->seed->flags |= ASN1_STRING_FLAG_BITS_LEFT;
1,CB_426,        if (!ASN1_BIT_STRING_set(curve->seed, group->seed,
1,CB_427,                                 (int)group->seed_len)) {
1,CB_428,            ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
1,CB_429,            goto err;
1,CB_430,        }
1,CB_431,    } else {
1,CB_432,        ASN1_BIT_STRING_free(curve->seed);
1,CB_433,        curve->seed = NULL;
1,CB_434,    }
1,CB_435,
1,CB_436,    ok = 1;
1,CB_437,
1,CB_438, err:
1,CB_439,    OPENSSL_free(a_buf);
1,CB_440,    OPENSSL_free(b_buf);
1,CB_441,    BN_free(tmp_1);
1,CB_442,    BN_free(tmp_2);
1,CB_443,    return ok;
1,CB_444,}
1,CB_445,
1,CB_446,ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
1,CB_447,                                               ECPARAMETERS *params)
1,CB_448,{
1,CB_449,    size_t len = 0;
1,CB_450,    ECPARAMETERS *ret = NULL;
1,CB_451,    const BIGNUM *tmp;
1,CB_452,    unsigned char *buffer = NULL;
1,CB_453,    const EC_POINT *point = NULL;
1,CB_454,    point_conversion_form_t form;
1,CB_455,    ASN1_INTEGER *orig;
1,CB_456,
1,CB_457,    if (params == NULL) {
1,CB_458,        if ((ret = ECPARAMETERS_new()) == NULL) {
1,CB_459,            ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CB_460,            goto err;
1,CB_461,        }
1,CB_462,    } else
1,CB_463,        ret = params;
1,CB_464,
1,CB_465,    /* set the version (always one) */
1,CB_466,    ret->version = (long)0x1;
1,CB_467,
1,CB_468,    /* set the fieldID */
1,CB_469,    if (!ec_asn1_group2fieldid(group, ret->fieldID)) {
1,CB_470,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_471,        goto err;
1,CB_472,    }
1,CB_473,
1,CB_474,    /* set the curve */
1,CB_475,    if (!ec_asn1_group2curve(group, ret->curve)) {
1,CB_476,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_477,        goto err;
1,CB_478,    }
1,CB_479,
1,CB_480,    /* set the base point */
1,CB_481,    if ((point = EC_GROUP_get0_generator(group)) == NULL) {
1,CB_482,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, EC_R_UNDEFINED_GENERATOR);
1,CB_483,        goto err;
1,CB_484,    }
1,CB_485,
1,CB_486,    form = EC_GROUP_get_point_conversion_form(group);
1,CB_487,
1,CB_488,    len = EC_POINT_point2buf(group, point, form, &buffer, NULL);
1,CB_489,    if (len == 0) {
1,CB_490,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_491,        goto err;
1,CB_492,    }
1,CB_493,    if (ret->base == NULL && (ret->base = ASN1_OCTET_STRING_new()) == NULL) {
1,CB_494,        OPENSSL_free(buffer);
1,CB_495,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CB_496,        goto err;
1,CB_497,    }
1,CB_498,    ASN1_STRING_set0(ret->base, buffer, len);
1,CB_499,
1,CB_500,    /* set the order */
1,CB_501,    tmp = EC_GROUP_get0_order(group);
1,CB_502,    if (tmp == NULL) {
1,CB_503,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_504,        goto err;
1,CB_505,    }
1,CB_506,    ret->order = BN_to_ASN1_INTEGER(tmp, orig = ret->order);
1,CB_507,    if (ret->order == NULL) {
1,CB_508,        ret->order = orig;
1,CB_509,        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CB_510,        goto err;
1,CB_511,    }
1,CB_512,
1,CB_513,    /* set the cofactor (optional) */
1,CB_514,    tmp = EC_GROUP_get0_cofactor(group);
1,CB_515,    if (tmp != NULL) {
1,CB_516,        ret->cofactor = BN_to_ASN1_INTEGER(tmp, orig = ret->cofactor);
1,CB_517,        if (ret->cofactor == NULL) {
1,CB_518,            ret->cofactor = orig;
1,CB_519,            ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CB_520,            goto err;
1,CB_521,        }
1,CB_522,    }
1,CB_523,
1,CB_524,    return ret;
1,CB_525,
1,CB_526, err:
1,CB_527,    if (params == NULL)
1,CB_528,        ECPARAMETERS_free(ret);
1,CB_529,    return NULL;
1,CB_530,}
1,CB_531,
1,CB_532,ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,
1,CB_533,                                            ECPKPARAMETERS *params)
1,CB_534,{
1,CB_535,    int ok = 1, tmp;
1,CB_536,    ECPKPARAMETERS *ret = params;
1,CB_537,
1,CB_538,    if (ret == NULL) {
1,CB_539,        if ((ret = ECPKPARAMETERS_new()) == NULL) {
1,CB_540,            ECerr(EC_F_EC_GROUP_GET_ECPKPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CB_541,            return NULL;
1,CB_542,        }
1,CB_543,    } else {
1,CB_544,        if (ret->type == ECPKPARAMETERS_TYPE_NAMED)
1,CB_545,            ASN1_OBJECT_free(ret->value.named_curve);
1,CB_546,        else if (ret->type == ECPKPARAMETERS_TYPE_EXPLICIT
1,CB_547,                 && ret->value.parameters != NULL)
1,CB_548,            ECPARAMETERS_free(ret->value.parameters);
1,CB_549,    }
1,CB_550,
1,CB_551,    if (EC_GROUP_get_asn1_flag(group) == OPENSSL_EC_NAMED_CURVE) {
1,CB_552,        /*
1,CB_553,         * use the asn1 OID to describe the elliptic curve parameters
1,CB_554,         */
1,CB_555,        tmp = EC_GROUP_get_curve_name(group);
1,CB_556,        if (tmp) {
1,CB_557,            ASN1_OBJECT *asn1obj = OBJ_nid2obj(tmp);
1,CB_558,
1,CB_559,            if (asn1obj == NULL || OBJ_length(asn1obj) == 0) {
1,CB_560,                ASN1_OBJECT_free(asn1obj);
1,CB_561,                ECerr(EC_F_EC_GROUP_GET_ECPKPARAMETERS, EC_R_MISSING_OID);
1,CB_562,                ok = 0;
1,CB_563,            } else {
1,CB_564,                ret->type = ECPKPARAMETERS_TYPE_NAMED;
1,CB_565,                ret->value.named_curve = asn1obj;
1,CB_566,            }
1,CB_567,        } else
1,CB_568,            /* we don't know the nid => ERROR */
1,CB_569,            ok = 0;
1,CB_570,    } else {
1,CB_571,        /* use the ECPARAMETERS structure */
1,CB_572,        ret->type = ECPKPARAMETERS_TYPE_EXPLICIT;
1,CB_573,        if ((ret->value.parameters =
1,CB_574,             EC_GROUP_get_ecparameters(group, NULL)) == NULL)
1,CB_575,            ok = 0;
1,CB_576,    }
1,CB_577,
1,CB_578,    if (!ok) {
1,CB_579,        ECPKPARAMETERS_free(ret);
1,CB_580,        return NULL;
1,CB_581,    }
1,CB_582,    return ret;
1,CB_583,}
1,CB_584,
1,CB_585,EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
1,CB_586,{
1,CB_587,    int ok = 0, tmp;
1,CB_588,    EC_GROUP *ret = NULL, *dup = NULL;
1,CB_589,    BIGNUM *p = NULL, *a = NULL, *b = NULL;
1,CB_590,    EC_POINT *point = NULL;
1,CB_591,    long field_bits;
1,CB_592,    int curve_name = NID_undef;
1,CB_593,    BN_CTX *ctx = NULL;
1,CB_594,
1,CB_595,    if (!params->fieldID || !params->fieldID->fieldType ||
1,CB_596,        !params->fieldID->p.ptr) {
1,CB_597,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_598,        goto err;
1,CB_599,    }
1,CB_600,
1,CB_601,    /*
1,CB_602,     * Now extract the curve parameters a and b. Note that, although SEC 1
1,CB_603,     * specifies the length of their encodings, historical versions of OpenSSL
1,CB_604,     * encoded them incorrectly, so we must accept any length for backwards
1,CB_605,     * compatibility.
1,CB_606,     */
1,CB_607,    if (!params->curve || !params->curve->a ||
1,CB_608,        !params->curve->a->data || !params->curve->b ||
1,CB_609,        !params->curve->b->data) {
1,CB_610,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_611,        goto err;
1,CB_612,    }
1,CB_613,    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);
1,CB_614,    if (a == NULL) {
1,CB_615,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
1,CB_616,        goto err;
1,CB_617,    }
1,CB_618,    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);
1,CB_619,    if (b == NULL) {
1,CB_620,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
1,CB_621,        goto err;
1,CB_622,    }
1,CB_623,
1,CB_624,    /* get the field parameters */
1,CB_625,    tmp = OBJ_obj2nid(params->fieldID->fieldType);
1,CB_626,    if (tmp == NID_X9_62_characteristic_two_field)
1,CB_627, 
1,CB_628,    {
1,CB_629,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);
1,CB_630,        goto err;
1,CB_631,
1,CB_632,
1,CB_633,
1,CB_634,        X9_62_CHARACTERISTIC_TWO *char_two;
1,CB_635,
1,CB_636,        char_two = params->fieldID->p.char_two;
1,CB_637,
1,CB_638,        field_bits = char_two->m;
1,CB_639,        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
1,CB_640,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
1,CB_641,            goto err;
1,CB_642,        }
1,CB_643,
1,CB_644,        if ((p = BN_new()) == NULL) {
1,CB_645,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CB_646,            goto err;
1,CB_647,        }
1,CB_648,
1,CB_649,        /* get the base type */
1,CB_650,        tmp = OBJ_obj2nid(char_two->type);
1,CB_651,
1,CB_652,        if (tmp == NID_X9_62_tpBasis) {
1,CB_653,            long tmp_long;
1,CB_654,
1,CB_655,            if (!char_two->p.tpBasis) {
1,CB_656,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_657,                goto err;
1,CB_658,            }
1,CB_659,
1,CB_660,            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);
1,CB_661,
1,CB_662,            if (!(char_two->m > tmp_long && tmp_long > 0)) {
1,CB_663,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
1,CB_664,                      EC_R_INVALID_TRINOMIAL_BASIS);
1,CB_665,                goto err;
1,CB_666,            }
1,CB_667,
1,CB_668,            /* create the polynomial */
1,CB_669,            if (!BN_set_bit(p, (int)char_two->m))
1,CB_670,                goto err;
1,CB_671,            if (!BN_set_bit(p, (int)tmp_long))
1,CB_672,                goto err;
1,CB_673,            if (!BN_set_bit(p, 0))
1,CB_674,                goto err;
1,CB_675,        } else if (tmp == NID_X9_62_ppBasis) {
1,CB_676,            X9_62_PENTANOMIAL *penta;
1,CB_677,
1,CB_678,            penta = char_two->p.ppBasis;
1,CB_679,            if (!penta) {
1,CB_680,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_681,                goto err;
1,CB_682,            }
1,CB_683,
1,CB_684,            if (!
1,CB_685,                (char_two->m > penta->k3 && penta->k3 > penta->k2
1,CB_686,                 && penta->k2 > penta->k1 && penta->k1 > 0)) {
1,CB_687,                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
1,CB_688,                      EC_R_INVALID_PENTANOMIAL_BASIS);
1,CB_689,                goto err;
1,CB_690,            }
1,CB_691,
1,CB_692,            /* create the polynomial */
1,CB_693,            if (!BN_set_bit(p, (int)char_two->m))
1,CB_694,                goto err;
1,CB_695,            if (!BN_set_bit(p, (int)penta->k1))
1,CB_696,                goto err;
1,CB_697,            if (!BN_set_bit(p, (int)penta->k2))
1,CB_698,                goto err;
1,CB_699,            if (!BN_set_bit(p, (int)penta->k3))
1,CB_700,                goto err;
1,CB_701,            if (!BN_set_bit(p, 0))
1,CB_702,                goto err;
1,CB_703,        } else if (tmp == NID_X9_62_onBasis) {
1,CB_704,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);
1,CB_705,            goto err;
1,CB_706,        } else {                /* error */
1,CB_707,
1,CB_708,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_709,            goto err;
1,CB_710,        }
1,CB_711,
1,CB_712,        /* create the EC_GROUP structure */
1,CB_713,        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);
1,CB_714,    }
1,CB_715, 
1,CB_716,    else if (tmp == NID_X9_62_prime_field) {
1,CB_717,        /* we have a curve over a prime field */
1,CB_718,        /* extract the prime number */
1,CB_719,        if (!params->fieldID->p.prime) {
1,CB_720,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_721,            goto err;
1,CB_722,        }
1,CB_723,        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);
1,CB_724,        if (p == NULL) {
1,CB_725,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CB_726,            goto err;
1,CB_727,        }
1,CB_728,
1,CB_729,        if (BN_is_negative(p) || BN_is_zero(p)) {
1,CB_730,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
1,CB_731,            goto err;
1,CB_732,        }
1,CB_733,
1,CB_734,        field_bits = BN_num_bits(p);
1,CB_735,        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
1,CB_736,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
1,CB_737,            goto err;
1,CB_738,        }
1,CB_739,
1,CB_740,        /* create the EC_GROUP structure */
1,CB_741,        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);
1,CB_742,    } else {
1,CB_743,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
1,CB_744,        goto err;
1,CB_745,    }
1,CB_746,
1,CB_747,    if (ret == NULL) {
1,CB_748,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_749,        goto err;
1,CB_750,    }
1,CB_751,
1,CB_752,    /* extract seed (optional) */
1,CB_753,    if (params->curve->seed != NULL) {
1,CB_754,        /*
1,CB_755,         * This happens for instance with
1,CB_756,         * fuzz/corpora/asn1/65cf44e85614c62f10cf3b7a7184c26293a19e4a
1,CB_757,         * and causes the OPENSSL_malloc below to choke on the
1,CB_758,         * zero length allocation request.
1,CB_759,         */
1,CB_760,        if (params->curve->seed->length == 0) {
1,CB_761,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_762,            goto err;
1,CB_763,        }
1,CB_764,        OPENSSL_free(ret->seed);
1,CB_765,        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {
1,CB_766,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CB_767,            goto err;
1,CB_768,        }
1,CB_769,        memcpy(ret->seed, params->curve->seed->data,
1,CB_770,               params->curve->seed->length);
1,CB_771,        ret->seed_len = params->curve->seed->length;
1,CB_772,    }
1,CB_773,
1,CB_774,    if (params->order == NULL
1,CB_775,            || params->base == NULL
1,CB_776,            || params->base->data == NULL
1,CB_777,            || params->base->length == 0) {
1,CB_778,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
1,CB_779,        goto err;
1,CB_780,    }
1,CB_781,
1,CB_782,    if ((point = EC_POINT_new(ret)) == NULL)
1,CB_783,        goto err;
1,CB_784,
1,CB_785,    /* set the point conversion form */
1,CB_786,    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)
1,CB_787,                                       (params->base->data[0] & ~0x01));
1,CB_788,
1,CB_789,    /* extract the ec point */
1,CB_790,    if (!EC_POINT_oct2point(ret, point, params->base->data,
1,CB_791,                            params->base->length, NULL)) {
1,CB_792,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_793,        goto err;
1,CB_794,    }
1,CB_795,
1,CB_796,    /* extract the order */
1,B_797,    if (ASN1_INTEGER_to_BN(params->order, a) == NULL) {
1,CB_798,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CB_799,        goto err;
1,CB_800,    }
1,CB_801,    if (BN_is_negative(a) || BN_is_zero(a)) {
1,CB_802,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
1,CB_803,        goto err;
1,CB_804,    }
1,CB_805,    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */
1,CB_806,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
1,CB_807,        goto err;
1,CB_808,    }
1,CB_809,
1,CB_810,    /* extract the cofactor (optional) */
1,CB_811,    if (params->cofactor == NULL) {
1,CB_812,        BN_free(b);
1,CB_813,        b = NULL;
1,B_814,    } else if (ASN1_INTEGER_to_BN(params->cofactor, b) == NULL) {
1,CB_815,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
1,CB_816,        goto err;
1,CB_817,    }
1,CB_818,    /* set the generator, order and cofactor (if present) */
1,CB_819,    if (!EC_GROUP_set_generator(ret, point, a, b)) {
1,CB_820,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_821,        goto err;
1,CB_822,    }
1,CB_823,
1,CB_824,    /*
1,CB_825,     * Check if the explicit parameters group just created matches one of the
1,CB_826,     * built-in curves.
1,CB_827,     *
1,CB_828,     * We create a copy of the group just built, so that we can remove optional
1,CB_829,     * fields for the lookup: we do this to avoid the possibility that one of
1,CB_830,     * the optional parameters is used to force the library into using a less
1,CB_831,     * performant and less secure EC_METHOD instead of the specialized one.
1,CB_832,     * In any case, `seed` is not really used in any computation, while a
1,CB_833,     * cofactor different from the one in the built-in table is just
1,CB_834,     * mathematically wrong anyway and should not be used.
1,CB_835,     */
1,CB_836,    if ((ctx = BN_CTX_new()) == NULL) {
1,CB_837,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
1,CB_838,        goto err;
1,CB_839,    }
1,CB_840,    if ((dup = EC_GROUP_dup(ret)) == NULL
1,CB_841,            || EC_GROUP_set_seed(dup, NULL, 0) != 1
1,CB_842,            || !EC_GROUP_set_generator(dup, point, a, NULL)) {
1,CB_843,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_844,        goto err;
1,CB_845,    }
1,CB_846,    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
1,CB_847,        /*
1,CB_848,         * The input explicit parameters successfully matched one of the
1,CB_849,         * built-in curves: often for built-in curves we have specialized
1,CB_850,         * methods with better performance and hardening.
1,CB_851,         *
1,CB_852,         * In this case we replace the `EC_GROUP` created through explicit
1,CB_853,         * parameters with one created from a named group.
1,CB_854,         */
1,CB_855,        EC_GROUP *named_group = NULL;
1,CB_856,
1,CB_857,#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
1,CB_858,        /*
1,CB_859,         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for
1,CB_860,         * the same curve, we prefer the SECP nid when matching explicit
1,CB_861,         * parameters as that is associated with a specialized EC_METHOD.
1,CB_862,         */
1,CB_863,        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)
1,CB_864,            curve_name = NID_secp224r1;
1,CB_865,#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */
1,CB_866,
1,CB_867,        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {
1,CB_868,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_869,            goto err;
1,CB_870,        }
1,CB_871,        EC_GROUP_free(ret);
1,CB_872,        ret = named_group;
1,CB_873,
1,CB_874,        /*
1,CB_875,         * Set the flag so that EC_GROUPs created from explicit parameters are
1,CB_876,         * serialized using explicit parameters by default.
1,CB_877,         */
1,CB_878,        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);
1,CB_879,
1,CB_880,        /*
1,CB_881,         * If the input params do not contain the optional seed field we make
1,CB_882,         * sure it is not added to the returned group.
1,CB_883,         *
1,CB_884,         * The seed field is not really used inside libcrypto anyway, and
1,CB_885,         * adding it to parsed explicit parameter keys would alter their DER
1,CB_886,         * encoding output (because of the extra field) which could impact
1,CB_887,         * applications fingerprinting keys by their DER encoding.
1,CB_888,         */
1,CB_889,        if (params->curve->seed == NULL) {
1,CB_890,            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)
1,CB_891,                goto err;
1,CB_892,        }
1,CB_893,    }
1,CB_894,
1,CB_895,    ok = 1;
1,CB_896,
1,CB_897, err:
1,CB_898,    if (!ok) {
1,CB_899,        EC_GROUP_free(ret);
1,CB_900,        ret = NULL;
1,CB_901,    }
1,CB_902,    EC_GROUP_free(dup);
1,CB_903,
1,CB_904,    BN_free(p);
1,CB_905,    BN_free(a);
1,CB_906,    BN_free(b);
1,CB_907,    EC_POINT_free(point);
1,CB_908,
1,CB_909,    BN_CTX_free(ctx);
1,CB_910,
1,CB_911,    return ret;
1,CB_912,}
1,CB_913,
1,CB_914,EC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params)
1,CB_915,{
1,CB_916,    EC_GROUP *ret = NULL;
1,CB_917,    int tmp = 0;
1,CB_918,
1,CB_919,    if (params == NULL) {
1,CB_920,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS, EC_R_MISSING_PARAMETERS);
1,CB_921,        return NULL;
1,CB_922,    }
1,CB_923,
1,CB_924,    if (params->type == ECPKPARAMETERS_TYPE_NAMED) {
1,CB_925,        /* the curve is given by an OID */
1,CB_926,        tmp = OBJ_obj2nid(params->value.named_curve);
1,CB_927,        if ((ret = EC_GROUP_new_by_curve_name(tmp)) == NULL) {
1,CB_928,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS,
1,CB_929,                  EC_R_EC_GROUP_NEW_BY_NAME_FAILURE);
1,CB_930,            return NULL;
1,CB_931,        }
1,CB_932,        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_NAMED_CURVE);
1,CB_933,    } else if (params->type == ECPKPARAMETERS_TYPE_EXPLICIT) {
1,CB_934,        /* the parameters are given by an ECPARAMETERS structure */
1,CB_935,        ret = EC_GROUP_new_from_ecparameters(params->value.parameters);
1,CB_936,        if (!ret) {
1,CB_937,            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS, ERR_R_EC_LIB);
1,CB_938,            return NULL;
1,CB_939,        }
1,CB_940,        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);
1,CB_941,    } else if (params->type == ECPKPARAMETERS_TYPE_IMPLICIT) {
1,CB_942,        /* implicit parameters inherited from CA - unsupported */
1,CB_943,        return NULL;
1,CB_944,    } else {
1,CB_945,        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS, EC_R_ASN1_ERROR);
1,CB_946,        return NULL;
1,CB_947,    }
1,CB_948,
1,CB_949,    return ret;
1,CB_950,}
1,CB_951,
1,CB_952,/* EC_GROUP <-> DER encoding of ECPKPARAMETERS */
1,CB_953,
1,CB_954,EC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)
1,CB_955,{
1,CB_956,    EC_GROUP *group = NULL;
1,CB_957,    ECPKPARAMETERS *params = NULL;
1,CB_958,    const unsigned char *p = *in;
1,CB_959,
1,CB_960,    if ((params = d2i_ECPKPARAMETERS(NULL, &p, len)) == NULL) {
1,CB_961,        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);
1,CB_962,        ECPKPARAMETERS_free(params);
1,CB_963,        return NULL;
1,CB_964,    }
1,CB_965,
1,CB_966,    if ((group = EC_GROUP_new_from_ecpkparameters(params)) == NULL) {
1,CB_967,        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);
1,CB_968,        ECPKPARAMETERS_free(params);
1,CB_969,        return NULL;
1,CB_970,    }
1,CB_971,
1,CB_972,    if (params->type == ECPKPARAMETERS_TYPE_EXPLICIT)
1,CB_973,        group->decoded_from_explicit_params = 1;
1,CB_974,
1,CB_975,    if (a) {
1,CB_976,        EC_GROUP_free(*a);
1,CB_977,        *a = group;
1,CB_978,    }
1,CB_979,
1,CB_980,    ECPKPARAMETERS_free(params);
1,CB_981,    *in = p;
1,CB_982,    return group;
1,CB_983,}
1,CB_984,
1,CB_985,int i2d_ECPKParameters(const EC_GROUP *a, unsigned char **out)
1,CB_986,{
1,CB_987,    int ret = 0;
1,CB_988,    ECPKPARAMETERS *tmp = EC_GROUP_get_ecpkparameters(a, NULL);
1,CB_989,    if (tmp == NULL) {
1,CB_990,        ECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_GROUP2PKPARAMETERS_FAILURE);
1,CB_991,        return 0;
1,CB_992,    }
1,CB_993,    if ((ret = i2d_ECPKPARAMETERS(tmp, out)) == 0) {
1,CB_994,        ECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_I2D_ECPKPARAMETERS_FAILURE);
1,CB_995,        ECPKPARAMETERS_free(tmp);
1,CB_996,        return 0;
1,CB_997,    }
1,CB_998,    ECPKPARAMETERS_free(tmp);
1,CB_999,    return ret;
1,CB_1000,}
1,CB_1001,
1,CB_1002,/* some EC_KEY functions */
1,CB_1003,
1,CB_1004,EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
1,CB_1005,{
1,CB_1006,    EC_KEY *ret = NULL;
1,CB_1007,    EC_PRIVATEKEY *priv_key = NULL;
1,CB_1008,    const unsigned char *p = *in;
1,CB_1009,
1,CB_1010,    if ((priv_key = d2i_EC_PRIVATEKEY(NULL, &p, len)) == NULL) {
1,CB_1011,        ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1012,        return NULL;
1,CB_1013,    }
1,CB_1014,
1,CB_1015,    if (a == NULL || *a == NULL) {
1,CB_1016,        if ((ret = EC_KEY_new()) == NULL) {
1,CB_1017,            ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
1,CB_1018,            goto err;
1,CB_1019,        }
1,CB_1020,    } else
1,CB_1021,        ret = *a;
1,CB_1022,
1,CB_1023,    if (priv_key->parameters) {
1,CB_1024,        EC_GROUP_free(ret->group);
1,CB_1025,        ret->group = EC_GROUP_new_from_ecpkparameters(priv_key->parameters);
1,CB_1026,        if (ret->group != NULL
1,CB_1027,            && priv_key->parameters->type == ECPKPARAMETERS_TYPE_EXPLICIT)
1,CB_1028,            ret->group->decoded_from_explicit_params = 1;
1,CB_1029,    }
1,CB_1030,
1,CB_1031,    if (ret->group == NULL) {
1,CB_1032,        ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1033,        goto err;
1,CB_1034,    }
1,CB_1035,
1,CB_1036,    ret->version = priv_key->version;
1,CB_1037,
1,CB_1038,    if (priv_key->privateKey) {
1,CB_1039,        ASN1_OCTET_STRING *pkey = priv_key->privateKey;
1,CB_1040,        if (EC_KEY_oct2priv(ret, ASN1_STRING_get0_data(pkey),
1,CB_1041,                            ASN1_STRING_length(pkey)) == 0)
1,CB_1042,            goto err;
1,CB_1043,    } else {
1,CB_1044,        ECerr(EC_F_D2I_ECPRIVATEKEY, EC_R_MISSING_PRIVATE_KEY);
1,CB_1045,        goto err;
1,CB_1046,    }
1,CB_1047,
1,CB_1048,    EC_POINT_clear_free(ret->pub_key);
1,CB_1049,    ret->pub_key = EC_POINT_new(ret->group);
1,CB_1050,    if (ret->pub_key == NULL) {
1,CB_1051,        ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1052,        goto err;
1,CB_1053,    }
1,CB_1054,
1,CB_1055,    if (priv_key->publicKey) {
1,CB_1056,        const unsigned char *pub_oct;
1,CB_1057,        int pub_oct_len;
1,CB_1058,
1,CB_1059,        pub_oct = ASN1_STRING_get0_data(priv_key->publicKey);
1,CB_1060,        pub_oct_len = ASN1_STRING_length(priv_key->publicKey);
1,CB_1061,        if (!EC_KEY_oct2key(ret, pub_oct, pub_oct_len, NULL)) {
1,CB_1062,            ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1063,            goto err;
1,CB_1064,        }
1,CB_1065,    } else {
1,CB_1066,        if (ret->group->meth->keygenpub == NULL
1,CB_1067,            || ret->group->meth->keygenpub(ret) == 0)
1,CB_1068,                goto err;
1,CB_1069,        /* Remember the original private-key-only encoding. */
1,CB_1070,        ret->enc_flag |= EC_PKEY_NO_PUBKEY;
1,CB_1071,    }
1,CB_1072,
1,CB_1073,    if (a)
1,CB_1074,        *a = ret;
1,CB_1075,    EC_PRIVATEKEY_free(priv_key);
1,CB_1076,    *in = p;
1,CB_1077,    return ret;
1,CB_1078,
1,CB_1079, err:
1,CB_1080,    if (a == NULL || *a != ret)
1,CB_1081,        EC_KEY_free(ret);
1,CB_1082,    EC_PRIVATEKEY_free(priv_key);
1,CB_1083,    return NULL;
1,CB_1084,}
1,CB_1085,
1,CB_1086,int i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)
1,CB_1087,{
1,CB_1088,    int ret = 0, ok = 0;
1,CB_1089,    unsigned char *priv= NULL, *pub= NULL;
1,CB_1090,    size_t privlen = 0, publen = 0;
1,CB_1091,
1,CB_1092,    EC_PRIVATEKEY *priv_key = NULL;
1,CB_1093,
1,CB_1094,    if (a == NULL || a->group == NULL ||
1,CB_1095,        (!(a->enc_flag & EC_PKEY_NO_PUBKEY) && a->pub_key == NULL)) {
1,CB_1096,        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
1,CB_1097,        goto err;
1,CB_1098,    }
1,CB_1099,
1,CB_1100,    if ((priv_key = EC_PRIVATEKEY_new()) == NULL) {
1,CB_1101,        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
1,CB_1102,        goto err;
1,CB_1103,    }
1,CB_1104,
1,CB_1105,    priv_key->version = a->version;
1,CB_1106,
1,CB_1107,    privlen = EC_KEY_priv2buf(a, &priv);
1,CB_1108,
1,CB_1109,    if (privlen == 0) {
1,CB_1110,        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1111,        goto err;
1,CB_1112,    }
1,CB_1113,
1,CB_1114,    ASN1_STRING_set0(priv_key->privateKey, priv, privlen);
1,CB_1115,    priv = NULL;
1,CB_1116,
1,CB_1117,    if (!(a->enc_flag & EC_PKEY_NO_PARAMETERS)) {
1,CB_1118,        if ((priv_key->parameters =
1,CB_1119,             EC_GROUP_get_ecpkparameters(a->group,
1,CB_1120,                                        priv_key->parameters)) == NULL) {
1,CB_1121,            ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1122,            goto err;
1,CB_1123,        }
1,CB_1124,    }
1,CB_1125,
1,CB_1126,    if (!(a->enc_flag & EC_PKEY_NO_PUBKEY)) {
1,CB_1127,        priv_key->publicKey = ASN1_BIT_STRING_new();
1,CB_1128,        if (priv_key->publicKey == NULL) {
1,CB_1129,            ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
1,CB_1130,            goto err;
1,CB_1131,        }
1,CB_1132,
1,CB_1133,        publen = EC_KEY_key2buf(a, a->conv_form, &pub, NULL);
1,CB_1134,
1,CB_1135,        if (publen == 0) {
1,CB_1136,            ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1137,            goto err;
1,CB_1138,        }
1,CB_1139,
1,CB_1140,        priv_key->publicKey->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
1,CB_1141,        priv_key->publicKey->flags |= ASN1_STRING_FLAG_BITS_LEFT;
1,CB_1142,        ASN1_STRING_set0(priv_key->publicKey, pub, publen);
1,CB_1143,        pub = NULL;
1,CB_1144,    }
1,CB_1145,
1,CB_1146,    if ((ret = i2d_EC_PRIVATEKEY(priv_key, out)) == 0) {
1,CB_1147,        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
1,CB_1148,        goto err;
1,CB_1149,    }
1,CB_1150,    ok = 1;
1,CB_1151, err:
1,CB_1152,    OPENSSL_clear_free(priv, privlen);
1,CB_1153,    OPENSSL_free(pub);
1,CB_1154,    EC_PRIVATEKEY_free(priv_key);
1,CB_1155,    return (ok ? ret : 0);
1,CB_1156,}
1,CB_1157,
1,CB_1158,int i2d_ECParameters(EC_KEY *a, unsigned char **out)
1,CB_1159,{
1,CB_1160,    if (a == NULL) {
1,CB_1161,        ECerr(EC_F_I2D_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);
1,CB_1162,        return 0;
1,CB_1163,    }
1,CB_1164,    return i2d_ECPKParameters(a->group, out);
1,CB_1165,}
1,CB_1166,
1,CB_1167,EC_KEY *d2i_ECParameters(EC_KEY **a, const unsigned char **in, long len)
1,CB_1168,{
1,CB_1169,    EC_KEY *ret;
1,CB_1170,
1,CB_1171,    if (in == NULL || *in == NULL) {
1,CB_1172,        ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);
1,CB_1173,        return NULL;
1,CB_1174,    }
1,CB_1175,
1,CB_1176,    if (a == NULL || *a == NULL) {
1,CB_1177,        if ((ret = EC_KEY_new()) == NULL) {
1,CB_1178,            ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
1,CB_1179,            return NULL;
1,CB_1180,        }
1,CB_1181,    } else
1,CB_1182,        ret = *a;
1,CB_1183,
1,CB_1184,    if (!d2i_ECPKParameters(&ret->group, in, len)) {
1,CB_1185,        ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_EC_LIB);
1,CB_1186,        if (a == NULL || *a != ret)
1,CB_1187,             EC_KEY_free(ret);
1,CB_1188,        return NULL;
1,CB_1189,    }
1,CB_1190,
1,CB_1191,    if (a)
1,CB_1192,        *a = ret;
1,CB_1193,
1,CB_1194,    return ret;
1,CB_1195,}
1,CB_1196,
1,CB_1197,EC_KEY *o2i_ECPublicKey(EC_KEY **a, const unsigned char **in, long len)
1,CB_1198,{
1,CB_1199,    EC_KEY *ret = NULL;
1,CB_1200,
1,CB_1201,    if (a == NULL || (*a) == NULL || (*a)->group == NULL) {
1,CB_1202,        /*
1,CB_1203,         * sorry, but a EC_GROUP-structure is necessary to set the public key
1,CB_1204,         */
1,CB_1205,        ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
1,CB_1206,        return 0;
1,CB_1207,    }
1,CB_1208,    ret = *a;
1,CB_1209,    if (!EC_KEY_oct2key(ret, *in, len, NULL)) {
1,CB_1210,        ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_EC_LIB);
1,CB_1211,        return 0;
1,CB_1212,    }
1,CB_1213,    *in += len;
1,CB_1214,    return ret;
1,CB_1215,}
1,CB_1216,
1,CB_1217,int i2o_ECPublicKey(const EC_KEY *a, unsigned char **out)
1,CB_1218,{
1,CB_1219,    size_t buf_len = 0;
1,CB_1220,    int new_buffer = 0;
1,CB_1221,
1,CB_1222,    if (a == NULL) {
1,CB_1223,        ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
1,CB_1224,        return 0;
1,CB_1225,    }
1,CB_1226,
1,CB_1227,    buf_len = EC_POINT_point2oct(a->group, a->pub_key,
1,CB_1228,                                 a->conv_form, NULL, 0, NULL);
1,CB_1229,
1,CB_1230,    if (out == NULL || buf_len == 0)
1,CB_1231,        /* out == NULL => just return the length of the octet string */
1,CB_1232,        return buf_len;
1,CB_1233,
1,CB_1234,    if (*out == NULL) {
1,CB_1235,        if ((*out = OPENSSL_malloc(buf_len)) == NULL) {
1,CB_1236,            ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);
1,CB_1237,            return 0;
1,CB_1238,        }
1,CB_1239,        new_buffer = 1;
1,CB_1240,    }
1,CB_1241,    if (!EC_POINT_point2oct(a->group, a->pub_key, a->conv_form,
1,CB_1242,                            *out, buf_len, NULL)) {
1,CB_1243,        ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);
1,CB_1244,        if (new_buffer) {
1,CB_1245,            OPENSSL_free(*out);
1,CB_1246,            *out = NULL;
1,CB_1247,        }
1,CB_1248,        return 0;
1,CB_1249,    }
1,CB_1250,    if (!new_buffer)
1,CB_1251,        *out += buf_len;
1,CB_1252,    return buf_len;
1,CB_1253,}
1,CB_1254,
1,CB_1255,ASN1_SEQUENCE(ECDSA_SIG) = {
1,CB_1256,        ASN1_SIMPLE(ECDSA_SIG, r, CBIGNUM),
1,CB_1257,        ASN1_SIMPLE(ECDSA_SIG, s, CBIGNUM)
1,CB_1258,} static_ASN1_SEQUENCE_END(ECDSA_SIG)
1,CB_1259,
1,CB_1260,DECLARE_ASN1_FUNCTIONS_const(ECDSA_SIG)
1,CB_1261,DECLARE_ASN1_ENCODE_FUNCTIONS_const(ECDSA_SIG, ECDSA_SIG)
1,CB_1262,IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(ECDSA_SIG, ECDSA_SIG, ECDSA_SIG)
1,CB_1263,
1,CB_1264,ECDSA_SIG *ECDSA_SIG_new(void)
1,CB_1265,{
1,CB_1266,    ECDSA_SIG *sig = OPENSSL_zalloc(sizeof(*sig));
1,CB_1267,    if (sig == NULL)
1,CB_1268,        ECerr(EC_F_ECDSA_SIG_NEW, ERR_R_MALLOC_FAILURE);
1,CB_1269,    return sig;
1,CB_1270,}
1,CB_1271,
1,CB_1272,void ECDSA_SIG_free(ECDSA_SIG *sig)
1,CB_1273,{
1,CB_1274,    if (sig == NULL)
1,CB_1275,        return;
1,CB_1276,    BN_clear_free(sig->r);
1,CB_1277,    BN_clear_free(sig->s);
1,CB_1278,    OPENSSL_free(sig);
1,CB_1279,}
1,CB_1280,
1,CB_1281,void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)
1,CB_1282,{
1,CB_1283,    if (pr != NULL)
1,CB_1284,        *pr = sig->r;
1,CB_1285,    if (ps != NULL)
1,CB_1286,        *ps = sig->s;
1,CB_1287,}
1,CB_1288,
1,CB_1289,const BIGNUM *ECDSA_SIG_get0_r(const ECDSA_SIG *sig)
1,CB_1290,{
1,CB_1291,    return sig->r;
1,CB_1292,}
1,CB_1293,
1,CB_1294,const BIGNUM *ECDSA_SIG_get0_s(const ECDSA_SIG *sig)
1,CB_1295,{
1,CB_1296,    return sig->s;
1,CB_1297,}
1,CB_1298,
1,CB_1299,int ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s)
1,CB_1300,{
1,CB_1301,    if (r == NULL || s == NULL)
1,CB_1302,        return 0;
1,CB_1303,    BN_clear_free(sig->r);
1,CB_1304,    BN_clear_free(sig->s);
1,CB_1305,    sig->r = r;
1,CB_1306,    sig->s = s;
1,CB_1307,    return 1;
1,CB_1308,}
1,CB_1309,
1,CB_1310,int ECDSA_size(const EC_KEY *r)
1,CB_1311,{
1,CB_1312,    int ret, i;
1,CB_1313,    ASN1_INTEGER bs;
1,CB_1314,    unsigned char buf[4];
1,CB_1315,    const EC_GROUP *group;
1,CB_1316,
1,CB_1317,    if (r == NULL)
1,CB_1318,        return 0;
1,CB_1319,    group = EC_KEY_get0_group(r);
1,CB_1320,    if (group == NULL)
1,CB_1321,        return 0;
1,CB_1322,
1,CB_1323,    i = EC_GROUP_order_bits(group);
1,CB_1324,    if (i == 0)
1,CB_1325,        return 0;
1,CB_1326,    bs.length = (i + 7) / 8;
1,CB_1327,    bs.data = buf;
1,CB_1328,    bs.type = V_ASN1_INTEGER;
1,CB_1329,    /* If the top bit is set the asn1 encoding is 1 larger. */
1,CB_1330,    buf[0] = 0xff;
1,CB_1331,
1,CB_1332,    i = i2d_ASN1_INTEGER(&bs, NULL);
1,CB_1333,    i += i;                     /* r and s */
1,CB_1334,    ret = ASN1_object_size(1, i, V_ASN1_SEQUENCE);
1,CB_1335,    if (ret < 0)
1,CB_1336,        return 0;
1,CB_1337,    return ret;
1,CB_1338,}
1,CB_1339,
2,CA_1,/*
2,A_2, * Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved.
2,CA_3, *
2,CA_4, * Licensed under the OpenSSL license (the "License").  You may not use
2,CA_5, * this file except in compliance with the License.  You can obtain a copy
2,CA_6, * in the file LICENSE in the source distribution or at
2,CA_7, * https://www.openssl.org/source/license.html
2,CA_8, */
2,CA_9,
2,CA_10,/*
2,CA_11, * Implementation of RFC 3779 section 2.2.
2,CA_12, */
2,CA_13,
2,CA_14,#include <stdio.h>
2,CA_15,#include <stdlib.h>
2,CA_16,
2,CA_17,#include "internal/cryptlib.h"
2,CA_18,#include <openssl/conf.h>
2,CA_19,#include <openssl/asn1.h>
2,CA_20,#include <openssl/asn1t.h>
2,CA_21,#include <openssl/buffer.h>
2,CA_22,#include <openssl/x509v3.h>
2,CA_23,#include "crypto/x509.h"
2,CA_24,#include "ext_dat.h"
2,CA_25,
2,CA_26,#ifndef OPENSSL_NO_RFC3779
2,CA_27,
2,CA_28,/*
2,CA_29, * OpenSSL ASN.1 template translation of RFC 3779 2.2.3.
2,CA_30, */
2,CA_31,
2,CA_32,ASN1_SEQUENCE(IPAddressRange) = {
2,CA_33,  ASN1_SIMPLE(IPAddressRange, min, ASN1_BIT_STRING),
2,CA_34,  ASN1_SIMPLE(IPAddressRange, max, ASN1_BIT_STRING)
2,CA_35,} ASN1_SEQUENCE_END(IPAddressRange)
2,CA_36,
2,CA_37,ASN1_CHOICE(IPAddressOrRange) = {
2,CA_38,  ASN1_SIMPLE(IPAddressOrRange, u.addressPrefix, ASN1_BIT_STRING),
2,CA_39,  ASN1_SIMPLE(IPAddressOrRange, u.addressRange,  IPAddressRange)
2,CA_40,} ASN1_CHOICE_END(IPAddressOrRange)
2,CA_41,
2,CA_42,ASN1_CHOICE(IPAddressChoice) = {
2,CA_43,  ASN1_SIMPLE(IPAddressChoice,      u.inherit,           ASN1_NULL),
2,CA_44,  ASN1_SEQUENCE_OF(IPAddressChoice, u.addressesOrRanges, IPAddressOrRange)
2,CA_45,} ASN1_CHOICE_END(IPAddressChoice)
2,CA_46,
2,CA_47,ASN1_SEQUENCE(IPAddressFamily) = {
2,CA_48,  ASN1_SIMPLE(IPAddressFamily, addressFamily,   ASN1_OCTET_STRING),
2,CA_49,  ASN1_SIMPLE(IPAddressFamily, ipAddressChoice, IPAddressChoice)
2,CA_50,} ASN1_SEQUENCE_END(IPAddressFamily)
2,CA_51,
2,CA_52,ASN1_ITEM_TEMPLATE(IPAddrBlocks) =
2,CA_53,  ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0,
2,CA_54,                        IPAddrBlocks, IPAddressFamily)
2,CA_55,static_ASN1_ITEM_TEMPLATE_END(IPAddrBlocks)
2,CA_56,
2,CA_57,IMPLEMENT_ASN1_FUNCTIONS(IPAddressRange)
2,CA_58,IMPLEMENT_ASN1_FUNCTIONS(IPAddressOrRange)
2,CA_59,IMPLEMENT_ASN1_FUNCTIONS(IPAddressChoice)
2,CA_60,IMPLEMENT_ASN1_FUNCTIONS(IPAddressFamily)
2,CA_61,
2,CA_62,/*
2,CA_63, * How much buffer space do we need for a raw address?
2,CA_64, */
2,CA_65,#define ADDR_RAW_BUF_LEN        16
2,CA_66,
2,CA_67,/*
2,CA_68, * What's the address length associated with this AFI?
2,CA_69, */
2,CA_70,static int length_from_afi(const unsigned afi)
2,CA_71,{
2,CA_72,    switch (afi) {
2,CA_73,    case IANA_AFI_IPV4:
2,CA_74,        return 4;
2,CA_75,    case IANA_AFI_IPV6:
2,CA_76,        return 16;
2,CA_77,    default:
2,CA_78,        return 0;
2,CA_79,    }
2,CA_80,}
2,CA_81,
2,CA_82,/*
2,CA_83, * Extract the AFI from an IPAddressFamily.
2,CA_84, */
2,CA_85,unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)
2,CA_86,{
2,CA_87,    if (f == NULL
2,CA_88,            || f->addressFamily == NULL
2,CA_89,            || f->addressFamily->data == NULL
2,CA_90,            || f->addressFamily->length < 2)
2,CA_91,        return 0;
2,CA_92,    return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1];
2,CA_93,}
2,CA_94,
2,CA_95,/*
2,CA_96, * Expand the bitstring form of an address into a raw byte array.
2,CA_97, * At the moment this is coded for simplicity, not speed.
2,CA_98, */
2,CA_99,static int addr_expand(unsigned char *addr,
2,CA_100,                       const ASN1_BIT_STRING *bs,
2,CA_101,                       const int length, const unsigned char fill)
2,CA_102,{
2,CA_103,    if (bs->length < 0 || bs->length > length)
2,CA_104,        return 0;
2,CA_105,    if (bs->length > 0) {
2,CA_106,        memcpy(addr, bs->data, bs->length);
2,CA_107,        if ((bs->flags & 7) != 0) {
2,CA_108,            unsigned char mask = 0xFF >> (8 - (bs->flags & 7));
2,CA_109,            if (fill == 0)
2,CA_110,                addr[bs->length - 1] &= ~mask;
2,CA_111,            else
2,CA_112,                addr[bs->length - 1] |= mask;
2,CA_113,        }
2,CA_114,    }
2,CA_115,    memset(addr + bs->length, fill, length - bs->length);
2,CA_116,    return 1;
2,CA_117,}
2,CA_118,
2,CA_119,/*
2,CA_120, * Extract the prefix length from a bitstring.
2,CA_121, */
2,CA_122,#define addr_prefixlen(bs) ((int) ((bs)->length * 8 - ((bs)->flags & 7)))
2,CA_123,
2,CA_124,/*
2,CA_125, * i2r handler for one address bitstring.
2,CA_126, */
2,CA_127,static int i2r_address(BIO *out,
2,CA_128,                       const unsigned afi,
2,CA_129,                       const unsigned char fill, const ASN1_BIT_STRING *bs)
2,CA_130,{
2,CA_131,    unsigned char addr[ADDR_RAW_BUF_LEN];
2,CA_132,    int i, n;
2,CA_133,
2,CA_134,    if (bs->length < 0)
2,CA_135,        return 0;
2,CA_136,    switch (afi) {
2,CA_137,    case IANA_AFI_IPV4:
2,CA_138,        if (!addr_expand(addr, bs, 4, fill))
2,CA_139,            return 0;
2,CA_140,        BIO_printf(out, "%d.%d.%d.%d", addr[0], addr[1], addr[2], addr[3]);
2,CA_141,        break;
2,CA_142,    case IANA_AFI_IPV6:
2,CA_143,        if (!addr_expand(addr, bs, 16, fill))
2,CA_144,            return 0;
2,CA_145,        for (n = 16; n > 1 && addr[n - 1] == 0x00 && addr[n - 2] == 0x00;
2,CA_146,             n -= 2) ;
2,CA_147,        for (i = 0; i < n; i += 2)
2,CA_148,            BIO_printf(out, "%x%s", (addr[i] << 8) | addr[i + 1],
2,CA_149,                       (i < 14 ? ":" : ""));
2,CA_150,        if (i < 16)
2,CA_151,            BIO_puts(out, ":");
2,CA_152,        if (i == 0)
2,CA_153,            BIO_puts(out, ":");
2,CA_154,        break;
2,CA_155,    default:
2,CA_156,        for (i = 0; i < bs->length; i++)
2,CA_157,            BIO_printf(out, "%s%02x", (i > 0 ? ":" : ""), bs->data[i]);
2,CA_158,        BIO_printf(out, "[%d]", (int)(bs->flags & 7));
2,CA_159,        break;
2,CA_160,    }
2,CA_161,    return 1;
2,CA_162,}
2,CA_163,
2,CA_164,/*
2,CA_165, * i2r handler for a sequence of addresses and ranges.
2,CA_166, */
2,CA_167,static int i2r_IPAddressOrRanges(BIO *out,
2,CA_168,                                 const int indent,
2,CA_169,                                 const IPAddressOrRanges *aors,
2,CA_170,                                 const unsigned afi)
2,CA_171,{
2,CA_172,    int i;
2,CA_173,    for (i = 0; i < sk_IPAddressOrRange_num(aors); i++) {
2,CA_174,        const IPAddressOrRange *aor = sk_IPAddressOrRange_value(aors, i);
2,CA_175,        BIO_printf(out, "%*s", indent, "");
2,CA_176,        switch (aor->type) {
2,CA_177,        case IPAddressOrRange_addressPrefix:
2,CA_178,            if (!i2r_address(out, afi, 0x00, aor->u.addressPrefix))
2,CA_179,                return 0;
2,CA_180,            BIO_printf(out, "/%d
2,CA_181,", addr_prefixlen(aor->u.addressPrefix));
2,CA_182,            continue;
2,CA_183,        case IPAddressOrRange_addressRange:
2,CA_184,            if (!i2r_address(out, afi, 0x00, aor->u.addressRange->min))
2,CA_185,                return 0;
2,CA_186,            BIO_puts(out, "-");
2,CA_187,            if (!i2r_address(out, afi, 0xFF, aor->u.addressRange->max))
2,CA_188,                return 0;
2,CA_189,            BIO_puts(out, "
2,CA_190,");
2,CA_191,            continue;
2,CA_192,        }
2,CA_193,    }
2,CA_194,    return 1;
2,CA_195,}
2,CA_196,
2,CA_197,/*
2,CA_198, * i2r handler for an IPAddrBlocks extension.
2,CA_199, */
2,CA_200,static int i2r_IPAddrBlocks(const X509V3_EXT_METHOD *method,
2,CA_201,                            void *ext, BIO *out, int indent)
2,CA_202,{
2,CA_203,    const IPAddrBlocks *addr = ext;
2,CA_204,    int i;
2,CA_205,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CA_206,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CA_207,        const unsigned int afi = X509v3_addr_get_afi(f);
2,CA_208,        switch (afi) {
2,CA_209,        case IANA_AFI_IPV4:
2,CA_210,            BIO_printf(out, "%*sIPv4", indent, "");
2,CA_211,            break;
2,CA_212,        case IANA_AFI_IPV6:
2,CA_213,            BIO_printf(out, "%*sIPv6", indent, "");
2,CA_214,            break;
2,CA_215,        default:
2,CA_216,            BIO_printf(out, "%*sUnknown AFI %u", indent, "", afi);
2,CA_217,            break;
2,CA_218,        }
2,CA_219,        if (f->addressFamily->length > 2) {
2,CA_220,            switch (f->addressFamily->data[2]) {
2,CA_221,            case 1:
2,CA_222,                BIO_puts(out, " (Unicast)");
2,CA_223,                break;
2,CA_224,            case 2:
2,CA_225,                BIO_puts(out, " (Multicast)");
2,CA_226,                break;
2,CA_227,            case 3:
2,CA_228,                BIO_puts(out, " (Unicast/Multicast)");
2,CA_229,                break;
2,CA_230,            case 4:
2,CA_231,                BIO_puts(out, " (MPLS)");
2,CA_232,                break;
2,CA_233,            case 64:
2,CA_234,                BIO_puts(out, " (Tunnel)");
2,CA_235,                break;
2,CA_236,            case 65:
2,CA_237,                BIO_puts(out, " (VPLS)");
2,CA_238,                break;
2,CA_239,            case 66:
2,CA_240,                BIO_puts(out, " (BGP MDT)");
2,CA_241,                break;
2,CA_242,            case 128:
2,CA_243,                BIO_puts(out, " (MPLS-labeled VPN)");
2,CA_244,                break;
2,CA_245,            default:
2,CA_246,                BIO_printf(out, " (Unknown SAFI %u)",
2,CA_247,                           (unsigned)f->addressFamily->data[2]);
2,CA_248,                break;
2,CA_249,            }
2,CA_250,        }
2,CA_251,        switch (f->ipAddressChoice->type) {
2,CA_252,        case IPAddressChoice_inherit:
2,CA_253,            BIO_puts(out, ": inherit
2,CA_254,");
2,CA_255,            break;
2,CA_256,        case IPAddressChoice_addressesOrRanges:
2,CA_257,            BIO_puts(out, ":
2,CA_258,");
2,CA_259,            if (!i2r_IPAddressOrRanges(out,
2,CA_260,                                       indent + 2,
2,CA_261,                                       f->ipAddressChoice->
2,CA_262,                                       u.addressesOrRanges, afi))
2,CA_263,                return 0;
2,CA_264,            break;
2,CA_265,        }
2,CA_266,    }
2,CA_267,    return 1;
2,CA_268,}
2,CA_269,
2,CA_270,/*
2,CA_271, * Sort comparison function for a sequence of IPAddressOrRange
2,CA_272, * elements.
2,CA_273, *
2,CA_274, * There's no sane answer we can give if addr_expand() fails, and an
2,CA_275, * assertion failure on externally supplied data is seriously uncool,
2,CA_276, * so we just arbitrarily declare that if given invalid inputs this
2,CA_277, * function returns -1.  If this messes up your preferred sort order
2,CA_278, * for garbage input, tough noogies.
2,CA_279, */
2,CA_280,static int IPAddressOrRange_cmp(const IPAddressOrRange *a,
2,CA_281,                                const IPAddressOrRange *b, const int length)
2,CA_282,{
2,CA_283,    unsigned char addr_a[ADDR_RAW_BUF_LEN], addr_b[ADDR_RAW_BUF_LEN];
2,CA_284,    int prefixlen_a = 0, prefixlen_b = 0;
2,CA_285,    int r;
2,CA_286,
2,CA_287,    switch (a->type) {
2,CA_288,    case IPAddressOrRange_addressPrefix:
2,CA_289,        if (!addr_expand(addr_a, a->u.addressPrefix, length, 0x00))
2,CA_290,            return -1;
2,CA_291,        prefixlen_a = addr_prefixlen(a->u.addressPrefix);
2,CA_292,        break;
2,CA_293,    case IPAddressOrRange_addressRange:
2,CA_294,        if (!addr_expand(addr_a, a->u.addressRange->min, length, 0x00))
2,CA_295,            return -1;
2,CA_296,        prefixlen_a = length * 8;
2,CA_297,        break;
2,CA_298,    }
2,CA_299,
2,CA_300,    switch (b->type) {
2,CA_301,    case IPAddressOrRange_addressPrefix:
2,CA_302,        if (!addr_expand(addr_b, b->u.addressPrefix, length, 0x00))
2,CA_303,            return -1;
2,CA_304,        prefixlen_b = addr_prefixlen(b->u.addressPrefix);
2,CA_305,        break;
2,CA_306,    case IPAddressOrRange_addressRange:
2,CA_307,        if (!addr_expand(addr_b, b->u.addressRange->min, length, 0x00))
2,CA_308,            return -1;
2,CA_309,        prefixlen_b = length * 8;
2,CA_310,        break;
2,CA_311,    }
2,CA_312,
2,CA_313,    if ((r = memcmp(addr_a, addr_b, length)) != 0)
2,CA_314,        return r;
2,CA_315,    else
2,CA_316,        return prefixlen_a - prefixlen_b;
2,CA_317,}
2,CA_318,
2,CA_319,/*
2,CA_320, * IPv4-specific closure over IPAddressOrRange_cmp, since sk_sort()
2,CA_321, * comparison routines are only allowed two arguments.
2,CA_322, */
2,CA_323,static int v4IPAddressOrRange_cmp(const IPAddressOrRange *const *a,
2,CA_324,                                  const IPAddressOrRange *const *b)
2,CA_325,{
2,CA_326,    return IPAddressOrRange_cmp(*a, *b, 4);
2,CA_327,}
2,CA_328,
2,CA_329,/*
2,CA_330, * IPv6-specific closure over IPAddressOrRange_cmp, since sk_sort()
2,CA_331, * comparison routines are only allowed two arguments.
2,CA_332, */
2,CA_333,static int v6IPAddressOrRange_cmp(const IPAddressOrRange *const *a,
2,CA_334,                                  const IPAddressOrRange *const *b)
2,CA_335,{
2,CA_336,    return IPAddressOrRange_cmp(*a, *b, 16);
2,CA_337,}
2,CA_338,
2,CA_339,static int range_should_be_prefix(const unsigned char *min,
2,CA_340,                                  const unsigned char *max, const int length)
2,CA_341,{
2,CA_342,    unsigned char mask;
2,CA_343,    int i, j;
2,CA_344,
2,A_345,    if (memcmp(min, max, length) <= 0)
2,A_346,        return -1;
2,CA_347,    for (i = 0; i < length && min[i] == max[i]; i++) ;
2,CA_348,    for (j = length - 1; j >= 0 && min[j] == 0x00 && max[j] == 0xFF; j--) ;
2,CA_349,    if (i < j)
2,CA_350,        return -1;
2,CA_351,    if (i > j)
2,CA_352,        return i * 8;
2,CA_353,    mask = min[i] ^ max[i];
2,CA_354,    switch (mask) {
2,CA_355,    case 0x01:
2,CA_356,        j = 7;
2,CA_357,        break;
2,CA_358,    case 0x03:
2,CA_359,        j = 6;
2,CA_360,        break;
2,CA_361,    case 0x07:
2,CA_362,        j = 5;
2,CA_363,        break;
2,CA_364,    case 0x0F:
2,CA_365,        j = 4;
2,CA_366,        break;
2,CA_367,    case 0x1F:
2,CA_368,        j = 3;
2,CA_369,        break;
2,CA_370,    case 0x3F:
2,CA_371,        j = 2;
2,CA_372,        break;
2,CA_373,    case 0x7F:
2,CA_374,        j = 1;
2,CA_375,        break;
2,CA_376,    default:
2,CA_377,        return -1;
2,CA_378,    }
2,CA_379,    if ((min[i] & mask) != 0 || (max[i] & mask) != mask)
2,CA_380,        return -1;
2,CA_381,    else
2,CA_382,        return i * 8 + j;
2,CA_383,}
2,CA_384,
2,CA_385,/*
2,CA_386, * Construct a prefix.
2,CA_387, */
2,CA_388,static int make_addressPrefix(IPAddressOrRange **result,
2,CA_389,                              unsigned char *addr, const int prefixlen)
2,CA_390,{
2,CA_391,    int bytelen = (prefixlen + 7) / 8, bitlen = prefixlen % 8;
2,CA_392,    IPAddressOrRange *aor = IPAddressOrRange_new();
2,CA_393,
2,CA_394,    if (aor == NULL)
2,CA_395,        return 0;
2,CA_396,    aor->type = IPAddressOrRange_addressPrefix;
2,CA_397,    if (aor->u.addressPrefix == NULL &&
2,CA_398,        (aor->u.addressPrefix = ASN1_BIT_STRING_new()) == NULL)
2,CA_399,        goto err;
2,CA_400,    if (!ASN1_BIT_STRING_set(aor->u.addressPrefix, addr, bytelen))
2,CA_401,        goto err;
2,CA_402,    aor->u.addressPrefix->flags &= ~7;
2,CA_403,    aor->u.addressPrefix->flags |= ASN1_STRING_FLAG_BITS_LEFT;
2,CA_404,    if (bitlen > 0) {
2,CA_405,        aor->u.addressPrefix->data[bytelen - 1] &= ~(0xFF >> bitlen);
2,CA_406,        aor->u.addressPrefix->flags |= 8 - bitlen;
2,CA_407,    }
2,CA_408,
2,CA_409,    *result = aor;
2,CA_410,    return 1;
2,CA_411,
2,CA_412, err:
2,CA_413,    IPAddressOrRange_free(aor);
2,CA_414,    return 0;
2,CA_415,}
2,CA_416,
2,CA_417,/*
2,CA_418, * Construct a range.  If it can be expressed as a prefix,
2,CA_419, * return a prefix instead.  Doing this here simplifies
2,CA_420, * the rest of the code considerably.
2,CA_421, */
2,CA_422,static int make_addressRange(IPAddressOrRange **result,
2,CA_423,                             unsigned char *min,
2,CA_424,                             unsigned char *max, const int length)
2,CA_425,{
2,CA_426,    IPAddressOrRange *aor;
2,CA_427,    int i, prefixlen;
2,CA_428,
2,CA_429,    if ((prefixlen = range_should_be_prefix(min, max, length)) >= 0)
2,CA_430,        return make_addressPrefix(result, min, prefixlen);
2,CA_431,
2,CA_432,    if ((aor = IPAddressOrRange_new()) == NULL)
2,CA_433,        return 0;
2,CA_434,    aor->type = IPAddressOrRange_addressRange;
2,CA_435,    if ((aor->u.addressRange = IPAddressRange_new()) == NULL)
2,CA_436,        goto err;
2,CA_437,    if (aor->u.addressRange->min == NULL &&
2,CA_438,        (aor->u.addressRange->min = ASN1_BIT_STRING_new()) == NULL)
2,CA_439,        goto err;
2,CA_440,    if (aor->u.addressRange->max == NULL &&
2,CA_441,        (aor->u.addressRange->max = ASN1_BIT_STRING_new()) == NULL)
2,CA_442,        goto err;
2,CA_443,
2,CA_444,    for (i = length; i > 0 && min[i - 1] == 0x00; --i) ;
2,CA_445,    if (!ASN1_BIT_STRING_set(aor->u.addressRange->min, min, i))
2,CA_446,        goto err;
2,CA_447,    aor->u.addressRange->min->flags &= ~7;
2,CA_448,    aor->u.addressRange->min->flags |= ASN1_STRING_FLAG_BITS_LEFT;
2,CA_449,    if (i > 0) {
2,CA_450,        unsigned char b = min[i - 1];
2,CA_451,        int j = 1;
2,CA_452,        while ((b & (0xFFU >> j)) != 0)
2,CA_453,            ++j;
2,CA_454,        aor->u.addressRange->min->flags |= 8 - j;
2,CA_455,    }
2,CA_456,
2,CA_457,    for (i = length; i > 0 && max[i - 1] == 0xFF; --i) ;
2,CA_458,    if (!ASN1_BIT_STRING_set(aor->u.addressRange->max, max, i))
2,CA_459,        goto err;
2,CA_460,    aor->u.addressRange->max->flags &= ~7;
2,CA_461,    aor->u.addressRange->max->flags |= ASN1_STRING_FLAG_BITS_LEFT;
2,CA_462,    if (i > 0) {
2,CA_463,        unsigned char b = max[i - 1];
2,CA_464,        int j = 1;
2,CA_465,        while ((b & (0xFFU >> j)) != (0xFFU >> j))
2,CA_466,            ++j;
2,CA_467,        aor->u.addressRange->max->flags |= 8 - j;
2,CA_468,    }
2,CA_469,
2,CA_470,    *result = aor;
2,CA_471,    return 1;
2,CA_472,
2,CA_473, err:
2,CA_474,    IPAddressOrRange_free(aor);
2,CA_475,    return 0;
2,CA_476,}
2,CA_477,
2,CA_478,/*
2,CA_479, * Construct a new address family or find an existing one.
2,CA_480, */
2,CA_481,static IPAddressFamily *make_IPAddressFamily(IPAddrBlocks *addr,
2,CA_482,                                             const unsigned afi,
2,CA_483,                                             const unsigned *safi)
2,CA_484,{
2,CA_485,    IPAddressFamily *f;
2,CA_486,    unsigned char key[3];
2,CA_487,    int keylen;
2,CA_488,    int i;
2,CA_489,
2,CA_490,    key[0] = (afi >> 8) & 0xFF;
2,CA_491,    key[1] = afi & 0xFF;
2,CA_492,    if (safi != NULL) {
2,CA_493,        key[2] = *safi & 0xFF;
2,CA_494,        keylen = 3;
2,CA_495,    } else {
2,CA_496,        keylen = 2;
2,CA_497,    }
2,CA_498,
2,CA_499,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CA_500,        f = sk_IPAddressFamily_value(addr, i);
2,CA_501,        if (f->addressFamily->length == keylen &&
2,CA_502,            !memcmp(f->addressFamily->data, key, keylen))
2,CA_503,            return f;
2,CA_504,    }
2,CA_505,
2,CA_506,    if ((f = IPAddressFamily_new()) == NULL)
2,CA_507,        goto err;
2,CA_508,    if (f->ipAddressChoice == NULL &&
2,CA_509,        (f->ipAddressChoice = IPAddressChoice_new()) == NULL)
2,CA_510,        goto err;
2,CA_511,    if (f->addressFamily == NULL &&
2,CA_512,        (f->addressFamily = ASN1_OCTET_STRING_new()) == NULL)
2,CA_513,        goto err;
2,CA_514,    if (!ASN1_OCTET_STRING_set(f->addressFamily, key, keylen))
2,CA_515,        goto err;
2,CA_516,    if (!sk_IPAddressFamily_push(addr, f))
2,CA_517,        goto err;
2,CA_518,
2,CA_519,    return f;
2,CA_520,
2,CA_521, err:
2,CA_522,    IPAddressFamily_free(f);
2,CA_523,    return NULL;
2,CA_524,}
2,CA_525,
2,CA_526,/*
2,CA_527, * Add an inheritance element.
2,CA_528, */
2,CA_529,int X509v3_addr_add_inherit(IPAddrBlocks *addr,
2,CA_530,                            const unsigned afi, const unsigned *safi)
2,CA_531,{
2,CA_532,    IPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);
2,CA_533,    if (f == NULL ||
2,CA_534,        f->ipAddressChoice == NULL ||
2,CA_535,        (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&
2,CA_536,         f->ipAddressChoice->u.addressesOrRanges != NULL))
2,CA_537,        return 0;
2,CA_538,    if (f->ipAddressChoice->type == IPAddressChoice_inherit &&
2,CA_539,        f->ipAddressChoice->u.inherit != NULL)
2,CA_540,        return 1;
2,CA_541,    if (f->ipAddressChoice->u.inherit == NULL &&
2,CA_542,        (f->ipAddressChoice->u.inherit = ASN1_NULL_new()) == NULL)
2,CA_543,        return 0;
2,CA_544,    f->ipAddressChoice->type = IPAddressChoice_inherit;
2,CA_545,    return 1;
2,CA_546,}
2,CA_547,
2,CA_548,/*
2,CA_549, * Construct an IPAddressOrRange sequence, or return an existing one.
2,CA_550, */
2,CA_551,static IPAddressOrRanges *make_prefix_or_range(IPAddrBlocks *addr,
2,CA_552,                                               const unsigned afi,
2,CA_553,                                               const unsigned *safi)
2,CA_554,{
2,CA_555,    IPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);
2,CA_556,    IPAddressOrRanges *aors = NULL;
2,CA_557,
2,CA_558,    if (f == NULL ||
2,CA_559,        f->ipAddressChoice == NULL ||
2,CA_560,        (f->ipAddressChoice->type == IPAddressChoice_inherit &&
2,CA_561,         f->ipAddressChoice->u.inherit != NULL))
2,CA_562,        return NULL;
2,CA_563,    if (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges)
2,CA_564,        aors = f->ipAddressChoice->u.addressesOrRanges;
2,CA_565,    if (aors != NULL)
2,CA_566,        return aors;
2,CA_567,    if ((aors = sk_IPAddressOrRange_new_null()) == NULL)
2,CA_568,        return NULL;
2,CA_569,    switch (afi) {
2,CA_570,    case IANA_AFI_IPV4:
2,CA_571,        (void)sk_IPAddressOrRange_set_cmp_func(aors, v4IPAddressOrRange_cmp);
2,CA_572,        break;
2,CA_573,    case IANA_AFI_IPV6:
2,CA_574,        (void)sk_IPAddressOrRange_set_cmp_func(aors, v6IPAddressOrRange_cmp);
2,CA_575,        break;
2,CA_576,    }
2,CA_577,    f->ipAddressChoice->type = IPAddressChoice_addressesOrRanges;
2,CA_578,    f->ipAddressChoice->u.addressesOrRanges = aors;
2,CA_579,    return aors;
2,CA_580,}
2,CA_581,
2,CA_582,/*
2,CA_583, * Add a prefix.
2,CA_584, */
2,CA_585,int X509v3_addr_add_prefix(IPAddrBlocks *addr,
2,CA_586,                           const unsigned afi,
2,CA_587,                           const unsigned *safi,
2,CA_588,                           unsigned char *a, const int prefixlen)
2,CA_589,{
2,CA_590,    IPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);
2,CA_591,    IPAddressOrRange *aor;
2,CA_592,    if (aors == NULL || !make_addressPrefix(&aor, a, prefixlen))
2,CA_593,        return 0;
2,CA_594,    if (sk_IPAddressOrRange_push(aors, aor))
2,CA_595,        return 1;
2,CA_596,    IPAddressOrRange_free(aor);
2,CA_597,    return 0;
2,CA_598,}
2,CA_599,
2,CA_600,/*
2,CA_601, * Add a range.
2,CA_602, */
2,CA_603,int X509v3_addr_add_range(IPAddrBlocks *addr,
2,CA_604,                          const unsigned afi,
2,CA_605,                          const unsigned *safi,
2,CA_606,                          unsigned char *min, unsigned char *max)
2,CA_607,{
2,CA_608,    IPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);
2,CA_609,    IPAddressOrRange *aor;
2,CA_610,    int length = length_from_afi(afi);
2,CA_611,    if (aors == NULL)
2,CA_612,        return 0;
2,CA_613,    if (!make_addressRange(&aor, min, max, length))
2,CA_614,        return 0;
2,CA_615,    if (sk_IPAddressOrRange_push(aors, aor))
2,CA_616,        return 1;
2,CA_617,    IPAddressOrRange_free(aor);
2,CA_618,    return 0;
2,CA_619,}
2,CA_620,
2,CA_621,/*
2,CA_622, * Extract min and max values from an IPAddressOrRange.
2,CA_623, */
2,CA_624,static int extract_min_max(IPAddressOrRange *aor,
2,CA_625,                           unsigned char *min, unsigned char *max, int length)
2,CA_626,{
2,CA_627,    if (aor == NULL || min == NULL || max == NULL)
2,CA_628,        return 0;
2,CA_629,    switch (aor->type) {
2,CA_630,    case IPAddressOrRange_addressPrefix:
2,CA_631,        return (addr_expand(min, aor->u.addressPrefix, length, 0x00) &&
2,CA_632,                addr_expand(max, aor->u.addressPrefix, length, 0xFF));
2,CA_633,    case IPAddressOrRange_addressRange:
2,CA_634,        return (addr_expand(min, aor->u.addressRange->min, length, 0x00) &&
2,CA_635,                addr_expand(max, aor->u.addressRange->max, length, 0xFF));
2,CA_636,    }
2,CA_637,    return 0;
2,CA_638,}
2,CA_639,
2,CA_640,/*
2,CA_641, * Public wrapper for extract_min_max().
2,CA_642, */
2,CA_643,int X509v3_addr_get_range(IPAddressOrRange *aor,
2,CA_644,                          const unsigned afi,
2,CA_645,                          unsigned char *min,
2,CA_646,                          unsigned char *max, const int length)
2,CA_647,{
2,CA_648,    int afi_length = length_from_afi(afi);
2,CA_649,    if (aor == NULL || min == NULL || max == NULL ||
2,CA_650,        afi_length == 0 || length < afi_length ||
2,CA_651,        (aor->type != IPAddressOrRange_addressPrefix &&
2,CA_652,         aor->type != IPAddressOrRange_addressRange) ||
2,CA_653,        !extract_min_max(aor, min, max, afi_length))
2,CA_654,        return 0;
2,CA_655,
2,CA_656,    return afi_length;
2,CA_657,}
2,CA_658,
2,CA_659,/*
2,CA_660, * Sort comparison function for a sequence of IPAddressFamily.
2,CA_661, *
2,CA_662, * The last paragraph of RFC 3779 2.2.3.3 is slightly ambiguous about
2,CA_663, * the ordering: I can read it as meaning that IPv6 without a SAFI
2,CA_664, * comes before IPv4 with a SAFI, which seems pretty weird.  The
2,CA_665, * examples in appendix B suggest that the author intended the
2,CA_666, * null-SAFI rule to apply only within a single AFI, which is what I
2,CA_667, * would have expected and is what the following code implements.
2,CA_668, */
2,CA_669,static int IPAddressFamily_cmp(const IPAddressFamily *const *a_,
2,CA_670,                               const IPAddressFamily *const *b_)
2,CA_671,{
2,CA_672,    const ASN1_OCTET_STRING *a = (*a_)->addressFamily;
2,CA_673,    const ASN1_OCTET_STRING *b = (*b_)->addressFamily;
2,CA_674,    int len = ((a->length <= b->length) ? a->length : b->length);
2,CA_675,    int cmp = memcmp(a->data, b->data, len);
2,CA_676,    return cmp ? cmp : a->length - b->length;
2,CA_677,}
2,CA_678,
2,CA_679,/*
2,CA_680, * Check whether an IPAddrBLocks is in canonical form.
2,CA_681, */
2,CA_682,int X509v3_addr_is_canonical(IPAddrBlocks *addr)
2,CA_683,{
2,CA_684,    unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];
2,CA_685,    unsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];
2,CA_686,    IPAddressOrRanges *aors;
2,CA_687,    int i, j, k;
2,CA_688,
2,CA_689,    /*
2,CA_690,     * Empty extension is canonical.
2,CA_691,     */
2,CA_692,    if (addr == NULL)
2,CA_693,        return 1;
2,CA_694,
2,CA_695,    /*
2,CA_696,     * Check whether the top-level list is in order.
2,CA_697,     */
2,CA_698,    for (i = 0; i < sk_IPAddressFamily_num(addr) - 1; i++) {
2,CA_699,        const IPAddressFamily *a = sk_IPAddressFamily_value(addr, i);
2,CA_700,        const IPAddressFamily *b = sk_IPAddressFamily_value(addr, i + 1);
2,CA_701,        if (IPAddressFamily_cmp(&a, &b) >= 0)
2,CA_702,            return 0;
2,CA_703,    }
2,CA_704,
2,CA_705,    /*
2,CA_706,     * Top level's ok, now check each address family.
2,CA_707,     */
2,CA_708,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CA_709,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CA_710,        int length = length_from_afi(X509v3_addr_get_afi(f));
2,CA_711,
2,CA_712,        /*
2,CA_713,         * Inheritance is canonical.  Anything other than inheritance or
2,CA_714,         * a SEQUENCE OF IPAddressOrRange is an ASN.1 error or something.
2,CA_715,         */
2,CA_716,        if (f == NULL || f->ipAddressChoice == NULL)
2,CA_717,            return 0;
2,CA_718,        switch (f->ipAddressChoice->type) {
2,CA_719,        case IPAddressChoice_inherit:
2,CA_720,            continue;
2,CA_721,        case IPAddressChoice_addressesOrRanges:
2,CA_722,            break;
2,CA_723,        default:
2,CA_724,            return 0;
2,CA_725,        }
2,CA_726,
2,CA_727,        /*
2,CA_728,         * It's an IPAddressOrRanges sequence, check it.
2,CA_729,         */
2,CA_730,        aors = f->ipAddressChoice->u.addressesOrRanges;
2,CA_731,        if (sk_IPAddressOrRange_num(aors) == 0)
2,CA_732,            return 0;
2,CA_733,        for (j = 0; j < sk_IPAddressOrRange_num(aors) - 1; j++) {
2,CA_734,            IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);
2,CA_735,            IPAddressOrRange *b = sk_IPAddressOrRange_value(aors, j + 1);
2,CA_736,
2,CA_737,            if (!extract_min_max(a, a_min, a_max, length) ||
2,CA_738,                !extract_min_max(b, b_min, b_max, length))
2,CA_739,                return 0;
2,CA_740,
2,CA_741,            /*
2,CA_742,             * Punt misordered list, overlapping start, or inverted range.
2,CA_743,             */
2,CA_744,            if (memcmp(a_min, b_min, length) >= 0 ||
2,CA_745,                memcmp(a_min, a_max, length) > 0 ||
2,CA_746,                memcmp(b_min, b_max, length) > 0)
2,CA_747,                return 0;
2,CA_748,
2,CA_749,            /*
2,CA_750,             * Punt if adjacent or overlapping.  Check for adjacency by
2,CA_751,             * subtracting one from b_min first.
2,CA_752,             */
2,CA_753,            for (k = length - 1; k >= 0 && b_min[k]-- == 0x00; k--) ;
2,CA_754,            if (memcmp(a_max, b_min, length) >= 0)
2,CA_755,                return 0;
2,CA_756,
2,CA_757,            /*
2,CA_758,             * Check for range that should be expressed as a prefix.
2,CA_759,             */
2,CA_760,            if (a->type == IPAddressOrRange_addressRange &&
2,CA_761,                range_should_be_prefix(a_min, a_max, length) >= 0)
2,CA_762,                return 0;
2,CA_763,        }
2,CA_764,
2,CA_765,        /*
2,CA_766,         * Check range to see if it's inverted or should be a
2,CA_767,         * prefix.
2,CA_768,         */
2,CA_769,        j = sk_IPAddressOrRange_num(aors) - 1;
2,CA_770,        {
2,CA_771,            IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);
2,CA_772,            if (a != NULL && a->type == IPAddressOrRange_addressRange) {
2,CA_773,                if (!extract_min_max(a, a_min, a_max, length))
2,CA_774,                    return 0;
2,CA_775,                if (memcmp(a_min, a_max, length) > 0 ||
2,CA_776,                    range_should_be_prefix(a_min, a_max, length) >= 0)
2,CA_777,                    return 0;
2,CA_778,            }
2,CA_779,        }
2,CA_780,    }
2,CA_781,
2,CA_782,    /*
2,CA_783,     * If we made it through all that, we're happy.
2,CA_784,     */
2,CA_785,    return 1;
2,CA_786,}
2,CA_787,
2,CA_788,/*
2,CA_789, * Whack an IPAddressOrRanges into canonical form.
2,CA_790, */
2,CA_791,static int IPAddressOrRanges_canonize(IPAddressOrRanges *aors,
2,CA_792,                                      const unsigned afi)
2,CA_793,{
2,CA_794,    int i, j, length = length_from_afi(afi);
2,CA_795,
2,CA_796,    /*
2,CA_797,     * Sort the IPAddressOrRanges sequence.
2,CA_798,     */
2,CA_799,    sk_IPAddressOrRange_sort(aors);
2,CA_800,
2,CA_801,    /*
2,CA_802,     * Clean up representation issues, punt on duplicates or overlaps.
2,CA_803,     */
2,CA_804,    for (i = 0; i < sk_IPAddressOrRange_num(aors) - 1; i++) {
2,CA_805,        IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, i);
2,CA_806,        IPAddressOrRange *b = sk_IPAddressOrRange_value(aors, i + 1);
2,CA_807,        unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];
2,CA_808,        unsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];
2,CA_809,
2,CA_810,        if (!extract_min_max(a, a_min, a_max, length) ||
2,CA_811,            !extract_min_max(b, b_min, b_max, length))
2,CA_812,            return 0;
2,CA_813,
2,CA_814,        /*
2,CA_815,         * Punt inverted ranges.
2,CA_816,         */
2,CA_817,        if (memcmp(a_min, a_max, length) > 0 ||
2,CA_818,            memcmp(b_min, b_max, length) > 0)
2,CA_819,            return 0;
2,CA_820,
2,CA_821,        /*
2,CA_822,         * Punt overlaps.
2,CA_823,         */
2,CA_824,        if (memcmp(a_max, b_min, length) >= 0)
2,CA_825,            return 0;
2,CA_826,
2,CA_827,        /*
2,CA_828,         * Merge if a and b are adjacent.  We check for
2,CA_829,         * adjacency by subtracting one from b_min first.
2,CA_830,         */
2,CA_831,        for (j = length - 1; j >= 0 && b_min[j]-- == 0x00; j--) ;
2,CA_832,        if (memcmp(a_max, b_min, length) == 0) {
2,CA_833,            IPAddressOrRange *merged;
2,CA_834,            if (!make_addressRange(&merged, a_min, b_max, length))
2,CA_835,                return 0;
2,CA_836,            (void)sk_IPAddressOrRange_set(aors, i, merged);
2,CA_837,            (void)sk_IPAddressOrRange_delete(aors, i + 1);
2,CA_838,            IPAddressOrRange_free(a);
2,CA_839,            IPAddressOrRange_free(b);
2,CA_840,            --i;
2,CA_841,            continue;
2,CA_842,        }
2,CA_843,    }
2,CA_844,
2,CA_845,    /*
2,CA_846,     * Check for inverted final range.
2,CA_847,     */
2,CA_848,    j = sk_IPAddressOrRange_num(aors) - 1;
2,CA_849,    {
2,CA_850,        IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);
2,CA_851,        if (a != NULL && a->type == IPAddressOrRange_addressRange) {
2,CA_852,            unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];
2,CA_853,            if (!extract_min_max(a, a_min, a_max, length))
2,CA_854,                return 0;
2,CA_855,            if (memcmp(a_min, a_max, length) > 0)
2,CA_856,                return 0;
2,CA_857,        }
2,CA_858,    }
2,CA_859,
2,CA_860,    return 1;
2,CA_861,}
2,CA_862,
2,CA_863,/*
2,CA_864, * Whack an IPAddrBlocks extension into canonical form.
2,CA_865, */
2,CA_866,int X509v3_addr_canonize(IPAddrBlocks *addr)
2,CA_867,{
2,CA_868,    int i;
2,CA_869,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CA_870,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CA_871,        if (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&
2,CA_872,            !IPAddressOrRanges_canonize(f->ipAddressChoice->
2,CA_873,                                        u.addressesOrRanges,
2,CA_874,                                        X509v3_addr_get_afi(f)))
2,CA_875,            return 0;
2,CA_876,    }
2,CA_877,    (void)sk_IPAddressFamily_set_cmp_func(addr, IPAddressFamily_cmp);
2,CA_878,    sk_IPAddressFamily_sort(addr);
2,CA_879,    if (!ossl_assert(X509v3_addr_is_canonical(addr)))
2,CA_880,        return 0;
2,CA_881,    return 1;
2,CA_882,}
2,CA_883,
2,CA_884,/*
2,CA_885, * v2i handler for the IPAddrBlocks extension.
2,CA_886, */
2,CA_887,static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
2,CA_888,                              struct v3_ext_ctx *ctx,
2,CA_889,                              STACK_OF(CONF_VALUE) *values)
2,CA_890,{
2,CA_891,    static const char v4addr_chars[] = "0123456789.";
2,CA_892,    static const char v6addr_chars[] = "0123456789.:abcdefABCDEF";
2,CA_893,    IPAddrBlocks *addr = NULL;
2,CA_894,    char *s = NULL, *t;
2,CA_895,    int i;
2,CA_896,
2,CA_897,    if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) {
2,CA_898,        X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CA_899,        return NULL;
2,CA_900,    }
2,CA_901,
2,CA_902,    for (i = 0; i < sk_CONF_VALUE_num(values); i++) {
2,CA_903,        CONF_VALUE *val = sk_CONF_VALUE_value(values, i);
2,CA_904,        unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN];
2,CA_905,        unsigned afi, *safi = NULL, safi_;
2,CA_906,        const char *addr_chars = NULL;
2,CA_907,        int prefixlen, i1, i2, delim, length;
2,CA_908,
2,CA_909,        if (!name_cmp(val->name, "IPv4")) {
2,CA_910,            afi = IANA_AFI_IPV4;
2,CA_911,        } else if (!name_cmp(val->name, "IPv6")) {
2,CA_912,            afi = IANA_AFI_IPV6;
2,CA_913,        } else if (!name_cmp(val->name, "IPv4-SAFI")) {
2,CA_914,            afi = IANA_AFI_IPV4;
2,CA_915,            safi = &safi_;
2,CA_916,        } else if (!name_cmp(val->name, "IPv6-SAFI")) {
2,CA_917,            afi = IANA_AFI_IPV6;
2,CA_918,            safi = &safi_;
2,CA_919,        } else {
2,CA_920,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_921,                      X509V3_R_EXTENSION_NAME_ERROR);
2,CA_922,            X509V3_conf_err(val);
2,CA_923,            goto err;
2,CA_924,        }
2,CA_925,
2,CA_926,        switch (afi) {
2,CA_927,        case IANA_AFI_IPV4:
2,CA_928,            addr_chars = v4addr_chars;
2,CA_929,            break;
2,CA_930,        case IANA_AFI_IPV6:
2,CA_931,            addr_chars = v6addr_chars;
2,CA_932,            break;
2,CA_933,        }
2,CA_934,
2,CA_935,        length = length_from_afi(afi);
2,CA_936,
2,CA_937,        /*
2,CA_938,         * Handle SAFI, if any, and OPENSSL_strdup() so we can null-terminate
2,CA_939,         * the other input values.
2,CA_940,         */
2,CA_941,        if (safi != NULL) {
2,CA_942,            *safi = strtoul(val->value, &t, 0);
2,CA_943,            t += strspn(t, " 	");
2,CA_944,            if (*safi > 0xFF || *t++ != ':') {
2,CA_945,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI);
2,CA_946,                X509V3_conf_err(val);
2,CA_947,                goto err;
2,CA_948,            }
2,CA_949,            t += strspn(t, " 	");
2,CA_950,            s = OPENSSL_strdup(t);
2,CA_951,        } else {
2,CA_952,            s = OPENSSL_strdup(val->value);
2,CA_953,        }
2,CA_954,        if (s == NULL) {
2,CA_955,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CA_956,            goto err;
2,CA_957,        }
2,CA_958,
2,CA_959,        /*
2,CA_960,         * Check for inheritance.  Not worth additional complexity to
2,CA_961,         * optimize this (seldom-used) case.
2,CA_962,         */
2,CA_963,        if (strcmp(s, "inherit") == 0) {
2,CA_964,            if (!X509v3_addr_add_inherit(addr, afi, safi)) {
2,CA_965,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_966,                          X509V3_R_INVALID_INHERITANCE);
2,CA_967,                X509V3_conf_err(val);
2,CA_968,                goto err;
2,CA_969,            }
2,CA_970,            OPENSSL_free(s);
2,CA_971,            s = NULL;
2,CA_972,            continue;
2,CA_973,        }
2,CA_974,
2,CA_975,        i1 = strspn(s, addr_chars);
2,CA_976,        i2 = i1 + strspn(s + i1, " 	");
2,CA_977,        delim = s[i2++];
2,CA_978,        s[i1] = ' ';
2,CA_979,
2,CA_980,        if (a2i_ipadd(min, s) != length) {
2,CA_981,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS);
2,CA_982,            X509V3_conf_err(val);
2,CA_983,            goto err;
2,CA_984,        }
2,CA_985,
2,CA_986,        switch (delim) {
2,CA_987,        case '/':
2,CA_988,            prefixlen = (int)strtoul(s + i2, &t, 10);
2,CA_989,            if (t == s + i2 || *t != ' ') {
2,CA_990,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_991,                          X509V3_R_EXTENSION_VALUE_ERROR);
2,CA_992,                X509V3_conf_err(val);
2,CA_993,                goto err;
2,CA_994,            }
2,CA_995,            if (!X509v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) {
2,CA_996,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CA_997,                goto err;
2,CA_998,            }
2,CA_999,            break;
2,CA_1000,        case '-':
2,CA_1001,            i1 = i2 + strspn(s + i2, " 	");
2,CA_1002,            i2 = i1 + strspn(s + i1, addr_chars);
2,CA_1003,            if (i1 == i2 || s[i2] != ' ') {
2,CA_1004,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_1005,                          X509V3_R_EXTENSION_VALUE_ERROR);
2,CA_1006,                X509V3_conf_err(val);
2,CA_1007,                goto err;
2,CA_1008,            }
2,CA_1009,            if (a2i_ipadd(max, s + i1) != length) {
2,CA_1010,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_1011,                          X509V3_R_INVALID_IPADDRESS);
2,CA_1012,                X509V3_conf_err(val);
2,CA_1013,                goto err;
2,CA_1014,            }
2,CA_1015,            if (memcmp(min, max, length_from_afi(afi)) > 0) {
2,CA_1016,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_1017,                          X509V3_R_EXTENSION_VALUE_ERROR);
2,CA_1018,                X509V3_conf_err(val);
2,CA_1019,                goto err;
2,CA_1020,            }
2,CA_1021,            if (!X509v3_addr_add_range(addr, afi, safi, min, max)) {
2,CA_1022,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CA_1023,                goto err;
2,CA_1024,            }
2,CA_1025,            break;
2,CA_1026,        case ' ':
2,CA_1027,            if (!X509v3_addr_add_prefix(addr, afi, safi, min, length * 8)) {
2,CA_1028,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CA_1029,                goto err;
2,CA_1030,            }
2,CA_1031,            break;
2,CA_1032,        default:
2,CA_1033,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CA_1034,                      X509V3_R_EXTENSION_VALUE_ERROR);
2,CA_1035,            X509V3_conf_err(val);
2,CA_1036,            goto err;
2,CA_1037,        }
2,CA_1038,
2,CA_1039,        OPENSSL_free(s);
2,CA_1040,        s = NULL;
2,CA_1041,    }
2,CA_1042,
2,CA_1043,    /*
2,CA_1044,     * Canonize the result, then we're done.
2,CA_1045,     */
2,CA_1046,    if (!X509v3_addr_canonize(addr))
2,CA_1047,        goto err;
2,CA_1048,    return addr;
2,CA_1049,
2,CA_1050, err:
2,CA_1051,    OPENSSL_free(s);
2,CA_1052,    sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free);
2,CA_1053,    return NULL;
2,CA_1054,}
2,CA_1055,
2,CA_1056,/*
2,CA_1057, * OpenSSL dispatch
2,CA_1058, */
2,CA_1059,const X509V3_EXT_METHOD v3_addr = {
2,CA_1060,    NID_sbgp_ipAddrBlock,       /* nid */
2,CA_1061,    0,                          /* flags */
2,CA_1062,    ASN1_ITEM_ref(IPAddrBlocks), /* template */
2,CA_1063,    0, 0, 0, 0,                 /* old functions, ignored */
2,CA_1064,    0,                          /* i2s */
2,CA_1065,    0,                          /* s2i */
2,CA_1066,    0,                          /* i2v */
2,CA_1067,    v2i_IPAddrBlocks,           /* v2i */
2,CA_1068,    i2r_IPAddrBlocks,           /* i2r */
2,CA_1069,    0,                          /* r2i */
2,CA_1070,    NULL                        /* extension-specific data */
2,CA_1071,};
2,CA_1072,
2,CA_1073,/*
2,CA_1074, * Figure out whether extension sues inheritance.
2,CA_1075, */
2,CA_1076,int X509v3_addr_inherits(IPAddrBlocks *addr)
2,CA_1077,{
2,CA_1078,    int i;
2,CA_1079,    if (addr == NULL)
2,CA_1080,        return 0;
2,CA_1081,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CA_1082,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CA_1083,        if (f->ipAddressChoice->type == IPAddressChoice_inherit)
2,CA_1084,            return 1;
2,CA_1085,    }
2,CA_1086,    return 0;
2,CA_1087,}
2,CA_1088,
2,CA_1089,/*
2,CA_1090, * Figure out whether parent contains child.
2,CA_1091, */
2,CA_1092,static int addr_contains(IPAddressOrRanges *parent,
2,CA_1093,                         IPAddressOrRanges *child, int length)
2,CA_1094,{
2,CA_1095,    unsigned char p_min[ADDR_RAW_BUF_LEN], p_max[ADDR_RAW_BUF_LEN];
2,CA_1096,    unsigned char c_min[ADDR_RAW_BUF_LEN], c_max[ADDR_RAW_BUF_LEN];
2,CA_1097,    int p, c;
2,CA_1098,
2,CA_1099,    if (child == NULL || parent == child)
2,CA_1100,        return 1;
2,CA_1101,    if (parent == NULL)
2,CA_1102,        return 0;
2,CA_1103,
2,CA_1104,    p = 0;
2,CA_1105,    for (c = 0; c < sk_IPAddressOrRange_num(child); c++) {
2,CA_1106,        if (!extract_min_max(sk_IPAddressOrRange_value(child, c),
2,CA_1107,                             c_min, c_max, length))
2,CA_1108,            return -1;
2,CA_1109,        for (;; p++) {
2,CA_1110,            if (p >= sk_IPAddressOrRange_num(parent))
2,CA_1111,                return 0;
2,CA_1112,            if (!extract_min_max(sk_IPAddressOrRange_value(parent, p),
2,CA_1113,                                 p_min, p_max, length))
2,CA_1114,                return 0;
2,CA_1115,            if (memcmp(p_max, c_max, length) < 0)
2,CA_1116,                continue;
2,CA_1117,            if (memcmp(p_min, c_min, length) > 0)
2,CA_1118,                return 0;
2,CA_1119,            break;
2,CA_1120,        }
2,CA_1121,    }
2,CA_1122,
2,CA_1123,    return 1;
2,CA_1124,}
2,CA_1125,
2,CA_1126,/*
2,CA_1127, * Test whether a is a subset of b.
2,CA_1128, */
2,CA_1129,int X509v3_addr_subset(IPAddrBlocks *a, IPAddrBlocks *b)
2,CA_1130,{
2,CA_1131,    int i;
2,CA_1132,    if (a == NULL || a == b)
2,CA_1133,        return 1;
2,CA_1134,    if (b == NULL || X509v3_addr_inherits(a) || X509v3_addr_inherits(b))
2,CA_1135,        return 0;
2,CA_1136,    (void)sk_IPAddressFamily_set_cmp_func(b, IPAddressFamily_cmp);
2,CA_1137,    for (i = 0; i < sk_IPAddressFamily_num(a); i++) {
2,CA_1138,        IPAddressFamily *fa = sk_IPAddressFamily_value(a, i);
2,CA_1139,        int j = sk_IPAddressFamily_find(b, fa);
2,CA_1140,        IPAddressFamily *fb;
2,CA_1141,        fb = sk_IPAddressFamily_value(b, j);
2,CA_1142,        if (fb == NULL)
2,CA_1143,            return 0;
2,CA_1144,        if (!addr_contains(fb->ipAddressChoice->u.addressesOrRanges,
2,CA_1145,                           fa->ipAddressChoice->u.addressesOrRanges,
2,CA_1146,                           length_from_afi(X509v3_addr_get_afi(fb))))
2,CA_1147,            return 0;
2,CA_1148,    }
2,CA_1149,    return 1;
2,CA_1150,}
2,CA_1151,
2,CA_1152,/*
2,CA_1153, * Validation error handling via callback.
2,CA_1154, */
2,CA_1155,#define validation_err(_err_)             do {                                      if (ctx != NULL) {                        ctx->error = _err_;                     ctx->error_depth = i;                   ctx->current_cert = x;                  ret = ctx->verify_cb(0, ctx);         } else {                                  ret = 0;                              }                                       if (!ret)                                 goto done;                          } while (0)
2,CA_1156,
2,CA_1157,/*
2,CA_1158, * Core code for RFC 3779 2.3 path validation.
2,CA_1159, *
2,CA_1160, * Returns 1 for success, 0 on error.
2,CA_1161, *
2,CA_1162, * When returning 0, ctx->error MUST be set to an appropriate value other than
2,CA_1163, * X509_V_OK.
2,CA_1164, */
2,CA_1165,static int addr_validate_path_internal(X509_STORE_CTX *ctx,
2,CA_1166,                                       STACK_OF(X509) *chain,
2,CA_1167,                                       IPAddrBlocks *ext)
2,CA_1168,{
2,CA_1169,    IPAddrBlocks *child = NULL;
2,CA_1170,    int i, j, ret = 1;
2,CA_1171,    X509 *x;
2,CA_1172,
2,CA_1173,    if (!ossl_assert(chain != NULL && sk_X509_num(chain) > 0)
2,CA_1174,            || !ossl_assert(ctx != NULL || ext != NULL)
2,CA_1175,            || !ossl_assert(ctx == NULL || ctx->verify_cb != NULL)) {
2,CA_1176,        if (ctx != NULL)
2,CA_1177,            ctx->error = X509_V_ERR_UNSPECIFIED;
2,CA_1178,        return 0;
2,CA_1179,    }
2,CA_1180,
2,CA_1181,    /*
2,CA_1182,     * Figure out where to start.  If we don't have an extension to
2,CA_1183,     * check, we're done.  Otherwise, check canonical form and
2,CA_1184,     * set up for walking up the chain.
2,CA_1185,     */
2,CA_1186,    if (ext != NULL) {
2,CA_1187,        i = -1;
2,CA_1188,        x = NULL;
2,CA_1189,    } else {
2,CA_1190,        i = 0;
2,CA_1191,        x = sk_X509_value(chain, i);
2,CA_1192,        if ((ext = x->rfc3779_addr) == NULL)
2,CA_1193,            goto done;
2,CA_1194,    }
2,CA_1195,    if (!X509v3_addr_is_canonical(ext))
2,CA_1196,        validation_err(X509_V_ERR_INVALID_EXTENSION);
2,CA_1197,    (void)sk_IPAddressFamily_set_cmp_func(ext, IPAddressFamily_cmp);
2,CA_1198,    if ((child = sk_IPAddressFamily_dup(ext)) == NULL) {
2,CA_1199,        X509V3err(X509V3_F_ADDR_VALIDATE_PATH_INTERNAL,
2,CA_1200,                  ERR_R_MALLOC_FAILURE);
2,CA_1201,        if (ctx != NULL)
2,CA_1202,            ctx->error = X509_V_ERR_OUT_OF_MEM;
2,CA_1203,        ret = 0;
2,CA_1204,        goto done;
2,CA_1205,    }
2,CA_1206,
2,CA_1207,    /*
2,CA_1208,     * Now walk up the chain.  No cert may list resources that its
2,CA_1209,     * parent doesn't list.
2,CA_1210,     */
2,CA_1211,    for (i++; i < sk_X509_num(chain); i++) {
2,CA_1212,        x = sk_X509_value(chain, i);
2,CA_1213,        if (!X509v3_addr_is_canonical(x->rfc3779_addr))
2,CA_1214,            validation_err(X509_V_ERR_INVALID_EXTENSION);
2,CA_1215,        if (x->rfc3779_addr == NULL) {
2,CA_1216,            for (j = 0; j < sk_IPAddressFamily_num(child); j++) {
2,CA_1217,                IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);
2,CA_1218,                if (fc->ipAddressChoice->type != IPAddressChoice_inherit) {
2,CA_1219,                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CA_1220,                    break;
2,CA_1221,                }
2,CA_1222,            }
2,CA_1223,            continue;
2,CA_1224,        }
2,CA_1225,        (void)sk_IPAddressFamily_set_cmp_func(x->rfc3779_addr,
2,CA_1226,                                              IPAddressFamily_cmp);
2,CA_1227,        for (j = 0; j < sk_IPAddressFamily_num(child); j++) {
2,CA_1228,            IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);
2,CA_1229,            int k = sk_IPAddressFamily_find(x->rfc3779_addr, fc);
2,CA_1230,            IPAddressFamily *fp =
2,CA_1231,                sk_IPAddressFamily_value(x->rfc3779_addr, k);
2,CA_1232,            if (fp == NULL) {
2,CA_1233,                if (fc->ipAddressChoice->type ==
2,CA_1234,                    IPAddressChoice_addressesOrRanges) {
2,CA_1235,                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CA_1236,                    break;
2,CA_1237,                }
2,CA_1238,                continue;
2,CA_1239,            }
2,CA_1240,            if (fp->ipAddressChoice->type ==
2,CA_1241,                IPAddressChoice_addressesOrRanges) {
2,CA_1242,                if (fc->ipAddressChoice->type == IPAddressChoice_inherit
2,CA_1243,                    || addr_contains(fp->ipAddressChoice->u.addressesOrRanges,
2,CA_1244,                                     fc->ipAddressChoice->u.addressesOrRanges,
2,CA_1245,                                     length_from_afi(X509v3_addr_get_afi(fc))))
2,CA_1246,                    sk_IPAddressFamily_set(child, j, fp);
2,CA_1247,                else
2,CA_1248,                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CA_1249,            }
2,CA_1250,        }
2,CA_1251,    }
2,CA_1252,
2,CA_1253,    /*
2,CA_1254,     * Trust anchor can't inherit.
2,CA_1255,     */
2,CA_1256,    if (x->rfc3779_addr != NULL) {
2,CA_1257,        for (j = 0; j < sk_IPAddressFamily_num(x->rfc3779_addr); j++) {
2,CA_1258,            IPAddressFamily *fp =
2,CA_1259,                sk_IPAddressFamily_value(x->rfc3779_addr, j);
2,CA_1260,            if (fp->ipAddressChoice->type == IPAddressChoice_inherit
2,CA_1261,                && sk_IPAddressFamily_find(child, fp) >= 0)
2,CA_1262,                validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CA_1263,        }
2,CA_1264,    }
2,CA_1265,
2,CA_1266, done:
2,CA_1267,    sk_IPAddressFamily_free(child);
2,CA_1268,    return ret;
2,CA_1269,}
2,CA_1270,
2,CA_1271,#undef validation_err
2,CA_1272,
2,CA_1273,/*
2,CA_1274, * RFC 3779 2.3 path validation -- called from X509_verify_cert().
2,CA_1275, */
2,CA_1276,int X509v3_addr_validate_path(X509_STORE_CTX *ctx)
2,CA_1277,{
2,CA_1278,    if (ctx->chain == NULL
2,CA_1279,            || sk_X509_num(ctx->chain) == 0
2,CA_1280,            || ctx->verify_cb == NULL) {
2,CA_1281,        ctx->error = X509_V_ERR_UNSPECIFIED;
2,CA_1282,        return 0;
2,CA_1283,    }
2,CA_1284,    return addr_validate_path_internal(ctx, ctx->chain, NULL);
2,CA_1285,}
2,CA_1286,
2,CA_1287,/*
2,CA_1288, * RFC 3779 2.3 path validation of an extension.
2,CA_1289, * Test whether chain covers extension.
2,CA_1290, */
2,CA_1291,int X509v3_addr_validate_resource_set(STACK_OF(X509) *chain,
2,CA_1292,                                  IPAddrBlocks *ext, int allow_inheritance)
2,CA_1293,{
2,CA_1294,    if (ext == NULL)
2,CA_1295,        return 1;
2,CA_1296,    if (chain == NULL || sk_X509_num(chain) == 0)
2,CA_1297,        return 0;
2,CA_1298,    if (!allow_inheritance && X509v3_addr_inherits(ext))
2,CA_1299,        return 0;
2,CA_1300,    return addr_validate_path_internal(NULL, chain, ext);
2,CA_1301,}
2,CA_1302,
2,CA_1303,#endif                          /* OPENSSL_NO_RFC3779 */
2,CA_1304,
2,CB_1,/*
2,B_2, * Copyright 2006-2022 The OpenSSL Project Authors. All Rights Reserved.
2,CB_3, *
2,CB_4, * Licensed under the OpenSSL license (the "License").  You may not use
2,CB_5, * this file except in compliance with the License.  You can obtain a copy
2,CB_6, * in the file LICENSE in the source distribution or at
2,CB_7, * https://www.openssl.org/source/license.html
2,CB_8, */
2,CB_9,
2,CB_10,/*
2,CB_11, * Implementation of RFC 3779 section 2.2.
2,CB_12, */
2,CB_13,
2,CB_14,#include <stdio.h>
2,CB_15,#include <stdlib.h>
2,B_16,#include <assert.h>
2,B_17,#include <string.h>
2,CB_18,
2,CB_19,#include "internal/cryptlib.h"
2,CB_20,#include <openssl/conf.h>
2,CB_21,#include <openssl/asn1.h>
2,CB_22,#include <openssl/asn1t.h>
2,CB_23,#include <openssl/buffer.h>
2,CB_24,#include <openssl/x509v3.h>
2,CB_25,#include "crypto/x509.h"
2,CB_26,#include "ext_dat.h"
2,CB_27,
2,CB_28,#ifndef OPENSSL_NO_RFC3779
2,CB_29,
2,CB_30,/*
2,CB_31, * OpenSSL ASN.1 template translation of RFC 3779 2.2.3.
2,CB_32, */
2,CB_33,
2,CB_34,ASN1_SEQUENCE(IPAddressRange) = {
2,CB_35,  ASN1_SIMPLE(IPAddressRange, min, ASN1_BIT_STRING),
2,CB_36,  ASN1_SIMPLE(IPAddressRange, max, ASN1_BIT_STRING)
2,CB_37,} ASN1_SEQUENCE_END(IPAddressRange)
2,CB_38,
2,CB_39,ASN1_CHOICE(IPAddressOrRange) = {
2,CB_40,  ASN1_SIMPLE(IPAddressOrRange, u.addressPrefix, ASN1_BIT_STRING),
2,CB_41,  ASN1_SIMPLE(IPAddressOrRange, u.addressRange,  IPAddressRange)
2,CB_42,} ASN1_CHOICE_END(IPAddressOrRange)
2,CB_43,
2,CB_44,ASN1_CHOICE(IPAddressChoice) = {
2,CB_45,  ASN1_SIMPLE(IPAddressChoice,      u.inherit,           ASN1_NULL),
2,CB_46,  ASN1_SEQUENCE_OF(IPAddressChoice, u.addressesOrRanges, IPAddressOrRange)
2,CB_47,} ASN1_CHOICE_END(IPAddressChoice)
2,CB_48,
2,CB_49,ASN1_SEQUENCE(IPAddressFamily) = {
2,CB_50,  ASN1_SIMPLE(IPAddressFamily, addressFamily,   ASN1_OCTET_STRING),
2,CB_51,  ASN1_SIMPLE(IPAddressFamily, ipAddressChoice, IPAddressChoice)
2,CB_52,} ASN1_SEQUENCE_END(IPAddressFamily)
2,CB_53,
2,CB_54,ASN1_ITEM_TEMPLATE(IPAddrBlocks) =
2,CB_55,  ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0,
2,CB_56,                        IPAddrBlocks, IPAddressFamily)
2,CB_57,static_ASN1_ITEM_TEMPLATE_END(IPAddrBlocks)
2,CB_58,
2,CB_59,IMPLEMENT_ASN1_FUNCTIONS(IPAddressRange)
2,CB_60,IMPLEMENT_ASN1_FUNCTIONS(IPAddressOrRange)
2,CB_61,IMPLEMENT_ASN1_FUNCTIONS(IPAddressChoice)
2,CB_62,IMPLEMENT_ASN1_FUNCTIONS(IPAddressFamily)
2,CB_63,
2,CB_64,/*
2,CB_65, * How much buffer space do we need for a raw address?
2,CB_66, */
2,CB_67,#define ADDR_RAW_BUF_LEN        16
2,CB_68,
2,CB_69,/*
2,CB_70, * What's the address length associated with this AFI?
2,CB_71, */
2,CB_72,static int length_from_afi(const unsigned afi)
2,CB_73,{
2,CB_74,    switch (afi) {
2,CB_75,    case IANA_AFI_IPV4:
2,CB_76,        return 4;
2,CB_77,    case IANA_AFI_IPV6:
2,CB_78,        return 16;
2,CB_79,    default:
2,CB_80,        return 0;
2,CB_81,    }
2,CB_82,}
2,CB_83,
2,CB_84,/*
2,CB_85, * Extract the AFI from an IPAddressFamily.
2,CB_86, */
2,CB_87,unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)
2,CB_88,{
2,CB_89,    if (f == NULL
2,CB_90,            || f->addressFamily == NULL
2,CB_91,            || f->addressFamily->data == NULL
2,CB_92,            || f->addressFamily->length < 2)
2,CB_93,        return 0;
2,CB_94,    return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1];
2,CB_95,}
2,CB_96,
2,CB_97,/*
2,CB_98, * Expand the bitstring form of an address into a raw byte array.
2,CB_99, * At the moment this is coded for simplicity, not speed.
2,CB_100, */
2,CB_101,static int addr_expand(unsigned char *addr,
2,CB_102,                       const ASN1_BIT_STRING *bs,
2,CB_103,                       const int length, const unsigned char fill)
2,CB_104,{
2,CB_105,    if (bs->length < 0 || bs->length > length)
2,CB_106,        return 0;
2,CB_107,    if (bs->length > 0) {
2,CB_108,        memcpy(addr, bs->data, bs->length);
2,CB_109,        if ((bs->flags & 7) != 0) {
2,CB_110,            unsigned char mask = 0xFF >> (8 - (bs->flags & 7));
2,CB_111,            if (fill == 0)
2,CB_112,                addr[bs->length - 1] &= ~mask;
2,CB_113,            else
2,CB_114,                addr[bs->length - 1] |= mask;
2,CB_115,        }
2,CB_116,    }
2,CB_117,    memset(addr + bs->length, fill, length - bs->length);
2,CB_118,    return 1;
2,CB_119,}
2,CB_120,
2,CB_121,/*
2,CB_122, * Extract the prefix length from a bitstring.
2,CB_123, */
2,CB_124,#define addr_prefixlen(bs) ((int) ((bs)->length * 8 - ((bs)->flags & 7)))
2,CB_125,
2,CB_126,/*
2,CB_127, * i2r handler for one address bitstring.
2,CB_128, */
2,CB_129,static int i2r_address(BIO *out,
2,CB_130,                       const unsigned afi,
2,CB_131,                       const unsigned char fill, const ASN1_BIT_STRING *bs)
2,CB_132,{
2,CB_133,    unsigned char addr[ADDR_RAW_BUF_LEN];
2,CB_134,    int i, n;
2,CB_135,
2,CB_136,    if (bs->length < 0)
2,CB_137,        return 0;
2,CB_138,    switch (afi) {
2,CB_139,    case IANA_AFI_IPV4:
2,CB_140,        if (!addr_expand(addr, bs, 4, fill))
2,CB_141,            return 0;
2,CB_142,        BIO_printf(out, "%d.%d.%d.%d", addr[0], addr[1], addr[2], addr[3]);
2,CB_143,        break;
2,CB_144,    case IANA_AFI_IPV6:
2,CB_145,        if (!addr_expand(addr, bs, 16, fill))
2,CB_146,            return 0;
2,CB_147,        for (n = 16; n > 1 && addr[n - 1] == 0x00 && addr[n - 2] == 0x00;
2,CB_148,             n -= 2) ;
2,CB_149,        for (i = 0; i < n; i += 2)
2,CB_150,            BIO_printf(out, "%x%s", (addr[i] << 8) | addr[i + 1],
2,CB_151,                       (i < 14 ? ":" : ""));
2,CB_152,        if (i < 16)
2,CB_153,            BIO_puts(out, ":");
2,CB_154,        if (i == 0)
2,CB_155,            BIO_puts(out, ":");
2,CB_156,        break;
2,CB_157,    default:
2,CB_158,        for (i = 0; i < bs->length; i++)
2,CB_159,            BIO_printf(out, "%s%02x", (i > 0 ? ":" : ""), bs->data[i]);
2,CB_160,        BIO_printf(out, "[%d]", (int)(bs->flags & 7));
2,CB_161,        break;
2,CB_162,    }
2,CB_163,    return 1;
2,CB_164,}
2,CB_165,
2,CB_166,/*
2,CB_167, * i2r handler for a sequence of addresses and ranges.
2,CB_168, */
2,CB_169,static int i2r_IPAddressOrRanges(BIO *out,
2,CB_170,                                 const int indent,
2,CB_171,                                 const IPAddressOrRanges *aors,
2,CB_172,                                 const unsigned afi)
2,CB_173,{
2,CB_174,    int i;
2,CB_175,    for (i = 0; i < sk_IPAddressOrRange_num(aors); i++) {
2,CB_176,        const IPAddressOrRange *aor = sk_IPAddressOrRange_value(aors, i);
2,CB_177,        BIO_printf(out, "%*s", indent, "");
2,CB_178,        switch (aor->type) {
2,CB_179,        case IPAddressOrRange_addressPrefix:
2,CB_180,            if (!i2r_address(out, afi, 0x00, aor->u.addressPrefix))
2,CB_181,                return 0;
2,CB_182,            BIO_printf(out, "/%d
2,CB_183,", addr_prefixlen(aor->u.addressPrefix));
2,CB_184,            continue;
2,CB_185,        case IPAddressOrRange_addressRange:
2,CB_186,            if (!i2r_address(out, afi, 0x00, aor->u.addressRange->min))
2,CB_187,                return 0;
2,CB_188,            BIO_puts(out, "-");
2,CB_189,            if (!i2r_address(out, afi, 0xFF, aor->u.addressRange->max))
2,CB_190,                return 0;
2,CB_191,            BIO_puts(out, "
2,CB_192,");
2,CB_193,            continue;
2,CB_194,        }
2,CB_195,    }
2,CB_196,    return 1;
2,CB_197,}
2,CB_198,
2,CB_199,/*
2,CB_200, * i2r handler for an IPAddrBlocks extension.
2,CB_201, */
2,CB_202,static int i2r_IPAddrBlocks(const X509V3_EXT_METHOD *method,
2,CB_203,                            void *ext, BIO *out, int indent)
2,CB_204,{
2,CB_205,    const IPAddrBlocks *addr = ext;
2,CB_206,    int i;
2,CB_207,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CB_208,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CB_209,        const unsigned int afi = X509v3_addr_get_afi(f);
2,CB_210,        switch (afi) {
2,CB_211,        case IANA_AFI_IPV4:
2,CB_212,            BIO_printf(out, "%*sIPv4", indent, "");
2,CB_213,            break;
2,CB_214,        case IANA_AFI_IPV6:
2,CB_215,            BIO_printf(out, "%*sIPv6", indent, "");
2,CB_216,            break;
2,CB_217,        default:
2,CB_218,            BIO_printf(out, "%*sUnknown AFI %u", indent, "", afi);
2,CB_219,            break;
2,CB_220,        }
2,CB_221,        if (f->addressFamily->length > 2) {
2,CB_222,            switch (f->addressFamily->data[2]) {
2,CB_223,            case 1:
2,CB_224,                BIO_puts(out, " (Unicast)");
2,CB_225,                break;
2,CB_226,            case 2:
2,CB_227,                BIO_puts(out, " (Multicast)");
2,CB_228,                break;
2,CB_229,            case 3:
2,CB_230,                BIO_puts(out, " (Unicast/Multicast)");
2,CB_231,                break;
2,CB_232,            case 4:
2,CB_233,                BIO_puts(out, " (MPLS)");
2,CB_234,                break;
2,CB_235,            case 64:
2,CB_236,                BIO_puts(out, " (Tunnel)");
2,CB_237,                break;
2,CB_238,            case 65:
2,CB_239,                BIO_puts(out, " (VPLS)");
2,CB_240,                break;
2,CB_241,            case 66:
2,CB_242,                BIO_puts(out, " (BGP MDT)");
2,CB_243,                break;
2,CB_244,            case 128:
2,CB_245,                BIO_puts(out, " (MPLS-labeled VPN)");
2,CB_246,                break;
2,CB_247,            default:
2,CB_248,                BIO_printf(out, " (Unknown SAFI %u)",
2,CB_249,                           (unsigned)f->addressFamily->data[2]);
2,CB_250,                break;
2,CB_251,            }
2,CB_252,        }
2,CB_253,        switch (f->ipAddressChoice->type) {
2,CB_254,        case IPAddressChoice_inherit:
2,CB_255,            BIO_puts(out, ": inherit
2,CB_256,");
2,CB_257,            break;
2,CB_258,        case IPAddressChoice_addressesOrRanges:
2,CB_259,            BIO_puts(out, ":
2,CB_260,");
2,CB_261,            if (!i2r_IPAddressOrRanges(out,
2,CB_262,                                       indent + 2,
2,CB_263,                                       f->ipAddressChoice->
2,CB_264,                                       u.addressesOrRanges, afi))
2,CB_265,                return 0;
2,CB_266,            break;
2,CB_267,        }
2,CB_268,    }
2,CB_269,    return 1;
2,CB_270,}
2,CB_271,
2,CB_272,/*
2,CB_273, * Sort comparison function for a sequence of IPAddressOrRange
2,CB_274, * elements.
2,CB_275, *
2,CB_276, * There's no sane answer we can give if addr_expand() fails, and an
2,CB_277, * assertion failure on externally supplied data is seriously uncool,
2,CB_278, * so we just arbitrarily declare that if given invalid inputs this
2,CB_279, * function returns -1.  If this messes up your preferred sort order
2,CB_280, * for garbage input, tough noogies.
2,CB_281, */
2,CB_282,static int IPAddressOrRange_cmp(const IPAddressOrRange *a,
2,CB_283,                                const IPAddressOrRange *b, const int length)
2,CB_284,{
2,CB_285,    unsigned char addr_a[ADDR_RAW_BUF_LEN], addr_b[ADDR_RAW_BUF_LEN];
2,CB_286,    int prefixlen_a = 0, prefixlen_b = 0;
2,CB_287,    int r;
2,CB_288,
2,CB_289,    switch (a->type) {
2,CB_290,    case IPAddressOrRange_addressPrefix:
2,CB_291,        if (!addr_expand(addr_a, a->u.addressPrefix, length, 0x00))
2,CB_292,            return -1;
2,CB_293,        prefixlen_a = addr_prefixlen(a->u.addressPrefix);
2,CB_294,        break;
2,CB_295,    case IPAddressOrRange_addressRange:
2,CB_296,        if (!addr_expand(addr_a, a->u.addressRange->min, length, 0x00))
2,CB_297,            return -1;
2,CB_298,        prefixlen_a = length * 8;
2,CB_299,        break;
2,CB_300,    }
2,CB_301,
2,CB_302,    switch (b->type) {
2,CB_303,    case IPAddressOrRange_addressPrefix:
2,CB_304,        if (!addr_expand(addr_b, b->u.addressPrefix, length, 0x00))
2,CB_305,            return -1;
2,CB_306,        prefixlen_b = addr_prefixlen(b->u.addressPrefix);
2,CB_307,        break;
2,CB_308,    case IPAddressOrRange_addressRange:
2,CB_309,        if (!addr_expand(addr_b, b->u.addressRange->min, length, 0x00))
2,CB_310,            return -1;
2,CB_311,        prefixlen_b = length * 8;
2,CB_312,        break;
2,CB_313,    }
2,CB_314,
2,CB_315,    if ((r = memcmp(addr_a, addr_b, length)) != 0)
2,CB_316,        return r;
2,CB_317,    else
2,CB_318,        return prefixlen_a - prefixlen_b;
2,CB_319,}
2,CB_320,
2,CB_321,/*
2,CB_322, * IPv4-specific closure over IPAddressOrRange_cmp, since sk_sort()
2,CB_323, * comparison routines are only allowed two arguments.
2,CB_324, */
2,CB_325,static int v4IPAddressOrRange_cmp(const IPAddressOrRange *const *a,
2,CB_326,                                  const IPAddressOrRange *const *b)
2,CB_327,{
2,CB_328,    return IPAddressOrRange_cmp(*a, *b, 4);
2,CB_329,}
2,CB_330,
2,CB_331,/*
2,CB_332, * IPv6-specific closure over IPAddressOrRange_cmp, since sk_sort()
2,CB_333, * comparison routines are only allowed two arguments.
2,CB_334, */
2,CB_335,static int v6IPAddressOrRange_cmp(const IPAddressOrRange *const *a,
2,CB_336,                                  const IPAddressOrRange *const *b)
2,CB_337,{
2,CB_338,    return IPAddressOrRange_cmp(*a, *b, 16);
2,CB_339,}
2,CB_340,
2,CB_341,static int range_should_be_prefix(const unsigned char *min,
2,CB_342,                                  const unsigned char *max, const int length)
2,CB_343,{
2,CB_344,    unsigned char mask;
2,CB_345,    int i, j;
2,CB_346,
2,B_347,    /*
2,B_348,     * It is the responsibility of the caller to confirm min <= max. We don't
2,B_349,     * use ossl_assert() here since we have no way of signalling an error from
2,B_350,     * this function - so we just use a plain assert instead.
2,B_351,     */
2,B_352,    assert(memcmp(min, max, length) <= 0);
2,B_353,
2,CB_354,    for (i = 0; i < length && min[i] == max[i]; i++) ;
2,CB_355,    for (j = length - 1; j >= 0 && min[j] == 0x00 && max[j] == 0xFF; j--) ;
2,CB_356,    if (i < j)
2,CB_357,        return -1;
2,CB_358,    if (i > j)
2,CB_359,        return i * 8;
2,CB_360,    mask = min[i] ^ max[i];
2,CB_361,    switch (mask) {
2,CB_362,    case 0x01:
2,CB_363,        j = 7;
2,CB_364,        break;
2,CB_365,    case 0x03:
2,CB_366,        j = 6;
2,CB_367,        break;
2,CB_368,    case 0x07:
2,CB_369,        j = 5;
2,CB_370,        break;
2,CB_371,    case 0x0F:
2,CB_372,        j = 4;
2,CB_373,        break;
2,CB_374,    case 0x1F:
2,CB_375,        j = 3;
2,CB_376,        break;
2,CB_377,    case 0x3F:
2,CB_378,        j = 2;
2,CB_379,        break;
2,CB_380,    case 0x7F:
2,CB_381,        j = 1;
2,CB_382,        break;
2,CB_383,    default:
2,CB_384,        return -1;
2,CB_385,    }
2,CB_386,    if ((min[i] & mask) != 0 || (max[i] & mask) != mask)
2,CB_387,        return -1;
2,CB_388,    else
2,CB_389,        return i * 8 + j;
2,CB_390,}
2,CB_391,
2,CB_392,/*
2,CB_393, * Construct a prefix.
2,CB_394, */
2,CB_395,static int make_addressPrefix(IPAddressOrRange **result,
2,CB_396,                              unsigned char *addr, const int prefixlen)
2,CB_397,{
2,CB_398,    int bytelen = (prefixlen + 7) / 8, bitlen = prefixlen % 8;
2,CB_399,    IPAddressOrRange *aor = IPAddressOrRange_new();
2,CB_400,
2,CB_401,    if (aor == NULL)
2,CB_402,        return 0;
2,CB_403,    aor->type = IPAddressOrRange_addressPrefix;
2,CB_404,    if (aor->u.addressPrefix == NULL &&
2,CB_405,        (aor->u.addressPrefix = ASN1_BIT_STRING_new()) == NULL)
2,CB_406,        goto err;
2,CB_407,    if (!ASN1_BIT_STRING_set(aor->u.addressPrefix, addr, bytelen))
2,CB_408,        goto err;
2,CB_409,    aor->u.addressPrefix->flags &= ~7;
2,CB_410,    aor->u.addressPrefix->flags |= ASN1_STRING_FLAG_BITS_LEFT;
2,CB_411,    if (bitlen > 0) {
2,CB_412,        aor->u.addressPrefix->data[bytelen - 1] &= ~(0xFF >> bitlen);
2,CB_413,        aor->u.addressPrefix->flags |= 8 - bitlen;
2,CB_414,    }
2,CB_415,
2,CB_416,    *result = aor;
2,CB_417,    return 1;
2,CB_418,
2,CB_419, err:
2,CB_420,    IPAddressOrRange_free(aor);
2,CB_421,    return 0;
2,CB_422,}
2,CB_423,
2,CB_424,/*
2,CB_425, * Construct a range.  If it can be expressed as a prefix,
2,CB_426, * return a prefix instead.  Doing this here simplifies
2,CB_427, * the rest of the code considerably.
2,CB_428, */
2,CB_429,static int make_addressRange(IPAddressOrRange **result,
2,CB_430,                             unsigned char *min,
2,CB_431,                             unsigned char *max, const int length)
2,CB_432,{
2,CB_433,    IPAddressOrRange *aor;
2,CB_434,    int i, prefixlen;
2,CB_435,
2,B_436,    if (memcmp(min, max, length) > 0)
2,B_437,        return 0;
2,B_438,
2,CB_439,    if ((prefixlen = range_should_be_prefix(min, max, length)) >= 0)
2,CB_440,        return make_addressPrefix(result, min, prefixlen);
2,CB_441,
2,CB_442,    if ((aor = IPAddressOrRange_new()) == NULL)
2,CB_443,        return 0;
2,CB_444,    aor->type = IPAddressOrRange_addressRange;
2,CB_445,    if ((aor->u.addressRange = IPAddressRange_new()) == NULL)
2,CB_446,        goto err;
2,CB_447,    if (aor->u.addressRange->min == NULL &&
2,CB_448,        (aor->u.addressRange->min = ASN1_BIT_STRING_new()) == NULL)
2,CB_449,        goto err;
2,CB_450,    if (aor->u.addressRange->max == NULL &&
2,CB_451,        (aor->u.addressRange->max = ASN1_BIT_STRING_new()) == NULL)
2,CB_452,        goto err;
2,CB_453,
2,CB_454,    for (i = length; i > 0 && min[i - 1] == 0x00; --i) ;
2,CB_455,    if (!ASN1_BIT_STRING_set(aor->u.addressRange->min, min, i))
2,CB_456,        goto err;
2,CB_457,    aor->u.addressRange->min->flags &= ~7;
2,CB_458,    aor->u.addressRange->min->flags |= ASN1_STRING_FLAG_BITS_LEFT;
2,CB_459,    if (i > 0) {
2,CB_460,        unsigned char b = min[i - 1];
2,CB_461,        int j = 1;
2,CB_462,        while ((b & (0xFFU >> j)) != 0)
2,CB_463,            ++j;
2,CB_464,        aor->u.addressRange->min->flags |= 8 - j;
2,CB_465,    }
2,CB_466,
2,CB_467,    for (i = length; i > 0 && max[i - 1] == 0xFF; --i) ;
2,CB_468,    if (!ASN1_BIT_STRING_set(aor->u.addressRange->max, max, i))
2,CB_469,        goto err;
2,CB_470,    aor->u.addressRange->max->flags &= ~7;
2,CB_471,    aor->u.addressRange->max->flags |= ASN1_STRING_FLAG_BITS_LEFT;
2,CB_472,    if (i > 0) {
2,CB_473,        unsigned char b = max[i - 1];
2,CB_474,        int j = 1;
2,CB_475,        while ((b & (0xFFU >> j)) != (0xFFU >> j))
2,CB_476,            ++j;
2,CB_477,        aor->u.addressRange->max->flags |= 8 - j;
2,CB_478,    }
2,CB_479,
2,CB_480,    *result = aor;
2,CB_481,    return 1;
2,CB_482,
2,CB_483, err:
2,CB_484,    IPAddressOrRange_free(aor);
2,CB_485,    return 0;
2,CB_486,}
2,CB_487,
2,CB_488,/*
2,CB_489, * Construct a new address family or find an existing one.
2,CB_490, */
2,CB_491,static IPAddressFamily *make_IPAddressFamily(IPAddrBlocks *addr,
2,CB_492,                                             const unsigned afi,
2,CB_493,                                             const unsigned *safi)
2,CB_494,{
2,CB_495,    IPAddressFamily *f;
2,CB_496,    unsigned char key[3];
2,CB_497,    int keylen;
2,CB_498,    int i;
2,CB_499,
2,CB_500,    key[0] = (afi >> 8) & 0xFF;
2,CB_501,    key[1] = afi & 0xFF;
2,CB_502,    if (safi != NULL) {
2,CB_503,        key[2] = *safi & 0xFF;
2,CB_504,        keylen = 3;
2,CB_505,    } else {
2,CB_506,        keylen = 2;
2,CB_507,    }
2,CB_508,
2,CB_509,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CB_510,        f = sk_IPAddressFamily_value(addr, i);
2,CB_511,        if (f->addressFamily->length == keylen &&
2,CB_512,            !memcmp(f->addressFamily->data, key, keylen))
2,CB_513,            return f;
2,CB_514,    }
2,CB_515,
2,CB_516,    if ((f = IPAddressFamily_new()) == NULL)
2,CB_517,        goto err;
2,CB_518,    if (f->ipAddressChoice == NULL &&
2,CB_519,        (f->ipAddressChoice = IPAddressChoice_new()) == NULL)
2,CB_520,        goto err;
2,CB_521,    if (f->addressFamily == NULL &&
2,CB_522,        (f->addressFamily = ASN1_OCTET_STRING_new()) == NULL)
2,CB_523,        goto err;
2,CB_524,    if (!ASN1_OCTET_STRING_set(f->addressFamily, key, keylen))
2,CB_525,        goto err;
2,CB_526,    if (!sk_IPAddressFamily_push(addr, f))
2,CB_527,        goto err;
2,CB_528,
2,CB_529,    return f;
2,CB_530,
2,CB_531, err:
2,CB_532,    IPAddressFamily_free(f);
2,CB_533,    return NULL;
2,CB_534,}
2,CB_535,
2,CB_536,/*
2,CB_537, * Add an inheritance element.
2,CB_538, */
2,CB_539,int X509v3_addr_add_inherit(IPAddrBlocks *addr,
2,CB_540,                            const unsigned afi, const unsigned *safi)
2,CB_541,{
2,CB_542,    IPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);
2,CB_543,    if (f == NULL ||
2,CB_544,        f->ipAddressChoice == NULL ||
2,CB_545,        (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&
2,CB_546,         f->ipAddressChoice->u.addressesOrRanges != NULL))
2,CB_547,        return 0;
2,CB_548,    if (f->ipAddressChoice->type == IPAddressChoice_inherit &&
2,CB_549,        f->ipAddressChoice->u.inherit != NULL)
2,CB_550,        return 1;
2,CB_551,    if (f->ipAddressChoice->u.inherit == NULL &&
2,CB_552,        (f->ipAddressChoice->u.inherit = ASN1_NULL_new()) == NULL)
2,CB_553,        return 0;
2,CB_554,    f->ipAddressChoice->type = IPAddressChoice_inherit;
2,CB_555,    return 1;
2,CB_556,}
2,CB_557,
2,CB_558,/*
2,CB_559, * Construct an IPAddressOrRange sequence, or return an existing one.
2,CB_560, */
2,CB_561,static IPAddressOrRanges *make_prefix_or_range(IPAddrBlocks *addr,
2,CB_562,                                               const unsigned afi,
2,CB_563,                                               const unsigned *safi)
2,CB_564,{
2,CB_565,    IPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);
2,CB_566,    IPAddressOrRanges *aors = NULL;
2,CB_567,
2,CB_568,    if (f == NULL ||
2,CB_569,        f->ipAddressChoice == NULL ||
2,CB_570,        (f->ipAddressChoice->type == IPAddressChoice_inherit &&
2,CB_571,         f->ipAddressChoice->u.inherit != NULL))
2,CB_572,        return NULL;
2,CB_573,    if (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges)
2,CB_574,        aors = f->ipAddressChoice->u.addressesOrRanges;
2,CB_575,    if (aors != NULL)
2,CB_576,        return aors;
2,CB_577,    if ((aors = sk_IPAddressOrRange_new_null()) == NULL)
2,CB_578,        return NULL;
2,CB_579,    switch (afi) {
2,CB_580,    case IANA_AFI_IPV4:
2,CB_581,        (void)sk_IPAddressOrRange_set_cmp_func(aors, v4IPAddressOrRange_cmp);
2,CB_582,        break;
2,CB_583,    case IANA_AFI_IPV6:
2,CB_584,        (void)sk_IPAddressOrRange_set_cmp_func(aors, v6IPAddressOrRange_cmp);
2,CB_585,        break;
2,CB_586,    }
2,CB_587,    f->ipAddressChoice->type = IPAddressChoice_addressesOrRanges;
2,CB_588,    f->ipAddressChoice->u.addressesOrRanges = aors;
2,CB_589,    return aors;
2,CB_590,}
2,CB_591,
2,CB_592,/*
2,CB_593, * Add a prefix.
2,CB_594, */
2,CB_595,int X509v3_addr_add_prefix(IPAddrBlocks *addr,
2,CB_596,                           const unsigned afi,
2,CB_597,                           const unsigned *safi,
2,CB_598,                           unsigned char *a, const int prefixlen)
2,CB_599,{
2,CB_600,    IPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);
2,CB_601,    IPAddressOrRange *aor;
2,CB_602,    if (aors == NULL || !make_addressPrefix(&aor, a, prefixlen))
2,CB_603,        return 0;
2,CB_604,    if (sk_IPAddressOrRange_push(aors, aor))
2,CB_605,        return 1;
2,CB_606,    IPAddressOrRange_free(aor);
2,CB_607,    return 0;
2,CB_608,}
2,CB_609,
2,CB_610,/*
2,CB_611, * Add a range.
2,CB_612, */
2,CB_613,int X509v3_addr_add_range(IPAddrBlocks *addr,
2,CB_614,                          const unsigned afi,
2,CB_615,                          const unsigned *safi,
2,CB_616,                          unsigned char *min, unsigned char *max)
2,CB_617,{
2,CB_618,    IPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);
2,CB_619,    IPAddressOrRange *aor;
2,CB_620,    int length = length_from_afi(afi);
2,CB_621,    if (aors == NULL)
2,CB_622,        return 0;
2,CB_623,    if (!make_addressRange(&aor, min, max, length))
2,CB_624,        return 0;
2,CB_625,    if (sk_IPAddressOrRange_push(aors, aor))
2,CB_626,        return 1;
2,CB_627,    IPAddressOrRange_free(aor);
2,CB_628,    return 0;
2,CB_629,}
2,CB_630,
2,CB_631,/*
2,CB_632, * Extract min and max values from an IPAddressOrRange.
2,CB_633, */
2,CB_634,static int extract_min_max(IPAddressOrRange *aor,
2,CB_635,                           unsigned char *min, unsigned char *max, int length)
2,CB_636,{
2,CB_637,    if (aor == NULL || min == NULL || max == NULL)
2,CB_638,        return 0;
2,CB_639,    switch (aor->type) {
2,CB_640,    case IPAddressOrRange_addressPrefix:
2,CB_641,        return (addr_expand(min, aor->u.addressPrefix, length, 0x00) &&
2,CB_642,                addr_expand(max, aor->u.addressPrefix, length, 0xFF));
2,CB_643,    case IPAddressOrRange_addressRange:
2,CB_644,        return (addr_expand(min, aor->u.addressRange->min, length, 0x00) &&
2,CB_645,                addr_expand(max, aor->u.addressRange->max, length, 0xFF));
2,CB_646,    }
2,CB_647,    return 0;
2,CB_648,}
2,CB_649,
2,CB_650,/*
2,CB_651, * Public wrapper for extract_min_max().
2,CB_652, */
2,CB_653,int X509v3_addr_get_range(IPAddressOrRange *aor,
2,CB_654,                          const unsigned afi,
2,CB_655,                          unsigned char *min,
2,CB_656,                          unsigned char *max, const int length)
2,CB_657,{
2,CB_658,    int afi_length = length_from_afi(afi);
2,CB_659,    if (aor == NULL || min == NULL || max == NULL ||
2,CB_660,        afi_length == 0 || length < afi_length ||
2,CB_661,        (aor->type != IPAddressOrRange_addressPrefix &&
2,CB_662,         aor->type != IPAddressOrRange_addressRange) ||
2,CB_663,        !extract_min_max(aor, min, max, afi_length))
2,CB_664,        return 0;
2,CB_665,
2,CB_666,    return afi_length;
2,CB_667,}
2,CB_668,
2,CB_669,/*
2,CB_670, * Sort comparison function for a sequence of IPAddressFamily.
2,CB_671, *
2,CB_672, * The last paragraph of RFC 3779 2.2.3.3 is slightly ambiguous about
2,CB_673, * the ordering: I can read it as meaning that IPv6 without a SAFI
2,CB_674, * comes before IPv4 with a SAFI, which seems pretty weird.  The
2,CB_675, * examples in appendix B suggest that the author intended the
2,CB_676, * null-SAFI rule to apply only within a single AFI, which is what I
2,CB_677, * would have expected and is what the following code implements.
2,CB_678, */
2,CB_679,static int IPAddressFamily_cmp(const IPAddressFamily *const *a_,
2,CB_680,                               const IPAddressFamily *const *b_)
2,CB_681,{
2,CB_682,    const ASN1_OCTET_STRING *a = (*a_)->addressFamily;
2,CB_683,    const ASN1_OCTET_STRING *b = (*b_)->addressFamily;
2,CB_684,    int len = ((a->length <= b->length) ? a->length : b->length);
2,CB_685,    int cmp = memcmp(a->data, b->data, len);
2,CB_686,    return cmp ? cmp : a->length - b->length;
2,CB_687,}
2,CB_688,
2,CB_689,/*
2,CB_690, * Check whether an IPAddrBLocks is in canonical form.
2,CB_691, */
2,CB_692,int X509v3_addr_is_canonical(IPAddrBlocks *addr)
2,CB_693,{
2,CB_694,    unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];
2,CB_695,    unsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];
2,CB_696,    IPAddressOrRanges *aors;
2,CB_697,    int i, j, k;
2,CB_698,
2,CB_699,    /*
2,CB_700,     * Empty extension is canonical.
2,CB_701,     */
2,CB_702,    if (addr == NULL)
2,CB_703,        return 1;
2,CB_704,
2,CB_705,    /*
2,CB_706,     * Check whether the top-level list is in order.
2,CB_707,     */
2,CB_708,    for (i = 0; i < sk_IPAddressFamily_num(addr) - 1; i++) {
2,CB_709,        const IPAddressFamily *a = sk_IPAddressFamily_value(addr, i);
2,CB_710,        const IPAddressFamily *b = sk_IPAddressFamily_value(addr, i + 1);
2,CB_711,        if (IPAddressFamily_cmp(&a, &b) >= 0)
2,CB_712,            return 0;
2,CB_713,    }
2,CB_714,
2,CB_715,    /*
2,CB_716,     * Top level's ok, now check each address family.
2,CB_717,     */
2,CB_718,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CB_719,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CB_720,        int length = length_from_afi(X509v3_addr_get_afi(f));
2,CB_721,
2,CB_722,        /*
2,CB_723,         * Inheritance is canonical.  Anything other than inheritance or
2,CB_724,         * a SEQUENCE OF IPAddressOrRange is an ASN.1 error or something.
2,CB_725,         */
2,CB_726,        if (f == NULL || f->ipAddressChoice == NULL)
2,CB_727,            return 0;
2,CB_728,        switch (f->ipAddressChoice->type) {
2,CB_729,        case IPAddressChoice_inherit:
2,CB_730,            continue;
2,CB_731,        case IPAddressChoice_addressesOrRanges:
2,CB_732,            break;
2,CB_733,        default:
2,CB_734,            return 0;
2,CB_735,        }
2,CB_736,
2,CB_737,        /*
2,CB_738,         * It's an IPAddressOrRanges sequence, check it.
2,CB_739,         */
2,CB_740,        aors = f->ipAddressChoice->u.addressesOrRanges;
2,CB_741,        if (sk_IPAddressOrRange_num(aors) == 0)
2,CB_742,            return 0;
2,CB_743,        for (j = 0; j < sk_IPAddressOrRange_num(aors) - 1; j++) {
2,CB_744,            IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);
2,CB_745,            IPAddressOrRange *b = sk_IPAddressOrRange_value(aors, j + 1);
2,CB_746,
2,CB_747,            if (!extract_min_max(a, a_min, a_max, length) ||
2,CB_748,                !extract_min_max(b, b_min, b_max, length))
2,CB_749,                return 0;
2,CB_750,
2,CB_751,            /*
2,CB_752,             * Punt misordered list, overlapping start, or inverted range.
2,CB_753,             */
2,CB_754,            if (memcmp(a_min, b_min, length) >= 0 ||
2,CB_755,                memcmp(a_min, a_max, length) > 0 ||
2,CB_756,                memcmp(b_min, b_max, length) > 0)
2,CB_757,                return 0;
2,CB_758,
2,CB_759,            /*
2,CB_760,             * Punt if adjacent or overlapping.  Check for adjacency by
2,CB_761,             * subtracting one from b_min first.
2,CB_762,             */
2,CB_763,            for (k = length - 1; k >= 0 && b_min[k]-- == 0x00; k--) ;
2,CB_764,            if (memcmp(a_max, b_min, length) >= 0)
2,CB_765,                return 0;
2,CB_766,
2,CB_767,            /*
2,CB_768,             * Check for range that should be expressed as a prefix.
2,CB_769,             */
2,CB_770,            if (a->type == IPAddressOrRange_addressRange &&
2,CB_771,                range_should_be_prefix(a_min, a_max, length) >= 0)
2,CB_772,                return 0;
2,CB_773,        }
2,CB_774,
2,CB_775,        /*
2,CB_776,         * Check range to see if it's inverted or should be a
2,CB_777,         * prefix.
2,CB_778,         */
2,CB_779,        j = sk_IPAddressOrRange_num(aors) - 1;
2,CB_780,        {
2,CB_781,            IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);
2,CB_782,            if (a != NULL && a->type == IPAddressOrRange_addressRange) {
2,CB_783,                if (!extract_min_max(a, a_min, a_max, length))
2,CB_784,                    return 0;
2,CB_785,                if (memcmp(a_min, a_max, length) > 0 ||
2,CB_786,                    range_should_be_prefix(a_min, a_max, length) >= 0)
2,CB_787,                    return 0;
2,CB_788,            }
2,CB_789,        }
2,CB_790,    }
2,CB_791,
2,CB_792,    /*
2,CB_793,     * If we made it through all that, we're happy.
2,CB_794,     */
2,CB_795,    return 1;
2,CB_796,}
2,CB_797,
2,CB_798,/*
2,CB_799, * Whack an IPAddressOrRanges into canonical form.
2,CB_800, */
2,CB_801,static int IPAddressOrRanges_canonize(IPAddressOrRanges *aors,
2,CB_802,                                      const unsigned afi)
2,CB_803,{
2,CB_804,    int i, j, length = length_from_afi(afi);
2,CB_805,
2,CB_806,    /*
2,CB_807,     * Sort the IPAddressOrRanges sequence.
2,CB_808,     */
2,CB_809,    sk_IPAddressOrRange_sort(aors);
2,CB_810,
2,CB_811,    /*
2,CB_812,     * Clean up representation issues, punt on duplicates or overlaps.
2,CB_813,     */
2,CB_814,    for (i = 0; i < sk_IPAddressOrRange_num(aors) - 1; i++) {
2,CB_815,        IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, i);
2,CB_816,        IPAddressOrRange *b = sk_IPAddressOrRange_value(aors, i + 1);
2,CB_817,        unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];
2,CB_818,        unsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];
2,CB_819,
2,CB_820,        if (!extract_min_max(a, a_min, a_max, length) ||
2,CB_821,            !extract_min_max(b, b_min, b_max, length))
2,CB_822,            return 0;
2,CB_823,
2,CB_824,        /*
2,CB_825,         * Punt inverted ranges.
2,CB_826,         */
2,CB_827,        if (memcmp(a_min, a_max, length) > 0 ||
2,CB_828,            memcmp(b_min, b_max, length) > 0)
2,CB_829,            return 0;
2,CB_830,
2,CB_831,        /*
2,CB_832,         * Punt overlaps.
2,CB_833,         */
2,CB_834,        if (memcmp(a_max, b_min, length) >= 0)
2,CB_835,            return 0;
2,CB_836,
2,CB_837,        /*
2,CB_838,         * Merge if a and b are adjacent.  We check for
2,CB_839,         * adjacency by subtracting one from b_min first.
2,CB_840,         */
2,CB_841,        for (j = length - 1; j >= 0 && b_min[j]-- == 0x00; j--) ;
2,CB_842,        if (memcmp(a_max, b_min, length) == 0) {
2,CB_843,            IPAddressOrRange *merged;
2,CB_844,            if (!make_addressRange(&merged, a_min, b_max, length))
2,CB_845,                return 0;
2,CB_846,            (void)sk_IPAddressOrRange_set(aors, i, merged);
2,CB_847,            (void)sk_IPAddressOrRange_delete(aors, i + 1);
2,CB_848,            IPAddressOrRange_free(a);
2,CB_849,            IPAddressOrRange_free(b);
2,CB_850,            --i;
2,CB_851,            continue;
2,CB_852,        }
2,CB_853,    }
2,CB_854,
2,CB_855,    /*
2,CB_856,     * Check for inverted final range.
2,CB_857,     */
2,CB_858,    j = sk_IPAddressOrRange_num(aors) - 1;
2,CB_859,    {
2,CB_860,        IPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);
2,CB_861,        if (a != NULL && a->type == IPAddressOrRange_addressRange) {
2,CB_862,            unsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];
2,CB_863,            if (!extract_min_max(a, a_min, a_max, length))
2,CB_864,                return 0;
2,CB_865,            if (memcmp(a_min, a_max, length) > 0)
2,CB_866,                return 0;
2,CB_867,        }
2,CB_868,    }
2,CB_869,
2,CB_870,    return 1;
2,CB_871,}
2,CB_872,
2,CB_873,/*
2,CB_874, * Whack an IPAddrBlocks extension into canonical form.
2,CB_875, */
2,CB_876,int X509v3_addr_canonize(IPAddrBlocks *addr)
2,CB_877,{
2,CB_878,    int i;
2,CB_879,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CB_880,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CB_881,        if (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&
2,CB_882,            !IPAddressOrRanges_canonize(f->ipAddressChoice->
2,CB_883,                                        u.addressesOrRanges,
2,CB_884,                                        X509v3_addr_get_afi(f)))
2,CB_885,            return 0;
2,CB_886,    }
2,CB_887,    (void)sk_IPAddressFamily_set_cmp_func(addr, IPAddressFamily_cmp);
2,CB_888,    sk_IPAddressFamily_sort(addr);
2,CB_889,    if (!ossl_assert(X509v3_addr_is_canonical(addr)))
2,CB_890,        return 0;
2,CB_891,    return 1;
2,CB_892,}
2,CB_893,
2,CB_894,/*
2,CB_895, * v2i handler for the IPAddrBlocks extension.
2,CB_896, */
2,CB_897,static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
2,CB_898,                              struct v3_ext_ctx *ctx,
2,CB_899,                              STACK_OF(CONF_VALUE) *values)
2,CB_900,{
2,CB_901,    static const char v4addr_chars[] = "0123456789.";
2,CB_902,    static const char v6addr_chars[] = "0123456789.:abcdefABCDEF";
2,CB_903,    IPAddrBlocks *addr = NULL;
2,CB_904,    char *s = NULL, *t;
2,CB_905,    int i;
2,CB_906,
2,CB_907,    if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) {
2,CB_908,        X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CB_909,        return NULL;
2,CB_910,    }
2,CB_911,
2,CB_912,    for (i = 0; i < sk_CONF_VALUE_num(values); i++) {
2,CB_913,        CONF_VALUE *val = sk_CONF_VALUE_value(values, i);
2,CB_914,        unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN];
2,CB_915,        unsigned afi, *safi = NULL, safi_;
2,CB_916,        const char *addr_chars = NULL;
2,CB_917,        int prefixlen, i1, i2, delim, length;
2,CB_918,
2,CB_919,        if (!name_cmp(val->name, "IPv4")) {
2,CB_920,            afi = IANA_AFI_IPV4;
2,CB_921,        } else if (!name_cmp(val->name, "IPv6")) {
2,CB_922,            afi = IANA_AFI_IPV6;
2,CB_923,        } else if (!name_cmp(val->name, "IPv4-SAFI")) {
2,CB_924,            afi = IANA_AFI_IPV4;
2,CB_925,            safi = &safi_;
2,CB_926,        } else if (!name_cmp(val->name, "IPv6-SAFI")) {
2,CB_927,            afi = IANA_AFI_IPV6;
2,CB_928,            safi = &safi_;
2,CB_929,        } else {
2,CB_930,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_931,                      X509V3_R_EXTENSION_NAME_ERROR);
2,CB_932,            X509V3_conf_err(val);
2,CB_933,            goto err;
2,CB_934,        }
2,CB_935,
2,CB_936,        switch (afi) {
2,CB_937,        case IANA_AFI_IPV4:
2,CB_938,            addr_chars = v4addr_chars;
2,CB_939,            break;
2,CB_940,        case IANA_AFI_IPV6:
2,CB_941,            addr_chars = v6addr_chars;
2,CB_942,            break;
2,CB_943,        }
2,CB_944,
2,CB_945,        length = length_from_afi(afi);
2,CB_946,
2,CB_947,        /*
2,CB_948,         * Handle SAFI, if any, and OPENSSL_strdup() so we can null-terminate
2,CB_949,         * the other input values.
2,CB_950,         */
2,CB_951,        if (safi != NULL) {
2,CB_952,            *safi = strtoul(val->value, &t, 0);
2,CB_953,            t += strspn(t, " 	");
2,CB_954,            if (*safi > 0xFF || *t++ != ':') {
2,CB_955,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI);
2,CB_956,                X509V3_conf_err(val);
2,CB_957,                goto err;
2,CB_958,            }
2,CB_959,            t += strspn(t, " 	");
2,CB_960,            s = OPENSSL_strdup(t);
2,CB_961,        } else {
2,CB_962,            s = OPENSSL_strdup(val->value);
2,CB_963,        }
2,CB_964,        if (s == NULL) {
2,CB_965,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CB_966,            goto err;
2,CB_967,        }
2,CB_968,
2,CB_969,        /*
2,CB_970,         * Check for inheritance.  Not worth additional complexity to
2,CB_971,         * optimize this (seldom-used) case.
2,CB_972,         */
2,CB_973,        if (strcmp(s, "inherit") == 0) {
2,CB_974,            if (!X509v3_addr_add_inherit(addr, afi, safi)) {
2,CB_975,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_976,                          X509V3_R_INVALID_INHERITANCE);
2,CB_977,                X509V3_conf_err(val);
2,CB_978,                goto err;
2,CB_979,            }
2,CB_980,            OPENSSL_free(s);
2,CB_981,            s = NULL;
2,CB_982,            continue;
2,CB_983,        }
2,CB_984,
2,CB_985,        i1 = strspn(s, addr_chars);
2,CB_986,        i2 = i1 + strspn(s + i1, " 	");
2,CB_987,        delim = s[i2++];
2,CB_988,        s[i1] = ' ';
2,CB_989,
2,CB_990,        if (a2i_ipadd(min, s) != length) {
2,CB_991,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS);
2,CB_992,            X509V3_conf_err(val);
2,CB_993,            goto err;
2,CB_994,        }
2,CB_995,
2,CB_996,        switch (delim) {
2,CB_997,        case '/':
2,CB_998,            prefixlen = (int)strtoul(s + i2, &t, 10);
2,CB_999,            if (t == s + i2 || *t != ' ') {
2,CB_1000,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_1001,                          X509V3_R_EXTENSION_VALUE_ERROR);
2,CB_1002,                X509V3_conf_err(val);
2,CB_1003,                goto err;
2,CB_1004,            }
2,CB_1005,            if (!X509v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) {
2,CB_1006,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CB_1007,                goto err;
2,CB_1008,            }
2,CB_1009,            break;
2,CB_1010,        case '-':
2,CB_1011,            i1 = i2 + strspn(s + i2, " 	");
2,CB_1012,            i2 = i1 + strspn(s + i1, addr_chars);
2,CB_1013,            if (i1 == i2 || s[i2] != ' ') {
2,CB_1014,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_1015,                          X509V3_R_EXTENSION_VALUE_ERROR);
2,CB_1016,                X509V3_conf_err(val);
2,CB_1017,                goto err;
2,CB_1018,            }
2,CB_1019,            if (a2i_ipadd(max, s + i1) != length) {
2,CB_1020,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_1021,                          X509V3_R_INVALID_IPADDRESS);
2,CB_1022,                X509V3_conf_err(val);
2,CB_1023,                goto err;
2,CB_1024,            }
2,CB_1025,            if (memcmp(min, max, length_from_afi(afi)) > 0) {
2,CB_1026,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_1027,                          X509V3_R_EXTENSION_VALUE_ERROR);
2,CB_1028,                X509V3_conf_err(val);
2,CB_1029,                goto err;
2,CB_1030,            }
2,CB_1031,            if (!X509v3_addr_add_range(addr, afi, safi, min, max)) {
2,CB_1032,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CB_1033,                goto err;
2,CB_1034,            }
2,CB_1035,            break;
2,CB_1036,        case ' ':
2,CB_1037,            if (!X509v3_addr_add_prefix(addr, afi, safi, min, length * 8)) {
2,CB_1038,                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
2,CB_1039,                goto err;
2,CB_1040,            }
2,CB_1041,            break;
2,CB_1042,        default:
2,CB_1043,            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
2,CB_1044,                      X509V3_R_EXTENSION_VALUE_ERROR);
2,CB_1045,            X509V3_conf_err(val);
2,CB_1046,            goto err;
2,CB_1047,        }
2,CB_1048,
2,CB_1049,        OPENSSL_free(s);
2,CB_1050,        s = NULL;
2,CB_1051,    }
2,CB_1052,
2,CB_1053,    /*
2,CB_1054,     * Canonize the result, then we're done.
2,CB_1055,     */
2,CB_1056,    if (!X509v3_addr_canonize(addr))
2,CB_1057,        goto err;
2,CB_1058,    return addr;
2,CB_1059,
2,CB_1060, err:
2,CB_1061,    OPENSSL_free(s);
2,CB_1062,    sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free);
2,CB_1063,    return NULL;
2,CB_1064,}
2,CB_1065,
2,CB_1066,/*
2,CB_1067, * OpenSSL dispatch
2,CB_1068, */
2,CB_1069,const X509V3_EXT_METHOD v3_addr = {
2,CB_1070,    NID_sbgp_ipAddrBlock,       /* nid */
2,CB_1071,    0,                          /* flags */
2,CB_1072,    ASN1_ITEM_ref(IPAddrBlocks), /* template */
2,CB_1073,    0, 0, 0, 0,                 /* old functions, ignored */
2,CB_1074,    0,                          /* i2s */
2,CB_1075,    0,                          /* s2i */
2,CB_1076,    0,                          /* i2v */
2,CB_1077,    v2i_IPAddrBlocks,           /* v2i */
2,CB_1078,    i2r_IPAddrBlocks,           /* i2r */
2,CB_1079,    0,                          /* r2i */
2,CB_1080,    NULL                        /* extension-specific data */
2,CB_1081,};
2,CB_1082,
2,CB_1083,/*
2,CB_1084, * Figure out whether extension sues inheritance.
2,CB_1085, */
2,CB_1086,int X509v3_addr_inherits(IPAddrBlocks *addr)
2,CB_1087,{
2,CB_1088,    int i;
2,CB_1089,    if (addr == NULL)
2,CB_1090,        return 0;
2,CB_1091,    for (i = 0; i < sk_IPAddressFamily_num(addr); i++) {
2,CB_1092,        IPAddressFamily *f = sk_IPAddressFamily_value(addr, i);
2,CB_1093,        if (f->ipAddressChoice->type == IPAddressChoice_inherit)
2,CB_1094,            return 1;
2,CB_1095,    }
2,CB_1096,    return 0;
2,CB_1097,}
2,CB_1098,
2,CB_1099,/*
2,CB_1100, * Figure out whether parent contains child.
2,CB_1101, */
2,CB_1102,static int addr_contains(IPAddressOrRanges *parent,
2,CB_1103,                         IPAddressOrRanges *child, int length)
2,CB_1104,{
2,CB_1105,    unsigned char p_min[ADDR_RAW_BUF_LEN], p_max[ADDR_RAW_BUF_LEN];
2,CB_1106,    unsigned char c_min[ADDR_RAW_BUF_LEN], c_max[ADDR_RAW_BUF_LEN];
2,CB_1107,    int p, c;
2,CB_1108,
2,CB_1109,    if (child == NULL || parent == child)
2,CB_1110,        return 1;
2,CB_1111,    if (parent == NULL)
2,CB_1112,        return 0;
2,CB_1113,
2,CB_1114,    p = 0;
2,CB_1115,    for (c = 0; c < sk_IPAddressOrRange_num(child); c++) {
2,CB_1116,        if (!extract_min_max(sk_IPAddressOrRange_value(child, c),
2,CB_1117,                             c_min, c_max, length))
2,CB_1118,            return -1;
2,CB_1119,        for (;; p++) {
2,CB_1120,            if (p >= sk_IPAddressOrRange_num(parent))
2,CB_1121,                return 0;
2,CB_1122,            if (!extract_min_max(sk_IPAddressOrRange_value(parent, p),
2,CB_1123,                                 p_min, p_max, length))
2,CB_1124,                return 0;
2,CB_1125,            if (memcmp(p_max, c_max, length) < 0)
2,CB_1126,                continue;
2,CB_1127,            if (memcmp(p_min, c_min, length) > 0)
2,CB_1128,                return 0;
2,CB_1129,            break;
2,CB_1130,        }
2,CB_1131,    }
2,CB_1132,
2,CB_1133,    return 1;
2,CB_1134,}
2,CB_1135,
2,CB_1136,/*
2,CB_1137, * Test whether a is a subset of b.
2,CB_1138, */
2,CB_1139,int X509v3_addr_subset(IPAddrBlocks *a, IPAddrBlocks *b)
2,CB_1140,{
2,CB_1141,    int i;
2,CB_1142,    if (a == NULL || a == b)
2,CB_1143,        return 1;
2,CB_1144,    if (b == NULL || X509v3_addr_inherits(a) || X509v3_addr_inherits(b))
2,CB_1145,        return 0;
2,CB_1146,    (void)sk_IPAddressFamily_set_cmp_func(b, IPAddressFamily_cmp);
2,CB_1147,    for (i = 0; i < sk_IPAddressFamily_num(a); i++) {
2,CB_1148,        IPAddressFamily *fa = sk_IPAddressFamily_value(a, i);
2,CB_1149,        int j = sk_IPAddressFamily_find(b, fa);
2,CB_1150,        IPAddressFamily *fb;
2,CB_1151,        fb = sk_IPAddressFamily_value(b, j);
2,CB_1152,        if (fb == NULL)
2,CB_1153,            return 0;
2,CB_1154,        if (!addr_contains(fb->ipAddressChoice->u.addressesOrRanges,
2,CB_1155,                           fa->ipAddressChoice->u.addressesOrRanges,
2,CB_1156,                           length_from_afi(X509v3_addr_get_afi(fb))))
2,CB_1157,            return 0;
2,CB_1158,    }
2,CB_1159,    return 1;
2,CB_1160,}
2,CB_1161,
2,CB_1162,/*
2,CB_1163, * Validation error handling via callback.
2,CB_1164, */
2,CB_1165,#define validation_err(_err_)             do {                                      if (ctx != NULL) {                        ctx->error = _err_;                     ctx->error_depth = i;                   ctx->current_cert = x;                  ret = ctx->verify_cb(0, ctx);         } else {                                  ret = 0;                              }                                       if (!ret)                                 goto done;                          } while (0)
2,CB_1166,
2,CB_1167,/*
2,CB_1168, * Core code for RFC 3779 2.3 path validation.
2,CB_1169, *
2,CB_1170, * Returns 1 for success, 0 on error.
2,CB_1171, *
2,CB_1172, * When returning 0, ctx->error MUST be set to an appropriate value other than
2,CB_1173, * X509_V_OK.
2,CB_1174, */
2,CB_1175,static int addr_validate_path_internal(X509_STORE_CTX *ctx,
2,CB_1176,                                       STACK_OF(X509) *chain,
2,CB_1177,                                       IPAddrBlocks *ext)
2,CB_1178,{
2,CB_1179,    IPAddrBlocks *child = NULL;
2,CB_1180,    int i, j, ret = 1;
2,CB_1181,    X509 *x;
2,CB_1182,
2,CB_1183,    if (!ossl_assert(chain != NULL && sk_X509_num(chain) > 0)
2,CB_1184,            || !ossl_assert(ctx != NULL || ext != NULL)
2,CB_1185,            || !ossl_assert(ctx == NULL || ctx->verify_cb != NULL)) {
2,CB_1186,        if (ctx != NULL)
2,CB_1187,            ctx->error = X509_V_ERR_UNSPECIFIED;
2,CB_1188,        return 0;
2,CB_1189,    }
2,CB_1190,
2,CB_1191,    /*
2,CB_1192,     * Figure out where to start.  If we don't have an extension to
2,CB_1193,     * check, we're done.  Otherwise, check canonical form and
2,CB_1194,     * set up for walking up the chain.
2,CB_1195,     */
2,CB_1196,    if (ext != NULL) {
2,CB_1197,        i = -1;
2,CB_1198,        x = NULL;
2,CB_1199,    } else {
2,CB_1200,        i = 0;
2,CB_1201,        x = sk_X509_value(chain, i);
2,CB_1202,        if ((ext = x->rfc3779_addr) == NULL)
2,CB_1203,            goto done;
2,CB_1204,    }
2,CB_1205,    if (!X509v3_addr_is_canonical(ext))
2,CB_1206,        validation_err(X509_V_ERR_INVALID_EXTENSION);
2,CB_1207,    (void)sk_IPAddressFamily_set_cmp_func(ext, IPAddressFamily_cmp);
2,CB_1208,    if ((child = sk_IPAddressFamily_dup(ext)) == NULL) {
2,CB_1209,        X509V3err(X509V3_F_ADDR_VALIDATE_PATH_INTERNAL,
2,CB_1210,                  ERR_R_MALLOC_FAILURE);
2,CB_1211,        if (ctx != NULL)
2,CB_1212,            ctx->error = X509_V_ERR_OUT_OF_MEM;
2,CB_1213,        ret = 0;
2,CB_1214,        goto done;
2,CB_1215,    }
2,CB_1216,
2,CB_1217,    /*
2,CB_1218,     * Now walk up the chain.  No cert may list resources that its
2,CB_1219,     * parent doesn't list.
2,CB_1220,     */
2,CB_1221,    for (i++; i < sk_X509_num(chain); i++) {
2,CB_1222,        x = sk_X509_value(chain, i);
2,CB_1223,        if (!X509v3_addr_is_canonical(x->rfc3779_addr))
2,CB_1224,            validation_err(X509_V_ERR_INVALID_EXTENSION);
2,CB_1225,        if (x->rfc3779_addr == NULL) {
2,CB_1226,            for (j = 0; j < sk_IPAddressFamily_num(child); j++) {
2,CB_1227,                IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);
2,CB_1228,                if (fc->ipAddressChoice->type != IPAddressChoice_inherit) {
2,CB_1229,                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CB_1230,                    break;
2,CB_1231,                }
2,CB_1232,            }
2,CB_1233,            continue;
2,CB_1234,        }
2,CB_1235,        (void)sk_IPAddressFamily_set_cmp_func(x->rfc3779_addr,
2,CB_1236,                                              IPAddressFamily_cmp);
2,CB_1237,        for (j = 0; j < sk_IPAddressFamily_num(child); j++) {
2,CB_1238,            IPAddressFamily *fc = sk_IPAddressFamily_value(child, j);
2,CB_1239,            int k = sk_IPAddressFamily_find(x->rfc3779_addr, fc);
2,CB_1240,            IPAddressFamily *fp =
2,CB_1241,                sk_IPAddressFamily_value(x->rfc3779_addr, k);
2,CB_1242,            if (fp == NULL) {
2,CB_1243,                if (fc->ipAddressChoice->type ==
2,CB_1244,                    IPAddressChoice_addressesOrRanges) {
2,CB_1245,                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CB_1246,                    break;
2,CB_1247,                }
2,CB_1248,                continue;
2,CB_1249,            }
2,CB_1250,            if (fp->ipAddressChoice->type ==
2,CB_1251,                IPAddressChoice_addressesOrRanges) {
2,CB_1252,                if (fc->ipAddressChoice->type == IPAddressChoice_inherit
2,CB_1253,                    || addr_contains(fp->ipAddressChoice->u.addressesOrRanges,
2,CB_1254,                                     fc->ipAddressChoice->u.addressesOrRanges,
2,CB_1255,                                     length_from_afi(X509v3_addr_get_afi(fc))))
2,CB_1256,                    sk_IPAddressFamily_set(child, j, fp);
2,CB_1257,                else
2,CB_1258,                    validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CB_1259,            }
2,CB_1260,        }
2,CB_1261,    }
2,CB_1262,
2,CB_1263,    /*
2,CB_1264,     * Trust anchor can't inherit.
2,CB_1265,     */
2,CB_1266,    if (x->rfc3779_addr != NULL) {
2,CB_1267,        for (j = 0; j < sk_IPAddressFamily_num(x->rfc3779_addr); j++) {
2,CB_1268,            IPAddressFamily *fp =
2,CB_1269,                sk_IPAddressFamily_value(x->rfc3779_addr, j);
2,CB_1270,            if (fp->ipAddressChoice->type == IPAddressChoice_inherit
2,CB_1271,                && sk_IPAddressFamily_find(child, fp) >= 0)
2,CB_1272,                validation_err(X509_V_ERR_UNNESTED_RESOURCE);
2,CB_1273,        }
2,CB_1274,    }
2,CB_1275,
2,CB_1276, done:
2,CB_1277,    sk_IPAddressFamily_free(child);
2,CB_1278,    return ret;
2,CB_1279,}
2,CB_1280,
2,CB_1281,#undef validation_err
2,CB_1282,
2,CB_1283,/*
2,CB_1284, * RFC 3779 2.3 path validation -- called from X509_verify_cert().
2,CB_1285, */
2,CB_1286,int X509v3_addr_validate_path(X509_STORE_CTX *ctx)
2,CB_1287,{
2,CB_1288,    if (ctx->chain == NULL
2,CB_1289,            || sk_X509_num(ctx->chain) == 0
2,CB_1290,            || ctx->verify_cb == NULL) {
2,CB_1291,        ctx->error = X509_V_ERR_UNSPECIFIED;
2,CB_1292,        return 0;
2,CB_1293,    }
2,CB_1294,    return addr_validate_path_internal(ctx, ctx->chain, NULL);
2,CB_1295,}
2,CB_1296,
2,CB_1297,/*
2,CB_1298, * RFC 3779 2.3 path validation of an extension.
2,CB_1299, * Test whether chain covers extension.
2,CB_1300, */
2,CB_1301,int X509v3_addr_validate_resource_set(STACK_OF(X509) *chain,
2,CB_1302,                                  IPAddrBlocks *ext, int allow_inheritance)
2,CB_1303,{
2,CB_1304,    if (ext == NULL)
2,CB_1305,        return 1;
2,CB_1306,    if (chain == NULL || sk_X509_num(chain) == 0)
2,CB_1307,        return 0;
2,CB_1308,    if (!allow_inheritance && X509v3_addr_inherits(ext))
2,CB_1309,        return 0;
2,CB_1310,    return addr_validate_path_internal(NULL, chain, ext);
2,CB_1311,}
2,CB_1312,
2,CB_1313,#endif                          /* OPENSSL_NO_RFC3779 */
2,CB_1314,
3,CA_1,/*
3,CA_2, * Copyright 1999-2022 The OpenSSL Project Authors. All Rights Reserved.
3,CA_3, *
3,CA_4, * Licensed under the OpenSSL license (the "License").  You may not use
3,CA_5, * this file except in compliance with the License.  You can obtain a copy
3,CA_6, * in the file LICENSE in the source distribution or at
3,CA_7, * https://www.openssl.org/source/license.html
3,CA_8, */
3,CA_9,
3,CA_10,#include <stdio.h>
3,CA_11,#include "internal/cryptlib.h"
3,CA_12,#include <openssl/conf.h>
3,CA_13,#include <openssl/asn1.h>
3,CA_14,#include <openssl/asn1t.h>
3,CA_15,#include <openssl/x509v3.h>
3,CA_16,#include "ext_dat.h"
3,CA_17,
3,CA_18,/* Support for Thawte strong extranet extension */
3,CA_19,
3,CA_20,#define SXNET_TEST
3,CA_21,
3,CA_22,static int sxnet_i2r(X509V3_EXT_METHOD *method, SXNET *sx, BIO *out,
3,CA_23,                     int indent);
3,CA_24,#ifdef SXNET_TEST
3,CA_25,static SXNET *sxnet_v2i(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
3,CA_26,                        STACK_OF(CONF_VALUE) *nval);
3,CA_27,#endif
3,CA_28,const X509V3_EXT_METHOD v3_sxnet = {
3,CA_29,    NID_sxnet, X509V3_EXT_MULTILINE, ASN1_ITEM_ref(SXNET),
3,CA_30,    0, 0, 0, 0,
3,CA_31,    0, 0,
3,CA_32,    0,
3,CA_33,#ifdef SXNET_TEST
3,CA_34,    (X509V3_EXT_V2I)sxnet_v2i,
3,CA_35,#else
3,CA_36,    0,
3,CA_37,#endif
3,CA_38,    (X509V3_EXT_I2R)sxnet_i2r,
3,CA_39,    0,
3,CA_40,    NULL
3,CA_41,};
3,CA_42,
3,CA_43,ASN1_SEQUENCE(SXNETID) = {
3,CA_44,        ASN1_SIMPLE(SXNETID, zone, ASN1_INTEGER),
3,CA_45,        ASN1_SIMPLE(SXNETID, user, ASN1_OCTET_STRING)
3,CA_46,} ASN1_SEQUENCE_END(SXNETID)
3,CA_47,
3,CA_48,IMPLEMENT_ASN1_FUNCTIONS(SXNETID)
3,CA_49,
3,CA_50,ASN1_SEQUENCE(SXNET) = {
3,CA_51,        ASN1_SIMPLE(SXNET, version, ASN1_INTEGER),
3,CA_52,        ASN1_SEQUENCE_OF(SXNET, ids, SXNETID)
3,CA_53,} ASN1_SEQUENCE_END(SXNET)
3,CA_54,
3,CA_55,IMPLEMENT_ASN1_FUNCTIONS(SXNET)
3,CA_56,
3,CA_57,static int sxnet_i2r(X509V3_EXT_METHOD *method, SXNET *sx, BIO *out,
3,CA_58,                     int indent)
3,CA_59,{
3,CA_60,    int64_t v;
3,CA_61,    char *tmp;
3,CA_62,    SXNETID *id;
3,CA_63,    int i;
3,CA_64,
3,CA_65,    /*
3,CA_66,     * Since we add 1 to the version number to display it, we don't support
3,CA_67,     * LONG_MAX since that would cause on overflow.
3,CA_68,     */
3,CA_69,    if (!ASN1_INTEGER_get_int64(&v, sx->version)
3,CA_70,            || v >= LONG_MAX
3,CA_71,            || v < LONG_MIN) {
3,CA_72,        BIO_printf(out, "%*sVersion: <unsupported>", indent, "");
3,CA_73,    } else {
3,CA_74,        long vl = (long)v;
3,CA_75,
3,CA_76,        BIO_printf(out, "%*sVersion: %ld (0x%lX)", indent, "", vl + 1, vl);
3,CA_77,    }
3,CA_78,    for (i = 0; i < sk_SXNETID_num(sx->ids); i++) {
3,CA_79,        id = sk_SXNETID_value(sx->ids, i);
3,CA_80,        tmp = i2s_ASN1_INTEGER(NULL, id->zone);
3,CA_81,        BIO_printf(out, "
3,CA_82,%*sZone: %s, User: ", indent, "", tmp);
3,CA_83,        OPENSSL_free(tmp);
3,CA_84,        ASN1_STRING_print(out, id->user);
3,CA_85,    }
3,CA_86,    return 1;
3,CA_87,}
3,CA_88,
3,CA_89,#ifdef SXNET_TEST
3,CA_90,
3,CA_91,/*
3,CA_92, * NBB: this is used for testing only. It should *not* be used for anything
3,CA_93, * else because it will just take static IDs from the configuration file and
3,CA_94, * they should really be separate values for each user.
3,CA_95, */
3,CA_96,
3,CA_97,static SXNET *sxnet_v2i(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
3,CA_98,                        STACK_OF(CONF_VALUE) *nval)
3,CA_99,{
3,CA_100,    CONF_VALUE *cnf;
3,CA_101,    SXNET *sx = NULL;
3,CA_102,    int i;
3,CA_103,    for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
3,CA_104,        cnf = sk_CONF_VALUE_value(nval, i);
3,CA_105,        if (!SXNET_add_id_asc(&sx, cnf->name, cnf->value, -1))
3,CA_106,            return NULL;
3,CA_107,    }
3,CA_108,    return sx;
3,CA_109,}
3,CA_110,
3,CA_111,#endif
3,CA_112,
3,CA_113,/* Strong Extranet utility functions */
3,CA_114,
3,CA_115,/* Add an id given the zone as an ASCII number */
3,CA_116,
3,CA_117,int SXNET_add_id_asc(SXNET **psx, const char *zone, const char *user, int userlen)
3,CA_118,{
3,CA_119,    ASN1_INTEGER *izone;
3,CA_120,
3,CA_121,    if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {
3,CA_122,        X509V3err(X509V3_F_SXNET_ADD_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);
3,CA_123,        return 0;
3,CA_124,    }
3,CA_125,    return SXNET_add_id_INTEGER(psx, izone, user, userlen);
3,CA_126,}
3,CA_127,
3,CA_128,/* Add an id given the zone as an unsigned long */
3,CA_129,
3,CA_130,int SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, const char *user,
3,CA_131,                       int userlen)
3,CA_132,{
3,CA_133,    ASN1_INTEGER *izone;
3,CA_134,
3,CA_135,    if ((izone = ASN1_INTEGER_new()) == NULL
3,CA_136,        || !ASN1_INTEGER_set(izone, lzone)) {
3,CA_137,        X509V3err(X509V3_F_SXNET_ADD_ID_ULONG, ERR_R_MALLOC_FAILURE);
3,CA_138,        ASN1_INTEGER_free(izone);
3,CA_139,        return 0;
3,CA_140,    }
3,CA_141,    return SXNET_add_id_INTEGER(psx, izone, user, userlen);
3,CA_142,
3,CA_143,}
3,CA_144,
3,CA_145,/*
3,CA_146, * Add an id given the zone as an ASN1_INTEGER. Note this version uses the
3,CA_147, * passed integer and doesn't make a copy so don't free it up afterwards.
3,CA_148, */
3,CA_149,
3,CA_150,int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,
3,CA_151,                         int userlen)
3,CA_152,{
3,CA_153,    SXNET *sx = NULL;
3,CA_154,    SXNETID *id = NULL;
3,CA_155,    if (!psx || !zone || !user) {
3,CA_156,        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,
3,CA_157,                  X509V3_R_INVALID_NULL_ARGUMENT);
3,CA_158,        return 0;
3,CA_159,    }
3,CA_160,    if (userlen == -1)
3,CA_161,        userlen = strlen(user);
3,CA_162,    if (userlen > 64) {
3,CA_163,        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_USER_TOO_LONG);
3,CA_164,        return 0;
3,CA_165,    }
3,CA_166,    if (*psx == NULL) {
3,CA_167,        if ((sx = SXNET_new()) == NULL)
3,CA_168,            goto err;
3,CA_169,        if (!ASN1_INTEGER_set(sx->version, 0))
3,CA_170,            goto err;
3,CA_171,        *psx = sx;
3,CA_172,    } else
3,CA_173,        sx = *psx;
3,CA_174,    if (SXNET_get_id_INTEGER(sx, zone)) {
3,CA_175,        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_DUPLICATE_ZONE_ID);
3,CA_176,        return 0;
3,CA_177,    }
3,CA_178,
3,CA_179,    if ((id = SXNETID_new()) == NULL)
3,CA_180,        goto err;
3,CA_181,    if (userlen == -1)
3,CA_182,        userlen = strlen(user);
3,CA_183,
3,CA_184,    if (!ASN1_OCTET_STRING_set(id->user, (const unsigned char *)user, userlen))
3,CA_185,        goto err;
3,CA_186,    if (!sk_SXNETID_push(sx->ids, id))
3,CA_187,        goto err;
3,CA_188,    id->zone = zone;
3,CA_189,    return 1;
3,CA_190,
3,CA_191, err:
3,CA_192,    X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, ERR_R_MALLOC_FAILURE);
3,CA_193,    SXNETID_free(id);
3,CA_194,    SXNET_free(sx);
3,CA_195,    *psx = NULL;
3,CA_196,    return 0;
3,CA_197,}
3,CA_198,
3,CA_199,ASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, const char *zone)
3,CA_200,{
3,CA_201,    ASN1_INTEGER *izone;
3,CA_202,    ASN1_OCTET_STRING *oct;
3,CA_203,
3,CA_204,    if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {
3,CA_205,        X509V3err(X509V3_F_SXNET_GET_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);
3,CA_206,        return NULL;
3,CA_207,    }
3,CA_208,    oct = SXNET_get_id_INTEGER(sx, izone);
3,CA_209,    ASN1_INTEGER_free(izone);
3,CA_210,    return oct;
3,CA_211,}
3,CA_212,
3,CA_213,ASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)
3,CA_214,{
3,CA_215,    ASN1_INTEGER *izone;
3,CA_216,    ASN1_OCTET_STRING *oct;
3,CA_217,
3,CA_218,    if ((izone = ASN1_INTEGER_new()) == NULL
3,CA_219,        || !ASN1_INTEGER_set(izone, lzone)) {
3,CA_220,        X509V3err(X509V3_F_SXNET_GET_ID_ULONG, ERR_R_MALLOC_FAILURE);
3,CA_221,        ASN1_INTEGER_free(izone);
3,CA_222,        return NULL;
3,CA_223,    }
3,CA_224,    oct = SXNET_get_id_INTEGER(sx, izone);
3,CA_225,    ASN1_INTEGER_free(izone);
3,CA_226,    return oct;
3,CA_227,}
3,CA_228,
3,CA_229,ASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)
3,CA_230,{
3,CA_231,    SXNETID *id;
3,CA_232,    int i;
3,CA_233,    for (i = 0; i < sk_SXNETID_num(sx->ids); i++) {
3,CA_234,        id = sk_SXNETID_value(sx->ids, i);
3,CA_235,        if (!ASN1_INTEGER_cmp(id->zone, zone))
3,CA_236,            return id->user;
3,CA_237,    }
3,CA_238,    return NULL;
3,CA_239,}
3,CA_240,
3,CB_1,/*
3,CB_2, * Copyright 1999-2022 The OpenSSL Project Authors. All Rights Reserved.
3,CB_3, *
3,CB_4, * Licensed under the OpenSSL license (the "License").  You may not use
3,CB_5, * this file except in compliance with the License.  You can obtain a copy
3,CB_6, * in the file LICENSE in the source distribution or at
3,CB_7, * https://www.openssl.org/source/license.html
3,CB_8, */
3,CB_9,
3,CB_10,#include <stdio.h>
3,CB_11,#include "internal/cryptlib.h"
3,CB_12,#include <openssl/conf.h>
3,CB_13,#include <openssl/asn1.h>
3,CB_14,#include <openssl/asn1t.h>
3,CB_15,#include <openssl/x509v3.h>
3,CB_16,#include "ext_dat.h"
3,CB_17,
3,CB_18,/* Support for Thawte strong extranet extension */
3,CB_19,
3,CB_20,#define SXNET_TEST
3,CB_21,
3,CB_22,static int sxnet_i2r(X509V3_EXT_METHOD *method, SXNET *sx, BIO *out,
3,CB_23,                     int indent);
3,CB_24,#ifdef SXNET_TEST
3,CB_25,static SXNET *sxnet_v2i(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
3,CB_26,                        STACK_OF(CONF_VALUE) *nval);
3,CB_27,#endif
3,CB_28,const X509V3_EXT_METHOD v3_sxnet = {
3,CB_29,    NID_sxnet, X509V3_EXT_MULTILINE, ASN1_ITEM_ref(SXNET),
3,CB_30,    0, 0, 0, 0,
3,CB_31,    0, 0,
3,CB_32,    0,
3,CB_33,#ifdef SXNET_TEST
3,CB_34,    (X509V3_EXT_V2I)sxnet_v2i,
3,CB_35,#else
3,CB_36,    0,
3,CB_37,#endif
3,CB_38,    (X509V3_EXT_I2R)sxnet_i2r,
3,CB_39,    0,
3,CB_40,    NULL
3,CB_41,};
3,CB_42,
3,CB_43,ASN1_SEQUENCE(SXNETID) = {
3,CB_44,        ASN1_SIMPLE(SXNETID, zone, ASN1_INTEGER),
3,CB_45,        ASN1_SIMPLE(SXNETID, user, ASN1_OCTET_STRING)
3,CB_46,} ASN1_SEQUENCE_END(SXNETID)
3,CB_47,
3,CB_48,IMPLEMENT_ASN1_FUNCTIONS(SXNETID)
3,CB_49,
3,CB_50,ASN1_SEQUENCE(SXNET) = {
3,CB_51,        ASN1_SIMPLE(SXNET, version, ASN1_INTEGER),
3,CB_52,        ASN1_SEQUENCE_OF(SXNET, ids, SXNETID)
3,CB_53,} ASN1_SEQUENCE_END(SXNET)
3,CB_54,
3,CB_55,IMPLEMENT_ASN1_FUNCTIONS(SXNET)
3,CB_56,
3,CB_57,static int sxnet_i2r(X509V3_EXT_METHOD *method, SXNET *sx, BIO *out,
3,CB_58,                     int indent)
3,CB_59,{
3,CB_60,    int64_t v;
3,CB_61,    char *tmp;
3,CB_62,    SXNETID *id;
3,CB_63,    int i;
3,CB_64,
3,CB_65,    /*
3,CB_66,     * Since we add 1 to the version number to display it, we don't support
3,CB_67,     * LONG_MAX since that would cause on overflow.
3,CB_68,     */
3,CB_69,    if (!ASN1_INTEGER_get_int64(&v, sx->version)
3,CB_70,            || v >= LONG_MAX
3,CB_71,            || v < LONG_MIN) {
3,CB_72,        BIO_printf(out, "%*sVersion: <unsupported>", indent, "");
3,CB_73,    } else {
3,CB_74,        long vl = (long)v;
3,CB_75,
3,CB_76,        BIO_printf(out, "%*sVersion: %ld (0x%lX)", indent, "", vl + 1, vl);
3,CB_77,    }
3,CB_78,    for (i = 0; i < sk_SXNETID_num(sx->ids); i++) {
3,CB_79,        id = sk_SXNETID_value(sx->ids, i);
3,CB_80,        tmp = i2s_ASN1_INTEGER(NULL, id->zone);
3,B_81,        if (tmp == NULL)
3,B_82,            return 0;
3,CB_83,        BIO_printf(out, "
3,CB_84,%*sZone: %s, User: ", indent, "", tmp);
3,CB_85,        OPENSSL_free(tmp);
3,CB_86,        ASN1_STRING_print(out, id->user);
3,CB_87,    }
3,CB_88,    return 1;
3,CB_89,}
3,CB_90,
3,CB_91,#ifdef SXNET_TEST
3,CB_92,
3,CB_93,/*
3,CB_94, * NBB: this is used for testing only. It should *not* be used for anything
3,CB_95, * else because it will just take static IDs from the configuration file and
3,CB_96, * they should really be separate values for each user.
3,CB_97, */
3,CB_98,
3,CB_99,static SXNET *sxnet_v2i(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
3,CB_100,                        STACK_OF(CONF_VALUE) *nval)
3,CB_101,{
3,CB_102,    CONF_VALUE *cnf;
3,CB_103,    SXNET *sx = NULL;
3,CB_104,    int i;
3,CB_105,    for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
3,CB_106,        cnf = sk_CONF_VALUE_value(nval, i);
3,CB_107,        if (!SXNET_add_id_asc(&sx, cnf->name, cnf->value, -1))
3,CB_108,            return NULL;
3,CB_109,    }
3,CB_110,    return sx;
3,CB_111,}
3,CB_112,
3,CB_113,#endif
3,CB_114,
3,CB_115,/* Strong Extranet utility functions */
3,CB_116,
3,CB_117,/* Add an id given the zone as an ASCII number */
3,CB_118,
3,CB_119,int SXNET_add_id_asc(SXNET **psx, const char *zone, const char *user, int userlen)
3,CB_120,{
3,CB_121,    ASN1_INTEGER *izone;
3,CB_122,
3,CB_123,    if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {
3,CB_124,        X509V3err(X509V3_F_SXNET_ADD_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);
3,CB_125,        return 0;
3,CB_126,    }
3,CB_127,    return SXNET_add_id_INTEGER(psx, izone, user, userlen);
3,CB_128,}
3,CB_129,
3,CB_130,/* Add an id given the zone as an unsigned long */
3,CB_131,
3,CB_132,int SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, const char *user,
3,CB_133,                       int userlen)
3,CB_134,{
3,CB_135,    ASN1_INTEGER *izone;
3,CB_136,
3,CB_137,    if ((izone = ASN1_INTEGER_new()) == NULL
3,CB_138,        || !ASN1_INTEGER_set(izone, lzone)) {
3,CB_139,        X509V3err(X509V3_F_SXNET_ADD_ID_ULONG, ERR_R_MALLOC_FAILURE);
3,CB_140,        ASN1_INTEGER_free(izone);
3,CB_141,        return 0;
3,CB_142,    }
3,CB_143,    return SXNET_add_id_INTEGER(psx, izone, user, userlen);
3,CB_144,
3,CB_145,}
3,CB_146,
3,CB_147,/*
3,CB_148, * Add an id given the zone as an ASN1_INTEGER. Note this version uses the
3,CB_149, * passed integer and doesn't make a copy so don't free it up afterwards.
3,CB_150, */
3,CB_151,
3,CB_152,int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,
3,CB_153,                         int userlen)
3,CB_154,{
3,CB_155,    SXNET *sx = NULL;
3,CB_156,    SXNETID *id = NULL;
3,CB_157,    if (!psx || !zone || !user) {
3,CB_158,        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,
3,CB_159,                  X509V3_R_INVALID_NULL_ARGUMENT);
3,CB_160,        return 0;
3,CB_161,    }
3,CB_162,    if (userlen == -1)
3,CB_163,        userlen = strlen(user);
3,CB_164,    if (userlen > 64) {
3,CB_165,        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_USER_TOO_LONG);
3,CB_166,        return 0;
3,CB_167,    }
3,CB_168,    if (*psx == NULL) {
3,CB_169,        if ((sx = SXNET_new()) == NULL)
3,CB_170,            goto err;
3,CB_171,        if (!ASN1_INTEGER_set(sx->version, 0))
3,CB_172,            goto err;
3,CB_173,        *psx = sx;
3,CB_174,    } else
3,CB_175,        sx = *psx;
3,CB_176,    if (SXNET_get_id_INTEGER(sx, zone)) {
3,CB_177,        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_DUPLICATE_ZONE_ID);
3,CB_178,        return 0;
3,CB_179,    }
3,CB_180,
3,CB_181,    if ((id = SXNETID_new()) == NULL)
3,CB_182,        goto err;
3,CB_183,    if (userlen == -1)
3,CB_184,        userlen = strlen(user);
3,CB_185,
3,CB_186,    if (!ASN1_OCTET_STRING_set(id->user, (const unsigned char *)user, userlen))
3,CB_187,        goto err;
3,CB_188,    if (!sk_SXNETID_push(sx->ids, id))
3,CB_189,        goto err;
3,CB_190,    id->zone = zone;
3,CB_191,    return 1;
3,CB_192,
3,CB_193, err:
3,CB_194,    X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, ERR_R_MALLOC_FAILURE);
3,CB_195,    SXNETID_free(id);
3,CB_196,    SXNET_free(sx);
3,CB_197,    *psx = NULL;
3,CB_198,    return 0;
3,CB_199,}
3,CB_200,
3,CB_201,ASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, const char *zone)
3,CB_202,{
3,CB_203,    ASN1_INTEGER *izone;
3,CB_204,    ASN1_OCTET_STRING *oct;
3,CB_205,
3,CB_206,    if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {
3,CB_207,        X509V3err(X509V3_F_SXNET_GET_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);
3,CB_208,        return NULL;
3,CB_209,    }
3,CB_210,    oct = SXNET_get_id_INTEGER(sx, izone);
3,CB_211,    ASN1_INTEGER_free(izone);
3,CB_212,    return oct;
3,CB_213,}
3,CB_214,
3,CB_215,ASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)
3,CB_216,{
3,CB_217,    ASN1_INTEGER *izone;
3,CB_218,    ASN1_OCTET_STRING *oct;
3,CB_219,
3,CB_220,    if ((izone = ASN1_INTEGER_new()) == NULL
3,CB_221,        || !ASN1_INTEGER_set(izone, lzone)) {
3,CB_222,        X509V3err(X509V3_F_SXNET_GET_ID_ULONG, ERR_R_MALLOC_FAILURE);
3,CB_223,        ASN1_INTEGER_free(izone);
3,CB_224,        return NULL;
3,CB_225,    }
3,CB_226,    oct = SXNET_get_id_INTEGER(sx, izone);
3,CB_227,    ASN1_INTEGER_free(izone);
3,CB_228,    return oct;
3,CB_229,}
3,CB_230,
3,CB_231,ASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)
3,CB_232,{
3,CB_233,    SXNETID *id;
3,CB_234,    int i;
3,CB_235,    for (i = 0; i < sk_SXNETID_num(sx->ids); i++) {
3,CB_236,        id = sk_SXNETID_value(sx->ids, i);
3,CB_237,        if (!ASN1_INTEGER_cmp(id->zone, zone))
3,CB_238,            return id->user;
3,CB_239,    }
3,CB_240,    return NULL;
3,CB_241,}
3,CB_242,
